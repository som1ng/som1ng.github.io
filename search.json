[{"title":"rust逆向基础-rust基础语法","url":"/2025/10/01/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","content":"前言:拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下\nrust相比其他编程语言的优势:\nrust不通过 GC(garbage collection)机制管理内存,例如python,golang等基于GC机制的编程语言会在exe运行时不断寻找虚拟地址中无用的内存空间.这会大大降低运行速度\n\nrust使用所有权机制管理内存,这也使得它相比与手动开辟内存的c&#x2F;c++更安全\n\n\n我们rust在逆向中通常用于网络编程,游戏编程,wasm,嵌入式.所以写游戏外挂,实现检测外挂都必须要学习rust.\n语法:变量:rust中变量声明要用let.rust中每个变量类型可以自己指定,也可交给编译器推断,每个变量类型可以声明可变也可声明不可变.(注:如果要声明常量类型时,常量名一定要全大写,并且必须显示指定类型.例如 const MAX:u32=10;)\n整数类型\n有符号：i8, i16, i32, i64, i128, isize\n\n无符号：u8, u16, u32, u64, u128, usize\n\n\n浮点数\nf32（32 位单精度）\n\nf64（64 位双精度，默认）\n\n\n布尔型\ntrue\n\nfalse\n\n\nchar型字符串型\n&amp;str → 字符串切片（不可变）\n\nString → 堆分配的可变字符串\n\n\nfn main() &#123;    let n: i32= 5; // 变量后的：i32可以自己指定，也可让编译器推断    let mut i: u32 = 5; // u32 表示32位无符号整数,mut表示可变    println!(&quot;The value of n is &#123;&#125;&quot;,n); // println! 用来打印字符串到终端，n代表换行，!代表宏    println!(&quot;The value of i is &#123;&#125;&quot;,i);    i=7;    println!(&quot;The value of i is &#123;&#125;&quot;,i);    let x: f64 = 5.2;    println!(&quot;The value of x is &#123;&#125;&quot;,x);    let y: char =&#x27;d&#x27;;    println!(&quot;The value of y is &#123;&#125;&quot;,y);    let t=true;    println!(&quot;The value of t is &#123;&#125;&quot;,t);    let str: &amp;str=&quot;hello&quot;;    println!(&quot;The value of str is &#123;&#125;&quot;,str);    let mut s2: String = String::from(&quot;Hello&quot;);    s2.push_str(&quot;, Rust!&quot;);        // 可变字符串    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n\n输出结果:\nThe value of n is 5The value of i is 5The value of i is 7The value of x is 5.2The value of y is dThe value of t is trueThe value of str is helloHello, Rust!\n\n控制语句:if-else if-else// iflet n = 5;if n &lt; 0 &#123;    println!(&quot;负数&quot;);&#125; else &#123;    println!(&quot;非负数&quot;);&#125;\n\n\n\n循环\nloop 一直循环\n\nwhile 有条件的循环\n\nfor\n\n\n可以通过break跳出循环,也可以通过continue继续当前循环.这和c++是一样的\n// looplet mut counter = 0;let result = loop &#123;    counter += 1;    if counter == 10 &#123;        break counter * 2; // 返回值    &#125;&#125;;// whilelet mut i = 3;while i &gt; 0 &#123;    println!(&quot;&#123;&#125;&quot;, i);    i -= 1;&#125;// forlet arr = [10, 20, 30];for val in arr &#123;    println!(&quot;&#123;&#125;&quot;, val);&#125;\n\n\n\nMatchmatch的用法和if-else很像,但是要注意match要把所有情况包含在内,不然编译阶段就报错\nlet x = 5;match x &#123;    1 | 2 =&gt; println!(&quot;一或二&quot;),    3..=7 =&gt; println!(&quot;三到七之间&quot;), // 范围匹配    _ =&gt; println!(&quot;其他&quot;),&#125;\n\n\n\n函数函数使用基本的函数定义是fn fucnction(a:i32,b:i32) -&gt; i32其中箭头右面的是返回值类型.rust函数表达力非常强\nfn add(a:i32,b:i32)-&gt;i32&#123;    a+b //不加分号，rust会将最后一行作为返回值&#125;fn main() &#123;    let a=1;    let b=3;    let res=add(a,b);    println!(&quot;&#123;&#125;&quot;,res);//println!()是rust的输出函数，其中第一个参数必须是&quot;&quot;包裹的字符串(不能用&#x27;&#x27;替代)，第二个参数是占位符，占位符的值通过&#123;&#125;来传递&#125;\n\n闭包:闭包可以理解成python里的lambda差不多,相当于匿名函数\nfn main() &#123;    let sum=|a:i32,b:i32|-&gt;i32&#123;a+b&#125;;//这里定义时是用||包裹参数，调用时和正常函数一样    let res=sum(1,2);    println!(&quot;The sum is &#123;&#125;&quot;,res);&#125;\n\nrust复合类型枚举:简单来说，枚举（enum）就是用来表示“一个值可能属于几种互斥情况之一”，也就是“有限状态或选择”。\n换句话说，它适合表示有多种可能性，但每次只能选一个的场景。\nenum TrafficLight &#123;    Red,    Yellow,    Green,&#125;let light = TrafficLight::Red;match light &#123;    TrafficLight::Red =&gt; println!(&quot;停&quot;),    TrafficLight::Yellow =&gt; println!(&quot;准备&quot;),    TrafficLight::Green =&gt; println!(&quot;走&quot;),&#125;\n\n结构体基础:结构体和enum不一样的点在于声明结构体时,要把内部变量的类型写出来.而enum就不用\n其中对#[derive(Debug)]的解释:\n\n\n\n部分\n含义\n记忆小技巧\n\n\n\n#[]\nRust 的 属性（attribute）标记，用来告诉编译器对后面的结构体&#x2F;枚举做某些处理\n“井号括号 → 给编译器的指令”\n\n\nderive\n自动 派生&#x2F;生成实现 trait 的代码\n“derive &#x3D; 自动生成某种功能”\n\n\n(Debug)\n指定生成的 trait 是 Debug\n“Debug &#x3D; 调试打印能力”\n\n\n#[derive(Debug)]struct Node&#123;    x: i32,    y: i32&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    println!(&quot;&#123;&#125;&quot;, x);    println!(&quot;&#123;&#125;&quot;, y);    println!(&quot;&#123;:?&#125;&quot;, n); //打印结构体或enum类型，要用&#123;:?&#125;,配合结构体定义上方的#[derive(Debug)]打印结构体&#125;\n\n结构体进阶:Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 key: value 语法来实现定义：\n实例化时:\n结构体类名 {    字段名 : 字段值,    …}\n(1)在结构体内部用impl关键字实现内联函数:\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn area(x:i32,y:i32)-&gt;i32&#123;        x*y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    let s=Node::area(x, y);    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n (2)用结构体中self指针实现\nstruct Node&#123;    x: i32,    y: i32,&#125;// impl Node&#123;//     fn area(x:i32,y:i32)-&gt;i32&#123;//         x*y//     &#125;// &#125;impl Node&#123;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    //let s=Node::area(x, y);    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n(3)结构体实现构造函数\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn new(x:i32,y:i32)-&gt;Self&#123;//默认构造函数名都叫new，但这不是个关键字        Node&#123;            x:x,            y:y        &#125;    &#125;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node::new(1,2);    let x=n.x;    let y=n.y;    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n(4)self的用法:\n\nself 小写 &#x3D; 当前对象实例指针。\n\nSelf 大写 &#x3D; 当前类型名。\n\n\nself指针也分为可变和不可变的,可变的要在self前加关键字mut\n#[derive(Debug)]struct Person&#123;    name:String,    age:u32&#125;impl Person&#123;    fn new(name:String,age:u32)-&gt;Self&#123;        Person&#123;name,age&#125;    &#125;    //不可变的this指针    fn greet(&amp;self)-&gt;String&#123;        format!(&quot;Hello,my name is &#123;&#125; and I am &#123;&#125; years old.&quot;,self.name,self.age)    &#125;    //可变的this指针    fn up_age(&amp;mut self)-&gt;u32&#123;        self.age+=1;        self.age    &#125;&#125;fn main() &#123;    let a=Person::new(&quot;原子&quot;.to_string(), 18); //“原子”是静态str.&amp;str类型，要转成可变的String    println!(&quot;&#123;:#?&#125;&quot;,a); //&#123;:#?&#125;是调试格式，和&#123;:?&#125;的区别是，&#123;:#?&#125;会多出缩进，方便阅读    println!(&quot;&#123;&#125;&quot;,a.greet());    let mut b =a;    b.up_age();    println!(&quot;&#123;&#125;&quot;,b.greet());&#125;\n\n输出:\nPerson &#123;    name: &quot;原子&quot;,    age: 18,&#125;Hello,my name is 原子 and I am 18 years old.Hello,my name is 原子 and I am 19 years old.\n\nself还有一个不经常用的用法:就是如果传入参数是self(不带&amp;)的话:\nstruct Node &#123;    x: i32,    y: i32,&#125;impl Node &#123;    // 这里的 self 是按值传递，意味着把 Node 本身交给这个方法    fn into_tuple(self) -&gt; (i32, i32) &#123;        (self.x, self.y)    &#125;&#125;fn main() &#123;    let n = Node &#123; x: 1, y: 2 &#125;;    let t = n.into_tuple();  //  这里 n 被 move 走    println!(&quot;&#123;:?&#125;&quot;, t);    // println!(&quot;&#123;:?&#125;&quot;, n.x); //  报错：因为 n 的所有权已经交出，不能再用&#125;\n\n元组:1.基本定义:元组就是把多个不同类型的值组合在一起的复合类型。语法：\nlet tup: (i32, f64, char) = (500, 6.4, &#x27;a&#x27;);\n\n2.访问元素\n有两种方式：\n方式一：解构\nlet tup = (500, 6.4, &#x27;a&#x27;);let (x, y, z) = tup;println!(&quot;y 的值是: &#123;&#125;&quot;, y);\n\n方式二：点语法（下标访问）\n注意第一个元素下标是0\nlet tup = (500, 6.4, &#x27;a&#x27;);println!(&quot;第一个元素是: &#123;&#125;&quot;, tup.0);println!(&quot;第二个元素是: &#123;&#125;&quot;, tup.1);println!(&quot;第三个元素是: &#123;&#125;&quot;, tup.2);\n\n3.特点:可以包含不同类型的值\n长度固定，不能改变\n4.打印可利用{:?}来打印\n核心机制&amp;数据结构栈和堆存放\n栈 (Stack) 的特点\n\n\n后进先出 (LIFO) 的数据结构，内存分配和释放都非常快。\n\n大小在编译时必须确定。\n\n栈上的数据一般是 固定大小、生命周期明确的值。\n\n\nlet x = 42;       // i32，大小固定 4 字节let y = true;     // bool，1 字节let z = &#x27;a&#x27;;      // char，4 字节let s : &amp;str = &#x27;hello&#x27;  //静态字符串切片,长度固定,在栈上\n\n\n堆 (Heap) 的特点\n\n\n内存大小运行时才能确定。\n\n需要手动申请（在 Rust 中由所有权系统管理，避免泄漏）。\n\n分配和释放开销比栈大，但适合存放 动态大小或不确定大小的数据。\n\n\n所有权机制堆和栈上数据都有所有权的这个概念,但是栈上数据拷贝时不会move(转移所有权),而是使用copy(复制一个样本),堆会move\n栈上的数据：如果它的类型实现了 Copy trait（比如 i32、bool、char、浮点数、简单元组），那么赋值时不会发生“严格意义上的 move”，而是直接 复制一份值。\n\n所以原变量不会失效，看起来像“转移没事”。\n\n实际上这不是“move”，而是 copy。\nfn main() &#123;    let x = 10;    let y = x;  // Copy，不是 move    println!(&quot;x=&#123;&#125;, y=&#123;&#125;&quot;, x, y); //  x 还能用&#125;\n\n堆上的数据：比如 String、Vec，它们没实现 Copy，赋值时会发生 move。\n\n所有权转移后，原变量会失效，防止两个变量同时指向同一块堆内存。\n\nfn main() &#123;    let s1 = String::from(&quot;hi&quot;);    let s2 = s1;   // Move    // println!(&quot;&#123;&#125;&quot;, s1); // 报错：s1 已经失效    println!(&quot;&#123;&#125;&quot;, s2);   //  只有 s2 能用了&#125;\n\n引用和可变引用:引用 (Reference)\n\n引用本质上就是 借用 (borrow)。\n\n借用不会转移所有权，值的所有者依然是原来的变量。\n\n分为：\n不可变引用 (&amp;T)：可以有多个，但不能和可变引用同时存在。\n可变引用 (&amp;mut T)：只能有一个，且不能和不可变引用共存。(可变引用要求被引用的变量是可变的)\n\n\nfn main() &#123;    let a:String =&quot;hello world&quot;.to_string();    let r1=&amp;a; //这里就算拷贝给r1,也能成功输出    println!(&quot;&#123;&#125;&quot;,a);&#125;\n\nclone的使用:#[derive(Debug,Clone)] //必须结构体里的所有字段都是可拷贝的，才可像正常u32，i32那样使用struct man&#123;    name:String,    age:u32&#125;fn main() &#123;    let a = man&#123;        name:&quot;原子&quot;.to_string(),        age:18    &#125;;    let m=a.clone();    println!(&quot;&#123;:?&#125;&quot;,a);&#125;\n\nclone就相当于c++中的深拷贝,解决了两个指针指向同一块内存的问题,所以clone之后就可以正常赋值,并接着使用\n生命周期:生命周期用语法 &#39;a 表示：\nfn example&lt;&#x27;a&gt;(s: &amp;&#x27;a str) &#123;    println!(&quot;&#123;&#125;&quot;, s);&#125;\n\n当结构体里有引用时，必须标注生命周期：\nstruct Person&lt;&#x27;a&gt; &#123;    name: &amp;&#x27;a str,    age: u32,&#125;fn main() &#123;    let name = String::from(&quot;Alice&quot;);    let p = Person &#123; name: &amp;name, age: 20 &#125;; // name 生命周期必须 ≥ p 生命周期&#125;\n\n生命周期的核心思想:引用永远不能比它指向的数据活得长。\n编译器在编译期检查生命周期，保证安全。\n&#39;a 是标识符，用来关联多个引用的生命周期。\n常用数据结构:String:&amp;str:是String类型的一个切片.长度确定放在栈上.\nString一般长度不确定,放在堆上\n创建:let s1 = String::new();              // 空字符串let s2 = String::from(&quot;hello&quot;);      // 从字面量创建let s3 = &quot;world&quot;.to_string();        // &amp;str 转 String\n\n添加:let mut s = String::from(&quot;Hello&quot;);s.push(&#x27;!&#x27;);          // 添加单个字符s.push_str(&quot; World&quot;); // 添加字符串切片\n\n拼接:let s1 = String::from(&quot;Hello&quot;);let s2 = String::from(&quot;World&quot;);// 使用 + 或 format! 宏let s3 = s1 + &amp;s2;           // s1 被移动，s2 被借用let s4 = format!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, &quot;!!!&quot;);  // 不移动任何变量\n\n获取长度和容量let s = String::from(&quot;hello&quot;);println!(&quot;length: &#123;&#125;&quot;, s.len());    // 字节数println!(&quot;capacity: &#123;&#125;&quot;, s.capacity()); // 堆上分配的容量\n\n删除内容let mut s = String::from(&quot;Hello World&quot;);s.pop();              // 删除最后一个字符s.clear();            // 清空整个字符串\n\n索引与切片let s = String::from(&quot;hello&quot;);// let c = s[0]; //  String 不支持直接索引let slice = &amp;s[0..2]; //  切片，返回 &amp;str，必须按字节边界\n\n查找和替换let s = String::from(&quot;hello world&quot;);println!(&quot;&#123;&#125;&quot;, s.contains(&quot;world&quot;));  // trueprintln!(&quot;&#123;&#125;&quot;, s.find(&quot;world&quot;).unwrap()); // 6，找到索引let new_s = s.replace(&quot;world&quot;, &quot;Rust&quot;);println!(&quot;&#123;&#125;&quot;, new_s); // hello Rust\n\n分割字符串let s = String::from(&quot;a,b,c&quot;);let v: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();println!(&quot;&#123;:?&#125;&quot;, v); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n\n遍历let s = String::from(&quot;hello&quot;);// 遍历字符for c in s.chars() &#123;    println!(&quot;&#123;&#125;&quot;, c);&#125;// 遍历字节for b in s.bytes() &#123;    println!(&quot;&#123;&#125;&quot;, b);&#125;\n\nVector:创建:let mut v: Vec&lt;i32&gt; = Vec::new();   // 空 vectorlet mut v = vec![1, 2, 3];          // 使用宏 vec! 初始化\n\n添加元素let mut v = Vec::new();v.push(10);   // 尾部插入v.push(20);\n\n访问元素let v = vec![1, 2, 3, 4];println!(&quot;&#123;&#125;&quot;, v[0]);        // 下标访问 (可能 panic 越界)println!(&quot;&#123;:?&#125;&quot;, v.get(2));  // 安全访问 -&gt; Some(3)println!(&quot;&#123;:?&#125;&quot;, v.get(10)); // None，不会 panic\n\n修改元素let mut v = vec![10, 20, 30];v[1] = 200;\n\n删除元素let mut v = vec![1, 2, 3, 4];v.pop();          // 删除最后一个 -&gt; Some(4)v.remove(0);      // 删除指定下标 -&gt; 返回删除的元素 (这里删除 1)\n\n遍历let v = vec![10, 20, 30];for x in &amp;v &#123;              // 只读遍历    println!(&quot;&#123;&#125;&quot;, x);&#125;for x in &amp;mut v &#123;          // 可修改遍历    *x += 1;&#125;\n\nHashMap:相当于c++中stl里的map\nuse std::collections::HashMap;fn main() &#123;    // 1. 创建一个 HashMap    let mut scores = HashMap::new();    // 2. 增加（插入）元素    scores.insert(&quot;Alice&quot;, 10);    scores.insert(&quot;Bob&quot;, 20);    // 3. 修改（如果 key 已存在，会覆盖旧值）    scores.insert(&quot;Alice&quot;, 30);  // Alice 的值从 10 -&gt; 30    // 4. 访问（用 get，返回 Option&lt;&amp;V&gt;）    if let Some(score) = scores.get(&quot;Alice&quot;) &#123;        println!(&quot;Alice 的分数是 &#123;&#125;&quot;, score);    &#125;    // 5. 删除（移除某个 key）    scores.remove(&quot;Bob&quot;);    println!(&quot;&#123;:?&#125;&quot;, scores);&#125;\n\n\n","categories":["rust逆向基础"],"tags":["rust"]},{"title":"Hello World","url":"/2025/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]