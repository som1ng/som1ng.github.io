[{"title":"2025羊城杯PLUS与pyd逆向","url":"/2025/10/30/ctf%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84misc/2025%E7%BE%8A%E5%9F%8E%E6%9D%AFPLUS/","content":"前言：通过一道例题学习一下pyd逆向，pyd就是动态链接库，和dll一样，在linux平台以.so命名\n做题流程：获取方法：先用die打开pyd看py编译版本，然后在命令行对应环境运行python交互环境\n(py39) C:\\Users\\Lenovo\\OneDrive\\Desktop\\chal&gt;pythonPython 3.9.23 | packaged by conda-forge | (main, Jun  4 2025, 17:49:16) [MSC v.1929 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import init&gt;&gt;&gt; x=dir(init)&gt;&gt;&gt; print(x)[&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;__test__&#x27;, &#x27;a2b_hex&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;i&#x27;, &#x27;int&#x27;, &#x27;m&#x27;, &#x27;p&#x27;]&gt;&gt;&gt;\n先用dir看一下导入的init.pyd都有什么方法，前面以”____”开头和结尾的是python环境内置方法，我们只需要关注a2b_hex，b，c，e，exec，exit，i，int，m，p就可以\n获取pyd方法源码我们可以用inspect这个模块来获取方法的源码和属性，但只有def 方式声明的函数可以出现源码，如果是cpython方式编译的源码就会报错，只能另做分析\n#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;inspect_extract.py自动提取模块中可读取的源码，正常显示换行，并为每个对象生成独立源码文件。&quot;&quot;&quot;import sysimport osimport inspectimport importlibimport tracebackimport jsonfrom textwrap import indentdef safe_get_source(obj):    try:        return True, inspect.getsource(obj)    except Exception as e:        return False, f&quot;&#123;e.__class__.__name__&#125;: &#123;e&#125;&quot;def safe_getfile(obj):    try:        return inspect.getfile(obj)    except Exception:        return Nonedef safe_signature(obj):    try:        if callable(obj):            return str(inspect.signature(obj))        return None    except Exception as e:        return f&quot;&lt;签名不可用: &#123;e&#125;&gt;&quot;def summarize_doc(doc, limit=200):    if not doc:        return None    doc = doc.strip().replace(&quot;\\r\\n&quot;, &quot;\\n&quot;)    if len(doc) &gt; limit:        return doc[:limit] + &quot;...\\n[文档省略]&quot;    return docdef sanitize_filename(name):    for ch in &quot;\\\\/:*?\\&quot;&lt;&gt;|&quot;:        name = name.replace(ch, &quot;_&quot;)    return namedef inspect_member(name, member, output_dir):    info = &#123;        &quot;name&quot;: name,        &quot;type&quot;: type(member).__name__,        &quot;signature&quot;: safe_signature(member),        &quot;file&quot;: safe_getfile(member),        &quot;doc&quot;: summarize_doc(inspect.getdoc(member)),        &quot;source_saved&quot;: False,        &quot;source_file&quot;: None,        &quot;note&quot;: None    &#125;    ok, src = safe_get_source(member)    if ok:        filename = sanitize_filename(name) + &quot;.py&quot;        filepath = os.path.join(output_dir, filename)        with open(filepath, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            f.write(f&quot;# Source for &#123;name&#125;\\n\\n&quot;)            f.write(src)        info[&quot;source_saved&quot;] = True        info[&quot;source_file&quot;] = filepath        print(f&quot;&#123;name&#125;: 源码已保存到 &#123;filepath&#125;&quot;)    else:        info[&quot;note&quot;] = f&quot;无法获取源码: &#123;src&#125;&quot;        print(f&quot;&#123;name&#125;: &#123;src&#125;&quot;)    return infodef inspect_module(mod_name):    module = importlib.import_module(mod_name)    members = inspect.getmembers(module)    output_dir = f&quot;&#123;mod_name&#125;_source&quot;    os.makedirs(output_dir, exist_ok=True)    results = []    for name, member in members:        try:            info = inspect_member(name, member, output_dir)            results.append(info)        except Exception as e:            results.append(&#123;                &quot;name&quot;: name,                &quot;error&quot;: f&quot;&#123;e.__class__.__name__&#125;: &#123;e&#125;&quot;,                &quot;traceback&quot;: traceback.format_exc()            &#125;)    json_path = f&quot;&#123;mod_name&#125;_inspect.json&quot;    with open(json_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:        json.dump(results, f, ensure_ascii=False, indent=2)    print(f&quot;\\n所有源码已保存到文件夹: &#123;output_dir&#125;&quot;)    print(f&quot;详细信息已写入: &#123;json_path&#125;&quot;)if __name__ == &quot;__main__&quot;:    if len(sys.argv) &lt; 2:        print(&quot;用法: python inspect_extract.py &lt;模块名&gt;&quot;)         sys.exit(1)    inspect_module(sys.argv[1])\n然后发现只有三个方法可以看源码，\nb方法：\n# Source for bdef b64encode(s, altchars=None):    &quot;&quot;&quot;Encode the bytes-like object s using Base64 and return a bytes object.    Optional altchars should be a byte string of length 2 which specifies an    alternative alphabet for the &#x27;+&#x27; and &#x27;/&#x27; characters.  This allows an    application to e.g. generate url or filesystem safe Base64 strings.    &quot;&quot;&quot;    encoded = binascii.b2a_base64(s, newline=False)    if altchars is not None:        assert len(altchars) == 2, repr(altchars)        return encoded.translate(bytes.maketrans(b&#x27;+/&#x27;, altchars))    return encoded\nc方法：\n# Source for cclass Uc(RegStateManager):    &quot;&quot;&quot;Unicorn Engine class.    &quot;&quot;&quot;    @staticmethod    def __is_compliant() -&gt; bool:        &quot;&quot;&quot;Checks whether Unicorn binding version complies with Unicorn library.        Returns: `True` if versions match, `False` otherwise        &quot;&quot;&quot;        uc_maj, uc_min, _ = uc_version()        bnd_maj, bnd_min, _ = version_bind()        return (uc_maj, uc_min) == (bnd_maj, bnd_min)    def __new__(cls, arch: int, mode: int, cpu: Optional[int] = None):        # verify version compatibility with the core before doing anything        if not Uc.__is_compliant():            raise UcError(uc.UC_ERR_VERSION)        import importlib        def __uc_subclass(pkgname: str, clsname: str):            &quot;&quot;&quot;Use a lazy subclass instantiation to avoid importing unnecessary arch            classes.            &quot;&quot;&quot;            def __wrapped() -&gt; Type[Uc]:                archmod = importlib.import_module(f&#x27;.arch.&#123;pkgname&#125;&#x27;, &#x27;unicorn.unicorn_py3&#x27;)                return getattr(archmod, clsname)            return __wrapped        def __uc_generic():            return Uc        wrapped: Callable[[], Type[Uc]] = &#123;            uc.UC_ARCH_ARM     : __uc_subclass(&#x27;arm&#x27;, &#x27;UcAArch32&#x27;),            uc.UC_ARCH_ARM64   : __uc_subclass(&#x27;arm64&#x27;, &#x27;UcAArch64&#x27;),            uc.UC_ARCH_MIPS    : __uc_generic,            uc.UC_ARCH_X86     : __uc_subclass(&#x27;intel&#x27;, &#x27;UcIntel&#x27;),            uc.UC_ARCH_PPC     : __uc_generic,            uc.UC_ARCH_SPARC   : __uc_generic,            uc.UC_ARCH_M68K    : __uc_generic,            uc.UC_ARCH_RISCV   : __uc_generic,            uc.UC_ARCH_S390X   : __uc_generic,            uc.UC_ARCH_TRICORE : __uc_generic        &#125;[arch]        subclass = wrapped()        # return the appropriate unicorn subclass type        return super(Uc, cls).__new__(subclass)    def __init__(self, arch: int, mode: int, cpu: Optional[int] = None) -&gt; None:        &quot;&quot;&quot;Initialize a Unicorn engine instance.        Args:            arch: emulated architecture identifier (see UC_ARCH_* constants)            mode: emulated processor mode (see UC_MODE_* constants)            cpu: emulated cpu model (see UC_CPU_* constants) [optional]        &quot;&quot;&quot;        self._arch = arch        self._mode = mode        # initialize the unicorn instance        self._uch = uc_engine()        status = uclib.uc_open(arch, mode, ctypes.byref(self._uch))        if status != uc.UC_ERR_OK:            self._uch = None            raise UcError(status)        if cpu is not None:            self.ctl_set_cpu_model(cpu)        # we have to keep a reference to the callbacks so they do not get gc-ed        # see: https://docs.python.org/3/library/ctypes.html#callback-functions        self._callbacks: Dict[int, ctypes._FuncPointer] = &#123;&#125;        self._mmio_callbacks: Dict[Tuple[int, int], Tuple[Optional[MMIO_READ_CFUNC], Optional[MMIO_WRITE_CFUNC]]] = &#123;&#125;        self._hook_exception: Optional[Exception] = None        # create a finalizer object that will appropriately free up resources when        # this instance undergoes garbage collection.        self.__finalizer = weakref.finalize(self, Uc.release_handle, self._uch)    @staticmethod    def release_handle(uch: uc_engine) -&gt; None:        # this method and its arguments must not have any reference to the Uc instance being        # destroyed. namely, this method cannot be a bound method.        if uch:            try:                status = uclib.uc_close(uch)            # _uc might be pulled from under our feet            except:                pass            else:                if status != uc.UC_ERR_OK:                    raise UcError(status)    @property    def errno(self) -&gt; int:        &quot;&quot;&quot;Get last error number.        Returns: error number (see: UC_ERR_*)        &quot;&quot;&quot;        return uclib.uc_errno(self._uch)    ###########################    #  Emulation controllers  #    ###########################    def emu_start(self, begin: int, until: int, timeout: int = 0, count: int = 0) -&gt; None:        &quot;&quot;&quot;Start emulation from a specified address to another.        Args:            begin   : emulation starting address            until   : emulation ending address            timeout : limit emulation to a certain amount of time (milliseconds)            count   : limit emulation to a certain amount of instructions        Raises:            `UcError`   : in case emulation could not be started properly            `Exception` : in case an error has been encountered during emulation        &quot;&quot;&quot;        self._hook_exception = None        status = uclib.uc_emu_start(self._uch, begin, until, timeout, count)        if status != uc.UC_ERR_OK:            raise UcError(status)        if self._hook_exception is not None:            raise self._hook_exception    def emu_stop(self) -&gt; None:        &quot;&quot;&quot;Stop emulation.        Raises: `UcError` in case emulation could not be stopped properly        &quot;&quot;&quot;        status = uclib.uc_emu_stop(self._uch)        if status != uc.UC_ERR_OK:            raise UcError(status)    ###########################    #  CPU state accessors    #    ###########################    def _do_reg_read(self, reg_id: int, reg_obj) -&gt; int:        &quot;&quot;&quot;Private register read implementation.        Do not call directly.        &quot;&quot;&quot;        return uclib.uc_reg_read(self._uch, reg_id, reg_obj)    def _do_reg_write(self, reg_id: int, reg_obj) -&gt; int:        &quot;&quot;&quot;Private register write implementation.        Do not call directly.        &quot;&quot;&quot;        return uclib.uc_reg_write(self._uch, reg_id, reg_obj)    def _do_reg_read_batch(self, reglist, vallist, count) -&gt; int:        &quot;&quot;&quot;Private batch register read implementation.        Do not call directly.        &quot;&quot;&quot;        return uclib.uc_reg_read_batch(self._uch, reglist, vallist, count)    def _do_reg_write_batch(self, reglist, vallist, count) -&gt; int:        &quot;&quot;&quot;Private batch register write implementation.        Do not call directly.        &quot;&quot;&quot;        return uclib.uc_reg_write_batch(self._uch, reglist, vallist, count)    ###########################    #  Memory management      #    ###########################    def mem_map(self, address: int, size: int, perms: int = uc.UC_PROT_ALL) -&gt; None:        &quot;&quot;&quot;Map a memory range.        Args:            address : range base address            size    : range size (in bytes)            perms   : access protection bitmask        Raises: `UcError` in case memory could not be mapped        &quot;&quot;&quot;        assert (perms &amp; ~uc.UC_PROT_ALL) == 0, &#x27;unexpected perms bitmask&#x27;        status = uclib.uc_mem_map(self._uch, address, size, perms)        if status != uc.UC_ERR_OK:            raise UcError(status)    def mem_map_ptr(self, address: int, size: int, perms: int, ptr: int) -&gt; None:        &quot;&quot;&quot;Map a memory range and point to existing data on host memory.        Args:            address : range base address            size    : range size (in bytes)            perms   : access protection bitmask            ptr     : address of data on host memory        Raises: `UcError` in case memory could not be mapped        &quot;&quot;&quot;        assert (perms &amp; ~uc.UC_PROT_ALL) == 0, &#x27;unexpected perms bitmask&#x27;        status = uclib.uc_mem_map_ptr(self._uch, address, size, perms, ptr)        if status != uc.UC_ERR_OK:            raise UcError(status)    def mem_unmap(self, address: int, size: int) -&gt; None:        &quot;&quot;&quot;Reclaim a mapped memory range.        Args:            address : range base address            size    : range size (in bytes)        Raises: `UcError` in case memory could not be unmapped        &quot;&quot;&quot;        status = uclib.uc_mem_unmap(self._uch, address, size)        if status != uc.UC_ERR_OK:            raise UcError(status)        # TODO: this is where mmio callbacks need to be released from cache,        # but we cannot tell whether this is an mmio range. also, memory ranges        # might be split by &#x27;map_protect&#x27; after they were mapped, so the        # (start, end) tuple may not be suitable for retrieving the callbacks.        #        # here we try to do that on a best-effort basis:        rng = (address, address + size)        if rng in self._mmio_callbacks:            del self._mmio_callbacks[rng]    def mem_protect(self, address: int, size: int, perms: int = uc.UC_PROT_ALL) -&gt; None:        &quot;&quot;&quot;Modify access protection bitmask of a mapped memory range.        Args:            address : range base address            size    : range size (in bytes)            perms   : new access protection bitmask        Raises: `UcError` in case access protection bitmask could not be changed        &quot;&quot;&quot;        assert (perms &amp; ~uc.UC_PROT_ALL) == 0, &#x27;unexpected perms bitmask&#x27;        status = uclib.uc_mem_protect(self._uch, address, size, perms)        if status != uc.UC_ERR_OK:            raise UcError(status)    def mmio_map(self, address: int, size: int,            read_cb: Optional[UC_MMIO_READ_TYPE], read_ud: Any,            write_cb: Optional[UC_MMIO_WRITE_TYPE], write_ud: Any) -&gt; None:        &quot;&quot;&quot;Map an MMIO range. This method binds a memory range to read and write accessors        to simulate a hardware device. Unicorn does not allocate memory to back this range.        Args:            address  : range base address            size     : range size (in bytes)            read_cb  : read callback to invoke upon read access. if not specified, reads \\                       from the mmio range will be silently dropped            read_ud  : optional context object to pass on to the read callback            write_cb : write callback to invoke upon a write access. if not specified, writes \\                       to the mmio range will be silently dropped            write_ud : optional context object to pass on to the write callback        &quot;&quot;&quot;        @uccallback(self, MMIO_READ_CFUNC)        def __mmio_map_read_cb(uc: Uc, offset: int, size: int, key: int) -&gt; int:            assert read_cb is not None            return read_cb(uc, offset, size, read_ud)        @uccallback(self, MMIO_WRITE_CFUNC)        def __mmio_map_write_cb(uc: Uc, offset: int, size: int, value: int, key: int) -&gt; None:            assert write_cb is not None            write_cb(uc, offset, size, value, write_ud)        read_cb_fptr = read_cb and __mmio_map_read_cb        write_cb_fptr = write_cb and __mmio_map_write_cb        status = uclib.uc_mmio_map(self._uch, address, size, read_cb_fptr, 0, write_cb_fptr, 0)        if status != uc.UC_ERR_OK:            raise UcError(status)        # hold a reference to mmio callbacks        rng = (address, address + size)        self._mmio_callbacks[rng] = (read_cb_fptr, write_cb_fptr)    def mem_regions(self) -&gt; Iterator[Tuple[int, int, int]]:        &quot;&quot;&quot;Iterate through mapped memory regions.        Returns: an iterator whose elements contain begin, end and perms  properties of each range        Raises: `UcError` in case an internal error has been encountered        &quot;&quot;&quot;        regions = ctypes.POINTER(uc_mem_region)()        count = ctypes.c_uint32()        status = uclib.uc_mem_regions(self._uch, ctypes.byref(regions), ctypes.byref(count))        if status != uc.UC_ERR_OK:            raise UcError(status)        try:            for i in range(count.value):                yield regions[i].value        finally:            uclib.uc_free(regions)    def mem_read(self, address: int, size: int) -&gt; bytearray:        &quot;&quot;&quot;Read data from emulated memory subsystem.        Args:            address : source memory location            size    : amount of bytes to read        Returns: data bytes        Raises: `UcError` in case of an invalid memory access        &quot;&quot;&quot;        data = ctypes.create_string_buffer(size)        status = uclib.uc_mem_read(self._uch, address, data, size)        if status != uc.UC_ERR_OK:            raise UcError(status, address, size)        return bytearray(data)    def mem_write(self, address: int, data: bytes) -&gt; None:        &quot;&quot;&quot;Write data to emulated memory subsystem.        Args:            address : target memory location            data    : data bytes to write        Raises: `UcError` in case of an invalid memory access        &quot;&quot;&quot;        size = len(data)        status = uclib.uc_mem_write(self._uch, address, data, size)        if status != uc.UC_ERR_OK:            raise UcError(status, address, size)    ###########################    #  Event hooks management #    ###########################    def __do_hook_add(self, htype: int, fptr: ctypes._FuncPointer, begin: int, end: int, *args: ctypes.c_int) -&gt; int:        handle = uc_hook_h()        # we do not need a callback counter to reference the callback and user data anymore,        # so just pass a dummy value. that value will become the unused &#x27;key&#x27; argument        dummy = 0        status = uclib.uc_hook_add(            self._uch,            ctypes.byref(handle),            htype,            fptr,            ctypes.cast(dummy, ctypes.c_void_p),            ctypes.c_uint64(begin),            ctypes.c_uint64(end),            *args        )        if status != uc.UC_ERR_OK:            raise UcError(status)        # hold a reference to the function pointer to prevent it from being gc-ed        self._callbacks[handle.value] = fptr        return handle.value    def hook_add(self, htype: int, callback: Callable, user_data: Any = None, begin: int = 1, end: int = 0, aux1: int = 0, aux2: int = 0) -&gt; int:        &quot;&quot;&quot;Hook emulated events of a certain type.        Args:            htype     : event type(s) to hook (see UC_HOOK_* constants)            callback  : a method to call each time the hooked event occurs            user_data : an additional context to pass to the callback when it is called            begin     : address where hook scope starts            end       : address where hook scope ends            aux1      : auxiliary parameter; needed for some hook types            aux2      : auxiliary parameter; needed for some hook types        Returns: hook handle        Raises: `UcError` in case of an invalid htype value        &quot;&quot;&quot;        def __hook_intr():            @uccallback(self, HOOK_INTR_CFUNC)            def __hook_intr_cb(uc: Uc, intno: int, key: int) -&gt; None:                callback(uc, intno, user_data)            return (__hook_intr_cb,)        def __hook_insn():            # each arch is expected to overload hook_add and implement this handler on their own.            # if we got here, it means this particular architecture does not support hooking any            # instruction, and so we fail            raise UcError(uc.UC_ERR_ARG)        def __hook_code():            @uccallback(self, HOOK_CODE_CFUNC)            def __hook_code_cb(uc: Uc, address: int, size: int, key: int) -&gt; None:                callback(uc, address, size, user_data)            return (__hook_code_cb,)        def __hook_invalid_mem():            @uccallback(self, HOOK_MEM_INVALID_CFUNC)            def __hook_mem_invalid_cb(uc: Uc, access: int, address: int, size: int, value: int, key: int) -&gt; bool:                return callback(uc, access, address, size, value, user_data)            return (__hook_mem_invalid_cb,)        def __hook_mem():            @uccallback(self, HOOK_MEM_ACCESS_CFUNC)            def __hook_mem_access_cb(uc: Uc, access: int, address: int, size: int, value: int, key: int) -&gt; None:                callback(uc, access, address, size, value, user_data)            return (__hook_mem_access_cb,)        def __hook_invalid_insn():            @uccallback(self, HOOK_INSN_INVALID_CFUNC)            def __hook_insn_invalid_cb(uc: Uc, key: int) -&gt; bool:                return callback(uc, user_data)            return (__hook_insn_invalid_cb,)        def __hook_edge_gen():            @uccallback(self, HOOK_EDGE_GEN_CFUNC)            def __hook_edge_gen_cb(uc: Uc, cur: ctypes._Pointer[uc_tb], prev: ctypes._Pointer[uc_tb], key: int) -&gt; None:                callback(uc, cur.contents, prev.contents, user_data)            return (__hook_edge_gen_cb,)        def __hook_tcg_opcode():            @uccallback(self, HOOK_TCG_OPCODE_CFUNC)            def __hook_tcg_op_cb(uc: Uc, address: int, arg1: int, arg2: int, size: int, key: int) -&gt; None:                callback(uc, address, arg1, arg2, size, user_data)            opcode = ctypes.c_uint64(aux1)            flags = ctypes.c_uint64(aux2)            return (__hook_tcg_op_cb, opcode, flags)        def __hook_tlb_fill():            @uccallback(self, HOOK_TLB_FILL_CFUNC)            def __hook_tlb_fill_cb(uc: Uc, vaddr: int, access: int, entry: ctypes._Pointer[uc_tlb_entry], key: int) -&gt; bool:                return callback(uc, vaddr, access, entry.contents, user_data)            return (__hook_tlb_fill_cb,)        handlers: Dict[int, Callable[[], Tuple]] = &#123;            uc.UC_HOOK_INTR               : __hook_intr,            uc.UC_HOOK_INSN               : __hook_insn,            uc.UC_HOOK_CODE               : __hook_code,            uc.UC_HOOK_BLOCK              : __hook_code,            uc.UC_HOOK_MEM_READ_UNMAPPED  : __hook_invalid_mem,            uc.UC_HOOK_MEM_WRITE_UNMAPPED : __hook_invalid_mem,            uc.UC_HOOK_MEM_FETCH_UNMAPPED : __hook_invalid_mem,            uc.UC_HOOK_MEM_READ_PROT      : __hook_invalid_mem,            uc.UC_HOOK_MEM_WRITE_PROT     : __hook_invalid_mem,            uc.UC_HOOK_MEM_FETCH_PROT     : __hook_invalid_mem,            uc.UC_HOOK_MEM_READ           : __hook_mem,            uc.UC_HOOK_MEM_WRITE          : __hook_mem,            uc.UC_HOOK_MEM_FETCH          : __hook_mem,            # uc.UC_HOOK_MEM_READ_AFTER            uc.UC_HOOK_INSN_INVALID       : __hook_invalid_insn,            uc.UC_HOOK_EDGE_GENERATED     : __hook_edge_gen,            uc.UC_HOOK_TCG_OPCODE         : __hook_tcg_opcode,            uc.UC_HOOK_TLB_FILL           : __hook_tlb_fill        &#125;        # the same callback may be registered for multiple hook types if they        # share the same handling method. here we iterate through htype set bits        # and collect all unique handlers it refers to (no duplicates)        matched = set(handlers.get(1 &lt;&lt; n) for n in range(32) if htype &amp; (1 &lt;&lt; n))        # the set of matched handlers is expected to include exactly one element.        # more than one member indicates that htype refers to more than one handler        # at the same time, whereas callbacks cannot be assigned to different handlers.        # an empty set indicates a matching handler was not found, probably due to        # an invalid htype value        if len(matched) != 1:            raise UcError(uc.UC_ERR_ARG)        handler = matched.pop()        # a None element indicates that htype has an unrecognized bit set        if handler is None:            raise UcError(uc.UC_ERR_ARG)        fptr, *aux = handler()        return self.__do_hook_add(htype, fptr, begin, end, *aux)    def hook_del(self, handle: int) -&gt; None:        &quot;&quot;&quot;Remove an existing hook.        Args:            handle: hook handle        &quot;&quot;&quot;        h = uc_hook_h(handle)        status = uclib.uc_hook_del(self._uch, h)        if status != uc.UC_ERR_OK:            raise UcError(status)        del self._callbacks[handle]    def query(self, prop: int) -&gt; int:        &quot;&quot;&quot;Query an internal Unicorn property.        Args:            prop: property identifier (see: UC_QUERY_* constants)        Returns: property value        &quot;&quot;&quot;        result = ctypes.c_size_t()        status = uclib.uc_query(self._uch, prop, ctypes.byref(result))        if status != uc.UC_ERR_OK:            raise UcError(status, prop)        return result.value    def context_save(self) -&gt; UcContext:        &quot;&quot;&quot;Save Unicorn instance internal context.        Returns: unicorn context instance        &quot;&quot;&quot;        context = UcContext(self._uch, self._arch, self._mode)        status = uclib.uc_context_save(self._uch, context.context)        if status != uc.UC_ERR_OK:            raise UcError(status)        return context    def context_update(self, context: UcContext) -&gt; None:        &quot;&quot;&quot;Update Unicorn instance internal context.        Args:            context : unicorn context instance to copy data from        &quot;&quot;&quot;        status = uclib.uc_context_save(self._uch, context.context)        if status != uc.UC_ERR_OK:            raise UcError(status)    def context_restore(self, context: UcContext) -&gt; None:        &quot;&quot;&quot;Overwrite Unicorn instance internal context.        Args:            context : unicorn context instance to copy data from        &quot;&quot;&quot;        status = uclib.uc_context_restore(self._uch, context.context)        if status != uc.UC_ERR_OK:            raise UcError(status)    @staticmethod    def __ctl_encode(ctl: int, op: int, nargs: int) -&gt; int:        assert check_maxbits(nargs, 4), f&#x27;nargs must not exceed value of 15 (got &#123;nargs&#125;)&#x27;        assert op and check_maxbits(op, 2), f&#x27;op must not exceed value of 3 (got &#123;op&#125;)&#x27;        return (op &lt;&lt; 30) | (nargs &lt;&lt; 26) | ctl    def ctl(self, ctl: int, op: int, *args):        code = Uc.__ctl_encode(ctl, op, len(args))        status = uclib.uc_ctl(self._uch, code, *args)        if status != uc.UC_ERR_OK:            raise UcError(status)    Arg = Tuple[Type, Optional[int]]    def __ctl_r(self, ctl: int, arg0: Arg):        atype, _ = arg0        carg = atype()        self.ctl(ctl, uc.UC_CTL_IO_READ, ctypes.byref(carg))        return carg.value    def __ctl_w(self, ctl: int, *args: Arg):        cargs = (atype(avalue) for atype, avalue in args)        self.ctl(ctl, uc.UC_CTL_IO_WRITE, *cargs)    def __ctl_wr(self, ctl: int, arg0: Arg, arg1: Arg):        atype, avalue = arg0        carg0 = atype(avalue)        atype, _ = arg1        carg1 = atype()        self.ctl(ctl, uc.UC_CTL_IO_READ_WRITE, carg0, ctypes.byref(carg1))        return carg1.value    def ctl_get_mode(self) -&gt; int:        &quot;&quot;&quot;Retrieve current processor mode.        Returns: current mode (see UC_MODE_* constants)        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_UC_MODE,            (ctypes.c_int, None)        )    def ctl_get_page_size(self) -&gt; int:        &quot;&quot;&quot;Retrieve target page size.        Returns: page size in bytes        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_UC_PAGE_SIZE,            (ctypes.c_uint32, None)        )    def ctl_set_page_size(self, val: int) -&gt; None:        &quot;&quot;&quot;Set target page size.        Args:            val: page size to set (in bytes)        Raises: `UcError` in any of the following cases:          - Unicorn architecture is not ARM          - Unicorn has already completed its initialization          - Page size is not a power of 2        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_UC_PAGE_SIZE,            (ctypes.c_uint32, val)        )    def ctl_get_arch(self) -&gt; int:        &quot;&quot;&quot;Retrieve target architecture.        Returns: current architecture (see UC_ARCH_* constants)        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_UC_ARCH,            (ctypes.c_int, None)        )    def ctl_get_timeout(self) -&gt; int:        &quot;&quot;&quot;Retrieve emulation timeout.        Returns: timeout value set on emulation start        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_UC_TIMEOUT,            (ctypes.c_uint64, None)        )    def ctl_exits_enabled(self, enable: bool) -&gt; None:        &quot;&quot;&quot;Instruct Unicorn whether to respect emulation exit points or ignore them.        Args:            enable: `True` to enable exit points, `False` to ignore them        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_UC_USE_EXITS,            (ctypes.c_int, enable)        )    def ctl_get_exits_cnt(self) -&gt; int:        &quot;&quot;&quot;Retrieve emulation exit points count.        Returns: number of emulation exit points        Raises: `UcErro` if Unicorn is set to ignore exits        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_UC_EXITS_CNT,            (ctypes.c_size_t, None)        )    def ctl_get_exits(self) -&gt; Sequence[int]:        &quot;&quot;&quot;Retrieve emulation exit points.        Returns: a tuple of all emulation exit points        Raises: `UcErro` if Unicorn is set to ignore exits        &quot;&quot;&quot;        count = self.ctl_get_exits_cnt()        arr = (ctypes.c_uint64 * count)()        self.ctl(uc.UC_CTL_UC_EXITS, uc.UC_CTL_IO_READ, ctypes.cast(arr, ctypes.c_void_p), ctypes.c_size_t(count))        return tuple(arr)    def ctl_set_exits(self, exits: Sequence[int]) -&gt; None:        &quot;&quot;&quot;Set emulation exit points.        Args:            exits: a list of emulation exit points to set        Raises: `UcErro` if Unicorn is set to ignore exits        &quot;&quot;&quot;        arr = (ctypes.c_uint64 * len(exits))(*exits)        self.ctl(uc.UC_CTL_UC_EXITS, uc.UC_CTL_IO_WRITE, ctypes.cast(arr, ctypes.c_void_p), ctypes.c_size_t(len(arr)))    def ctl_get_cpu_model(self) -&gt; int:        &quot;&quot;&quot;Retrieve target processor model.        Returns: target cpu model (see UC_CPU_* constants)        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_CPU_MODEL,            (ctypes.c_int, None)        )    def ctl_set_cpu_model(self, model: int) -&gt; None:        &quot;&quot;&quot;Set target processor model.        Args:            model: cpu model to set (see UC_CPU_* constants)        Raises: `UcError` in any of the following cases:          - `model` is not a valid cpu model          - Requested cpu model is incompatible with current mode          - Unicorn has already completed its initialization        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_CPU_MODEL,            (ctypes.c_int, model)        )    def ctl_remove_cache(self, lbound: int, ubound: int) -&gt; None:        &quot;&quot;&quot;Invalidate translation cache for a specified region.        Args:            lbound: region lower bound            ubound: region upper bound        Raises: `UcError` in case the provided range bounds are invalid        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_TB_REMOVE_CACHE,            (ctypes.c_uint64, lbound),            (ctypes.c_uint64, ubound)        )    def ctl_request_cache(self, addr: int) -&gt; TBStruct:        &quot;&quot;&quot;Get translation cache info for a specified address.        Args:            addr: address to get its translation cache info        Returns: a 3-tuple containing the base address, instructions count and                size of the translation block containing the specified address        &quot;&quot;&quot;        return self.__ctl_wr(uc.UC_CTL_TB_REQUEST_CACHE,            (ctypes.c_uint64, addr),            (uc_tb, None)        )    def ctl_flush_tb(self) -&gt; None:        &quot;&quot;&quot;Flush the entire translation cache.        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_TB_FLUSH)    def ctl_set_tlb_mode(self, mode: int) -&gt; None:        &quot;&quot;&quot;Set TLB mode.        Args:            mode: tlb mode to use (see UC_TLB_* constants)        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_TLB_TYPE,            (ctypes.c_uint, mode)        )    # For backward compatibility...    def ctl_tlb_mode(self, mode: int) -&gt; None:        &quot;&quot;&quot;Deprecated, please use ctl_set_tlb_mode instead.        Args:            mode: tlb mode to use (see UC_TLB_* constants)        &quot;&quot;&quot;        warnings.warn(&#x27;Deprecated method, use ctl_set_tlb_mode&#x27;, DeprecationWarning)        self.ctl_set_tlb_mode(mode)    def ctl_get_tcg_buffer_size(self) -&gt; int:        &quot;&quot;&quot;Retrieve TCG buffer size.        Returns: buffer size (in bytes)        &quot;&quot;&quot;        return self.__ctl_r(uc.UC_CTL_TCG_BUFFER_SIZE,            (ctypes.c_uint32, None)        )    def ctl_set_tcg_buffer_size(self, size: int) -&gt; None:        &quot;&quot;&quot;Set TCG buffer size.        Args:            size: new size to set        &quot;&quot;&quot;        self.__ctl_w(uc.UC_CTL_TCG_BUFFER_SIZE,            (ctypes.c_uint32, size)        )\nm方法：\n# Source for mclass methodcaller:    &quot;&quot;&quot;    Return a callable object that calls the given method on its operand.    After f = methodcaller(&#x27;name&#x27;), the call f(r) returns r.name().    After g = methodcaller(&#x27;name&#x27;, &#x27;date&#x27;, foo=1), the call g(r) returns    r.name(&#x27;date&#x27;, foo=1).    &quot;&quot;&quot;    __slots__ = (&#x27;_name&#x27;, &#x27;_args&#x27;, &#x27;_kwargs&#x27;)    def __init__(self, name, /, *args, **kwargs):        self._name = name        if not isinstance(self._name, str):            raise TypeError(&#x27;method name must be a string&#x27;)        self._args = args        self._kwargs = kwargs    def __call__(self, obj):        return getattr(obj, self._name)(*self._args, **self._kwargs)    def __repr__(self):        args = [repr(self._name)]        args.extend(map(repr, self._args))        args.extend(&#x27;%s=%r&#x27; % (k, v) for k, v in self._kwargs.items())        return &#x27;%s.%s(%s)&#x27; % (self.__class__.__module__,                              self.__class__.__name__,                              &#x27;, &#x27;.join(args))    def __reduce__(self):        if not self._kwargs:            return self.__class__, (self._name,) + self._args        else:            from functools import partial            return partial(self.__class__, self._name, **self._kwargs), self._args\n其他的cpython编译的源码虽然看不到，但我们可以看它其他的信息\n[  &#123;    &quot;name&quot;: &quot;__builtins__&quot;,    &quot;type&quot;: &quot;module&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil&#x27; object; Ellipsis represents `...&#x27; in slices.&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: &lt;module &#x27;builtins&#x27; (built-in)&gt; is a built-in module&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__doc__&quot;,    &quot;type&quot;: &quot;NoneType&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: null,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got NoneType&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__file__&quot;,    &quot;type&quot;: &quot;str&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;str(object=&#x27;&#x27;) -&gt; str\\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\\n\\nCreate a new string object from the given object. If encoding or\\nerrors is specified, then the object must expose a data buffer...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got str&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__loader__&quot;,    &quot;type&quot;: &quot;ExtensionFileLoader&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;Loader for extension modules.\\n\\nThe constructor is designed to work with FileFinder.&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got ExtensionFileLoader&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__name__&quot;,    &quot;type&quot;: &quot;str&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;str(object=&#x27;&#x27;) -&gt; str\\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\\n\\nCreate a new string object from the given object. If encoding or\\nerrors is specified, then the object must expose a data buffer...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got str&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__package__&quot;,    &quot;type&quot;: &quot;str&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;str(object=&#x27;&#x27;) -&gt; str\\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\\n\\nCreate a new string object from the given object. If encoding or\\nerrors is specified, then the object must expose a data buffer...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got str&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__spec__&quot;,    &quot;type&quot;: &quot;ModuleSpec&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;The specification for a module, used for loading.\\n\\nA module&#x27;s spec is the source for information about the module.  For\\ndata associated with the module, including source, use the spec&#x27;s\\nloader.\\n\\n`name...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got ModuleSpec&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;__test__&quot;,    &quot;type&quot;: &quot;dict&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;dict() -&gt; new empty dictionary\\ndict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n    (key, value) pairs\\ndict(iterable) -&gt; new dictionary initialized as if via:\\n    d = &#123;&#125;\\n    for k, ...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got dict&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;a2b_hex&quot;,    &quot;type&quot;: &quot;builtin_function_or_method&quot;,    &quot;signature&quot;: &quot;(hexstr, /)&quot;,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;Binary data of hexadecimal representation.\\n\\nhexstr must contain an even number of hex digits (upper or lower case).\\nThis function is also available as \\&quot;unhexlify()\\&quot;.&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got builtin_function_or_method&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;b&quot;,    &quot;type&quot;: &quot;function&quot;,    &quot;signature&quot;: &quot;(s, altchars=None)&quot;,    &quot;file&quot;: &quot;D:\\\\anaconda\\\\envs\\\\py39\\\\lib\\\\base64.py&quot;,    &quot;doc&quot;: &quot;Encode the bytes-like object s using Base64 and return a bytes object.\\n\\nOptional altchars should be a byte string of length 2 which specifies an\\nalternative alphabet for the &#x27;+&#x27; and &#x27;/&#x27; characters.  T...\\n[文档省略]&quot;,    &quot;source_saved&quot;: true,    &quot;source_file&quot;: &quot;init_source\\\\b.py&quot;,    &quot;note&quot;: null  &#125;,  &#123;    &quot;name&quot;: &quot;c&quot;,    &quot;type&quot;: &quot;type&quot;,    &quot;signature&quot;: &quot;(arch: &#x27;int&#x27;, mode: &#x27;int&#x27;, cpu: &#x27;Optional[int]&#x27; = None)&quot;,    &quot;file&quot;: &quot;D:\\\\anaconda\\\\envs\\\\py39\\\\lib\\\\site-packages\\\\unicorn\\\\unicorn_py3\\\\unicorn.py&quot;,    &quot;doc&quot;: &quot;Unicorn Engine class.&quot;,    &quot;source_saved&quot;: true,    &quot;source_file&quot;: &quot;init_source\\\\c.py&quot;,    &quot;note&quot;: null  &#125;,  &#123;    &quot;name&quot;: &quot;e&quot;,    &quot;type&quot;: &quot;UcIntel&quot;,    &quot;signature&quot;: null,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;Unicorn subclass for Intel architecture.&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got UcIntel&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;exec&quot;,    &quot;type&quot;: &quot;cython_function_or_method&quot;,    &quot;signature&quot;: &quot;(x)&quot;,    &quot;file&quot;: null,    &quot;doc&quot;: null,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got cython_function_or_method&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;exit&quot;,    &quot;type&quot;: &quot;builtin_function_or_method&quot;,    &quot;signature&quot;: &quot;(source, globals=None, locals=None, /)&quot;,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;Evaluate the given source in the context of globals and locals.\\n\\nThe source may be a string representing a Python expression\\nor a code object as returned by compile().\\nThe globals must be a dictionary...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got builtin_function_or_method&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;i&quot;,    &quot;type&quot;: &quot;builtin_function_or_method&quot;,    &quot;signature&quot;: &quot;(prompt=None, /)&quot;,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;Read a string from standard input.  The trailing newline is stripped.\\n\\nThe prompt string, if given, is printed to standard output without a\\ntrailing newline before reading input.\\n\\nIf the user hits EOF...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got builtin_function_or_method&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;int&quot;,    &quot;type&quot;: &quot;type&quot;,    &quot;signature&quot;: &quot;&lt;签名不可用: no signature found for builtin type &lt;class &#x27;str&#x27;&gt;&gt;&quot;,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;str(object=&#x27;&#x27;) -&gt; str\\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\\n\\nCreate a new string object from the given object. If encoding or\\nerrors is specified, then the object must expose a data buffer...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: &lt;class &#x27;str&#x27;&gt; is a built-in class&quot;  &#125;,  &#123;    &quot;name&quot;: &quot;m&quot;,    &quot;type&quot;: &quot;type&quot;,    &quot;signature&quot;: &quot;&lt;签名不可用: no signature found for builtin type &lt;class &#x27;operator.methodcaller&#x27;&gt;&gt;&quot;,    &quot;file&quot;: &quot;D:\\\\anaconda\\\\envs\\\\py39\\\\lib\\\\operator.py&quot;,    &quot;doc&quot;: &quot;methodcaller(name, ...) --&gt; methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller(&#x27;name&#x27;), the call f(r) returns r.name().\\nAfter g = methodca...\\n[文档省略]&quot;,    &quot;source_saved&quot;: true,    &quot;source_file&quot;: &quot;init_source\\\\m.py&quot;,    &quot;note&quot;: null  &#125;,  &#123;    &quot;name&quot;: &quot;p&quot;,    &quot;type&quot;: &quot;builtin_function_or_method&quot;,    &quot;signature&quot;: &quot;&lt;签名不可用: no signature found for builtin &lt;built-in function print&gt;&gt;&quot;,    &quot;file&quot;: null,    &quot;doc&quot;: &quot;print(value, ..., sep=&#x27; &#x27;, end=&#x27;\\\\n&#x27;, file=sys.stdout, flush=False)\\n\\nPrints the values to a stream, or to sys.stdout by default.\\nOptional keyword arguments:\\nfile:  a file-like object (stream); defaults...\\n[文档省略]&quot;,    &quot;source_saved&quot;: false,    &quot;source_file&quot;: null,    &quot;note&quot;: &quot;无法获取源码: TypeError: module, class, method, function, traceback, frame, or code object was expected, got builtin_function_or_method&quot;  &#125;]\n比如说可以看到p是print()，i是input()等等\n\n\n\n\n名称\n实际对象\n含义\n\n\n\n\na2b_hex\nbuilt-in\n用于十六进制转字节。无关。\n\n\nb\nbase64.b64encode\nBase64 编码函数。\n\n\nc\nunicorn.Uc\n模拟器类。\n\n\ne\nUcIntel()\n模拟器实例。\n\n\nexec\n自定义（Cython 实现）\n类似 exec() 执行字符串代码。\n\n\nexit\n其实是 Python 内置 eval()（看 doc）\n所以 exit(&quot;1+2&quot;) == eval(&quot;1+2&quot;)。\n\n\ni\ninput()\n读取输入。\n\n\nint\n实际是 str()（伪装成 int）\n所以 int(30) 返回 &#39;30&#39;！\n\n\nm\noperator.methodcaller\n调用某个对象的方法的工厂函数。\n\n\np\nprint()\n打印函数。\n\n\n\n\n简化：现在把这些扔给ai用正则表达式对plus.py简化\n# Deobfuscated / formatted (text-only transform)# Mappings:# m -&gt; operator.methodcaller# b -&gt; base64.b64encode (b)# c -&gt; unicorn.Uc# e -&gt; unicorn instance (uc)# exec -&gt; exec-like function (kept as exec placeholder)# exit -&gt; converted by concatenating int(...) digits into integer literal# i -&gt; input# int -&gt; behaves as str(...) in init, replaced accordingly# p -&gt; print#from init import *;m(exec(30792292888306032), 16777216, 2097152)(e);m(exec(30792292888306032), 18874368, 65536)(e);m(exec(2018003706771258569829),16777216,exec(2154308209104587365050518702243508477825638429417674506...60128987662749468317325542233718690074933730651941880380559453),)(e);m(exec(2110235738289946063973), 44, 18939903)(e);m(exec(2018003706771258569829), 18878464, i(exec(520485229507545392928716380743873332979750615584)).encode())(e);m(exec(2110235738289946063973), 39, 18878464)(e);m(exec(2110235738289946063973), 43, 44)(e);m(exec(2110235738289946063973), 40, 7)(e);m(exec(18710084667165524261000), 16777216, 16777332)(e);p(exec(17353562600)) if (b(m(exec(7882826979490488676), 18878464, 44)(e)).decode()== exec(63649679746492988981901858995847426189422638088...77866432975817021)) else p(exec(31084432670685473)) #type:ignore\n由于methodcaller() 的第一个参数必须是字符串，说明 exec() 方法是一个把 “int” 转 “str” 的方法\n(py39) C:\\Users\\Lenovo\\OneDrive\\Desktop\\chal&gt;pythonPython 3.9.23 | packaged by conda-forge | (main, Jun  4 2025, 17:49:16) [MSC v.1929 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import init&gt;&gt;&gt; print(init.exec(7882826979490488676))mem_read&gt;&gt;&gt;\n继续替换：\n# plus.exec.pyimport base64from operator import methodcallerfrom unicorn import Uc, UC_ARCH_X86, UC_MODE_64e = Uc(UC_ARCH_X86, UC_MODE_64)methodcaller(&quot;mem_map&quot;, 16777216, 2097152)(e)methodcaller(&quot;mem_map&quot;, 18874368, 65536)(e)methodcaller(&quot;mem_write&quot;, 16777216, b&quot;\\xf3\\x0f\\x1e\\xfaUH\\x89\\xe5H\\x89&#125;\\xe8\\x89u\\xe4\\x89\\xd0\\x88E\\xe0\\xc7E\\xfc\\x00\\x00\\x00\\x00\\xebL\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x00\\x8d\\x0c\\xc5\\x00\\x00\\x00\\x00\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x002E\\xe0\\x8d4\\x01\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x00\\xc1\\xe0\\x05\\x89\\xc1\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x8d\\x14\\x0e\\x88\\x10\\x83E\\xfc\\x01\\x8bE\\xfc;E\\xe4r\\xac\\x90\\x90]&quot;,)(e)methodcaller(&quot;reg_write&quot;, 44, 18939903)(e)methodcaller(&quot;mem_write&quot;, 18878464, input(&quot;[+]input your flag: &quot;).encode())(e)methodcaller(&quot;reg_write&quot;, 39, 18878464)(e)methodcaller(&quot;reg_write&quot;, 43, 44)(e)methodcaller(&quot;reg_write&quot;, 40, 7)(e)methodcaller(&quot;emu_start&quot;, 16777216, 16777332)(e)(print(&quot;good&quot;)if (        base64.b64encode(e.mem_read(18878464, 44)).decode() == &quot;425MvHMxtLqZ3ty3RZkw3mwwulNRjkswbpkDMK+3CDCOtbe6kzAqPyrcEAI=&quot;    )elseprint(&quot;no way!&quot;))\n再把methodcaller去了\n# plus.exec.pyimport base64from unicorn import Uc, UC_ARCH_X86, UC_MODE_64e = Uc(UC_ARCH_X86, UC_MODE_64) #说明：用 Unicorn 创建 x86_64 的仿真器实例 e。e.mem_map(16777216, 2097152)e.mem_map(18874368, 65536) #说明：在虚拟地址 0x1000000（16777216）和 0x1200000（18874368）分别映射一段内存，长度分别是 0x200000（2097152）和 0x10000（65536）。这些是写入 shellcode/数据和 flag 的内存区域。e.mem_write(16777216, b&quot;\\xf3\\x0f\\x1e\\xfaUH\\x89\\xe5H\\x89&#125;\\xe8\\x89u\\xe4\\x89\\xd0\\x88E\\xe0\\xc7E\\xfc\\x00\\x00\\x00\\x00\\xebL\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x00\\x8d\\x0c\\xc5\\x00\\x00\\x00\\x00\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x002E\\xe0\\x8d4\\x01\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x00\\xc1\\xe0\\x05\\x89\\xc1\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x8d\\x14\\x0e\\x88\\x10\\x83E\\xfc\\x01\\x8bE\\xfc;E\\xe4r\\xac\\x90\\x90]&quot;)#把一段“字节串”写到 0x1000000e.reg_write(44, 18939903) #把数值 18939903 写到寄存器编号 44e.mem_write(18878464, input(&quot;[+]input your flag: &quot;).encode())e.reg_write(39, 18878464) # inpute.reg_write(43, 44) # lengthe.reg_write(40, 7) # key  #把相关寄存器设置为相应地址/值（39、43、40 为寄存器 id）。e.emu_start(16777216, 16777332) #从 0x1000000 执行到 0x1000000 + ?（结束地址 16777332），在这段内执行之前写入的 shellcode。(print(&quot;good&quot;)if (        base64.b64encode(e.mem_read(18878464, 44)).decode() == &quot;425MvHMxtLqZ3ty3RZkw3mwwulNRjkswbpkDMK+3CDCOtbe6kzAqPyrcEAI=&quot;    )elseprint(&quot;no way!&quot;))\n现在分析那段字节串代表的指令：\ndata = b&quot;\\xf3\\x0f\\x1e\\xfaUH\\x89\\xe5H\\x89&#125;\\xe8\\x89u\\xe4\\x89\\xd0\\x88E\\xe0\\xc7E\\xfc\\x00\\x00\\x00\\x00\\xebL\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x00\\x8d\\x0c\\xc5\\x00\\x00\\x00\\x00\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x002E\\xe0\\x8d4\\x01\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x0f\\xb6\\x00\\xc1\\xe0\\x05\\x89\\xc1\\x8bU\\xfcH\\x8bE\\xe8H\\x01\\xd0\\x8d\\x14\\x0e\\x88\\x10\\x83E\\xfc\\x01\\x8bE\\xfc;E\\xe4r\\xac\\x90\\x90&quot;with open(r&quot;C:\\Users\\Lenovo\\OneDrive\\Desktop\\chal\\code.bin&quot;, &quot;wb&quot;) as f:    f.write(data)\n然后用ida打开这个code.bin就可以看到反汇编逻辑了\n\n获取函数参数那怎么看这个反汇编传的参数都是什么呢？\ne.reg_write(39, 18878464) # inpute.reg_write(43, 44) # lengthe.reg_write(40, 7) # key  #把相关寄存器设置为相应地址/值（39、43、40 为寄存器 id）。\n这里它把对应寄存器编号赋值，我们可以打印一下这些编号对应寄存器\nUnicorn 使用 统一的常量命名，UC_X86_REG_* 代表 x86/x86-64 的寄存器。\nimport unicorn.x86_const as xcimport unicornimport jsonfrom pprint import pprint# unicorn 版本信息（可选）try:    ver = unicorn.__version__except Exception:    ver = &quot;&lt;unknown&gt;&quot;# 收集 UC_X86_REG_* 常量consts = &#123;name: getattr(xc, name) for name in dir(xc) if name.startswith(&quot;UC_X86_REG_&quot;)&#125;# 反查表： value -&gt; name (若有冲突，保留列表)inv = &#123;&#125;for name, val in consts.items():    inv.setdefault(val, []).append(name)# 输出信息print(&quot;unicorn version:&quot;, ver)print(&quot;Total UC_X86_REG_* constants:&quot;, len(consts))print(&quot;\\n-- 常量按数值排序（value -&gt; name） --\\n&quot;)for val in sorted(inv):    names = &quot;, &quot;.join(inv[val])    print(f&quot;&#123;val:4d&#125; -&gt; &#123;names&#125;&quot;)(43))\n(py39) C:\\Users\\Lenovo\\OneDrive\\Desktop\\chal&gt;python 2.pyunicorn version: 2.1.4Total UC_X86_REG_* constants: 240-- 常量按数值排序（value -&gt; name） --   0 -&gt; UC_X86_REG_INVALID   1 -&gt; UC_X86_REG_AH   2 -&gt; UC_X86_REG_AL   3 -&gt; UC_X86_REG_AX   4 -&gt; UC_X86_REG_BH   5 -&gt; UC_X86_REG_BL   6 -&gt; UC_X86_REG_BP   7 -&gt; UC_X86_REG_BPL   8 -&gt; UC_X86_REG_BX   9 -&gt; UC_X86_REG_CH  10 -&gt; UC_X86_REG_CL  11 -&gt; UC_X86_REG_CS  12 -&gt; UC_X86_REG_CX  13 -&gt; UC_X86_REG_DH  14 -&gt; UC_X86_REG_DI  15 -&gt; UC_X86_REG_DIL  16 -&gt; UC_X86_REG_DL  17 -&gt; UC_X86_REG_DS  18 -&gt; UC_X86_REG_DX  19 -&gt; UC_X86_REG_EAX  20 -&gt; UC_X86_REG_EBP  21 -&gt; UC_X86_REG_EBX  22 -&gt; UC_X86_REG_ECX  23 -&gt; UC_X86_REG_EDI  24 -&gt; UC_X86_REG_EDX  25 -&gt; UC_X86_REG_EFLAGS  26 -&gt; UC_X86_REG_EIP  28 -&gt; UC_X86_REG_ES  29 -&gt; UC_X86_REG_ESI  30 -&gt; UC_X86_REG_ESP  31 -&gt; UC_X86_REG_FPSW  32 -&gt; UC_X86_REG_FS  33 -&gt; UC_X86_REG_GS  34 -&gt; UC_X86_REG_IP  35 -&gt; UC_X86_REG_RAX  36 -&gt; UC_X86_REG_RBP  37 -&gt; UC_X86_REG_RBX  38 -&gt; UC_X86_REG_RCX  39 -&gt; UC_X86_REG_RDI  40 -&gt; UC_X86_REG_RDX  41 -&gt; UC_X86_REG_RIP  43 -&gt; UC_X86_REG_RSI  44 -&gt; UC_X86_REG_RSP  45 -&gt; UC_X86_REG_SI  46 -&gt; UC_X86_REG_SIL  47 -&gt; UC_X86_REG_SP  48 -&gt; UC_X86_REG_SPL  49 -&gt; UC_X86_REG_SS  50 -&gt; UC_X86_REG_CR0  51 -&gt; UC_X86_REG_CR1  52 -&gt; UC_X86_REG_CR2  53 -&gt; UC_X86_REG_CR3  54 -&gt; UC_X86_REG_CR4  58 -&gt; UC_X86_REG_CR8  66 -&gt; UC_X86_REG_DR0  67 -&gt; UC_X86_REG_DR1  68 -&gt; UC_X86_REG_DR2  69 -&gt; UC_X86_REG_DR3  70 -&gt; UC_X86_REG_DR4  71 -&gt; UC_X86_REG_DR5  72 -&gt; UC_X86_REG_DR6  73 -&gt; UC_X86_REG_DR7  82 -&gt; UC_X86_REG_FP0  83 -&gt; UC_X86_REG_FP1  84 -&gt; UC_X86_REG_FP2  85 -&gt; UC_X86_REG_FP3  86 -&gt; UC_X86_REG_FP4  87 -&gt; UC_X86_REG_FP5  88 -&gt; UC_X86_REG_FP6  89 -&gt; UC_X86_REG_FP7  90 -&gt; UC_X86_REG_K0  91 -&gt; UC_X86_REG_K1  92 -&gt; UC_X86_REG_K2  93 -&gt; UC_X86_REG_K3  94 -&gt; UC_X86_REG_K4  95 -&gt; UC_X86_REG_K5  96 -&gt; UC_X86_REG_K6  97 -&gt; UC_X86_REG_K7  98 -&gt; UC_X86_REG_MM0  99 -&gt; UC_X86_REG_MM1 100 -&gt; UC_X86_REG_MM2 101 -&gt; UC_X86_REG_MM3 102 -&gt; UC_X86_REG_MM4 103 -&gt; UC_X86_REG_MM5 104 -&gt; UC_X86_REG_MM6 105 -&gt; UC_X86_REG_MM7 106 -&gt; UC_X86_REG_R8 107 -&gt; UC_X86_REG_R9 108 -&gt; UC_X86_REG_R10 109 -&gt; UC_X86_REG_R11 110 -&gt; UC_X86_REG_R12 111 -&gt; UC_X86_REG_R13 112 -&gt; UC_X86_REG_R14 113 -&gt; UC_X86_REG_R15 114 -&gt; UC_X86_REG_ST0 115 -&gt; UC_X86_REG_ST1 116 -&gt; UC_X86_REG_ST2 117 -&gt; UC_X86_REG_ST3 118 -&gt; UC_X86_REG_ST4 119 -&gt; UC_X86_REG_ST5 120 -&gt; UC_X86_REG_ST6 121 -&gt; UC_X86_REG_ST7 122 -&gt; UC_X86_REG_XMM0 123 -&gt; UC_X86_REG_XMM1 124 -&gt; UC_X86_REG_XMM2 125 -&gt; UC_X86_REG_XMM3 126 -&gt; UC_X86_REG_XMM4 127 -&gt; UC_X86_REG_XMM5 128 -&gt; UC_X86_REG_XMM6 129 -&gt; UC_X86_REG_XMM7 130 -&gt; UC_X86_REG_XMM8 131 -&gt; UC_X86_REG_XMM9 132 -&gt; UC_X86_REG_XMM10 133 -&gt; UC_X86_REG_XMM11 134 -&gt; UC_X86_REG_XMM12 135 -&gt; UC_X86_REG_XMM13 136 -&gt; UC_X86_REG_XMM14 137 -&gt; UC_X86_REG_XMM15 138 -&gt; UC_X86_REG_XMM16 139 -&gt; UC_X86_REG_XMM17 140 -&gt; UC_X86_REG_XMM18 141 -&gt; UC_X86_REG_XMM19 142 -&gt; UC_X86_REG_XMM20 143 -&gt; UC_X86_REG_XMM21 144 -&gt; UC_X86_REG_XMM22 145 -&gt; UC_X86_REG_XMM23 146 -&gt; UC_X86_REG_XMM24 147 -&gt; UC_X86_REG_XMM25 148 -&gt; UC_X86_REG_XMM26 149 -&gt; UC_X86_REG_XMM27 150 -&gt; UC_X86_REG_XMM28 151 -&gt; UC_X86_REG_XMM29 152 -&gt; UC_X86_REG_XMM30 153 -&gt; UC_X86_REG_XMM31 154 -&gt; UC_X86_REG_YMM0 155 -&gt; UC_X86_REG_YMM1 156 -&gt; UC_X86_REG_YMM2 157 -&gt; UC_X86_REG_YMM3 158 -&gt; UC_X86_REG_YMM4 159 -&gt; UC_X86_REG_YMM5 160 -&gt; UC_X86_REG_YMM6 161 -&gt; UC_X86_REG_YMM7 162 -&gt; UC_X86_REG_YMM8 163 -&gt; UC_X86_REG_YMM9 164 -&gt; UC_X86_REG_YMM10 165 -&gt; UC_X86_REG_YMM11 166 -&gt; UC_X86_REG_YMM12 167 -&gt; UC_X86_REG_YMM13 168 -&gt; UC_X86_REG_YMM14 169 -&gt; UC_X86_REG_YMM15 170 -&gt; UC_X86_REG_YMM16 171 -&gt; UC_X86_REG_YMM17 172 -&gt; UC_X86_REG_YMM18 173 -&gt; UC_X86_REG_YMM19 174 -&gt; UC_X86_REG_YMM20 175 -&gt; UC_X86_REG_YMM21 176 -&gt; UC_X86_REG_YMM22 177 -&gt; UC_X86_REG_YMM23 178 -&gt; UC_X86_REG_YMM24 179 -&gt; UC_X86_REG_YMM25 180 -&gt; UC_X86_REG_YMM26 181 -&gt; UC_X86_REG_YMM27 182 -&gt; UC_X86_REG_YMM28 183 -&gt; UC_X86_REG_YMM29 184 -&gt; UC_X86_REG_YMM30 185 -&gt; UC_X86_REG_YMM31 186 -&gt; UC_X86_REG_ZMM0 187 -&gt; UC_X86_REG_ZMM1 188 -&gt; UC_X86_REG_ZMM2 189 -&gt; UC_X86_REG_ZMM3 190 -&gt; UC_X86_REG_ZMM4 191 -&gt; UC_X86_REG_ZMM5 192 -&gt; UC_X86_REG_ZMM6 193 -&gt; UC_X86_REG_ZMM7 194 -&gt; UC_X86_REG_ZMM8 195 -&gt; UC_X86_REG_ZMM9 196 -&gt; UC_X86_REG_ZMM10 197 -&gt; UC_X86_REG_ZMM11 198 -&gt; UC_X86_REG_ZMM12 199 -&gt; UC_X86_REG_ZMM13 200 -&gt; UC_X86_REG_ZMM14 201 -&gt; UC_X86_REG_ZMM15 202 -&gt; UC_X86_REG_ZMM16 203 -&gt; UC_X86_REG_ZMM17 204 -&gt; UC_X86_REG_ZMM18 205 -&gt; UC_X86_REG_ZMM19 206 -&gt; UC_X86_REG_ZMM20 207 -&gt; UC_X86_REG_ZMM21 208 -&gt; UC_X86_REG_ZMM22 209 -&gt; UC_X86_REG_ZMM23 210 -&gt; UC_X86_REG_ZMM24 211 -&gt; UC_X86_REG_ZMM25 212 -&gt; UC_X86_REG_ZMM26 213 -&gt; UC_X86_REG_ZMM27 214 -&gt; UC_X86_REG_ZMM28 215 -&gt; UC_X86_REG_ZMM29 216 -&gt; UC_X86_REG_ZMM30 217 -&gt; UC_X86_REG_ZMM31 218 -&gt; UC_X86_REG_R8B 219 -&gt; UC_X86_REG_R9B 220 -&gt; UC_X86_REG_R10B 221 -&gt; UC_X86_REG_R11B 222 -&gt; UC_X86_REG_R12B 223 -&gt; UC_X86_REG_R13B 224 -&gt; UC_X86_REG_R14B 225 -&gt; UC_X86_REG_R15B 226 -&gt; UC_X86_REG_R8D 227 -&gt; UC_X86_REG_R9D 228 -&gt; UC_X86_REG_R10D 229 -&gt; UC_X86_REG_R11D 230 -&gt; UC_X86_REG_R12D 231 -&gt; UC_X86_REG_R13D 232 -&gt; UC_X86_REG_R14D 233 -&gt; UC_X86_REG_R15D 234 -&gt; UC_X86_REG_R8W 235 -&gt; UC_X86_REG_R9W 236 -&gt; UC_X86_REG_R10W 237 -&gt; UC_X86_REG_R11W 238 -&gt; UC_X86_REG_R12W 239 -&gt; UC_X86_REG_R13W 240 -&gt; UC_X86_REG_R14W 241 -&gt; UC_X86_REG_R15W 242 -&gt; UC_X86_REG_IDTR 243 -&gt; UC_X86_REG_GDTR 244 -&gt; UC_X86_REG_LDTR 245 -&gt; UC_X86_REG_TR 246 -&gt; UC_X86_REG_FPCW 247 -&gt; UC_X86_REG_FPTAG 248 -&gt; UC_X86_REG_MSR 249 -&gt; UC_X86_REG_MXCSR 250 -&gt; UC_X86_REG_FS_BASE 251 -&gt; UC_X86_REG_GS_BASE 252 -&gt; UC_X86_REG_FLAGS 253 -&gt; UC_X86_REG_RFLAGS 254 -&gt; UC_X86_REG_FIP 255 -&gt; UC_X86_REG_FCS 256 -&gt; UC_X86_REG_FDP 257 -&gt; UC_X86_REG_FDS 258 -&gt; UC_X86_REG_FOP 259 -&gt; UC_X86_REG_ENDINGRSI\n64 位下：函数参数主要是 通过寄存器传递 的，而不是栈。前 6 个参数分别放在：\n\nrdi → 第 1 个参数\n\nrsi → 第 2 个参数\n\nrdx → 第 3 个参数\n\nrcx → 第 4 个参数\n\nr8 → 第 5 个参数\n\nr9 → 第 6 个参数\n\n\n所以a3就是key也就是7\nexp：import base64def decrypt(data: bytes, key: int) -&gt; bytes:    result = bytearray()    for e in data:        for b in range(256):            if (40 * b + (key ^ b)) &amp; 0xFF == e:                    result.append(b)                    break    return bytes(result)if __name__ == &quot;__main__&quot;:    enc = &quot;425MvHMxtLqZ3ty3RZkw3mwwulNRjkswbpkDMK+3CDCOtbe6kzAqPyrcEAI=&quot;    b = base64.b64decode(enc)    dec = decrypt(b, 7)try:    print(dec.decode(&quot;utf-8&quot;))except UnicodeDecodeError as e:    print(e)or as e:print(e)\nflag：DASCTF{un1c0rn_1s_u4fal_And_h0w_ab0ut_exec?}\nreference：2025 羊城杯网络安全大赛 线上初赛 逆向 PLUS Writeup | CN-SEC 中文网\n","categories":["ctf逆向中的misc","py逆向"],"tags":["pyd逆向"]},{"title":"py逆向做题总结","url":"/2025/10/23/ctf%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84misc/py%E5%81%9A%E9%A2%98/","content":"题目给了exe或者直接给了pyc文件处理exe（解包为 pyc 文件）有的题直接给 .exe 文件，这通常是 PyInstaller 打包的 Python 程序。我们需要先将 .exe 提取出 .pyc 文件夹。\n使用工具：pyinstxtractor.py\nGitHub地址: https://github.com/extremecoders-re/pyinstxtractor\n作用：从 PyInstaller 打包的 exe/elf 文件中提取出 .pyc 文件与资源。\n支持：Python 2.x / 3.x 各版本（与目标程序相同版本最稳）\n\n使用# 用对应 Python 版本运行（与目标 exe 一致！）python pyinstxtractor.py target.exe\n运行后会生成 target.exe_extracted/ 文件夹。在里面可以看到 .pyc 文件和 PYZ-00.pyz_extracted/ 目录。\n注意事项\n反编译出的 .pyc 文件魔数要正确：\n每个 Python 版本的魔数（magic number）不同；\n可以从同版本的 struct.pyc 或官方魔数表复制。\n\n\n\n\n\n\n\nPython版本\n魔数字节\n\n\n\n\nPy2.x\n8字节（magic + timestamp）\n\n\nPy3.0–3.2\n12字节（magic + timestamp + size）\n\n\nPy3.3+\n16字节（magic + flags + timestamp/hash）\n\n\n\n\n\n一定要用与原程序一致的 Python 版本运行 pyinstxtractor.py，否则解包后的 PYZ-00.pyz_extracted 可能是空的。\n\n\n处理 pyc 文件解包后获得 .pyc 文件，我们需要将其反编译成 .py 源码。\n\n工具一：uncompyle6\nGitHub: https://github.com/rocky/python-uncompyle6\n支持 Python 1.5 ~ 3.7，部分支持 3.8、3.9。\nPyPI安装：\n\npip install uncompyle6\n\n命令行用法：\n\nuncompyle6 1.pyc &gt; 1.py\n\n工具二：pycdc\nGitHub: https://github.com/zrax/pycdc\n支持 Python 3.9 及更高版本；\n构建或下载编译好的 pycdc.exe：\n\npycdc.exe yourfile.pyc &gt; yourfile.py\n\n工具三（针对高版本）PyLingual\nGitHub: https://github.com/diprajpatra/pylingual 可以直接按readme里的步骤部署,也可以直接在在线网站逆向pyc https://pylingual.io/\n适用于 Python 3.11~3.12 字节码分析；\n命令行用法（需在 conda py312 环境下）：\n\npylingual 1.pyc\n注意事项\n.pyc 反编译出来的 .py 文件可能：\nwhile、if 分支混乱；\n列表、条件逻辑丢失；\n要人工修复逻辑结构。\n\n\n若 .pyc 文件加入了花指令（junk bytecode），需手动修复。\n\npyc 字节码（Bytecode）分析当题目直接给了 pyc 字节码或源码无法反编译时，可以手动分析。\n工具：Python 内置 dis 模块\ndis 是 Python 内置的字节码反汇编工具。它可以把 Python 的函数、模块或者 code object 的 字节码 (co_code) 转换成人类可读的形式（类似汇编指令），显示每条 opcode 和它的参数。\n\n官方文档：dis — Disassembler for Python bytecode &#8212; Python 3.14.0 documentation\n\n用法：\n\n\nimport disdis.dis(your_function)\n\n或直接命令行：\n\npython -m dis yourfile.pyc\n手动还原思路\n参考 u-tools 的「程序员手册」搜索 dis 指令说明；\n每个 Python 版本字节码结构略不同：\nPython 2：每条指令 3 字节/1字节\nPython 3：每条指令 2 字节/1字节\n\n\n\n通过分析 opcode，可手动还原出 Python 逻辑。\npyc字节码花指令处理花指令即插入无效或干扰反编译的字节码。\n步骤流程\n识别花指令\n\n结合 uncompyle6 的输出,如果pyc字节码加花没办法正确反编译回py文件\n实际字节码判断,若有无用字节码,就是花指令\n参考 Python Opcodes表: https://unpyc.sourceforge.net/Opcodes.html 查指令含义。\n\n\n定位花指令\n\n用机器码定位\n\n\n修改花指令\n\n修改code object总长度\n\n\npyc文件结构:\ntypedef struct &#123;    PyObject_HEAD    int co_argcount;        /* #arguments, except *args */    int co_nlocals;     /* #local variables */    int co_stacksize;       /* #entries needed for evaluation stack */    int co_flags;       /* CO_..., see below */    PyObject *co_code;      /* instruction opcodes */    PyObject *co_consts;    /* list (constants used) */    PyObject *co_names;     /* list of strings (names used) */    PyObject *co_varnames;  /* tuple of strings (local variable names) */    PyObject *co_freevars;  /* tuple of strings (free variable names) */    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */    /* The rest doesn&#x27;t count for hash/cmp */    PyObject *co_filename;  /* string (where it was loaded from) */    PyObject *co_name;      /* string (name, for reference) */    int co_firstlineno;     /* first source line number */    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) */&#125; PyCodeObject;\n其中我们关注的就是co_code字段\nimport marshalcode = marshal.load(open(&quot;1.pyc&quot;, &quot;rb&quot;))  # 你的pyc路径print(len(code.co_code))\n   根据长度在winhex搜索这个数值,找到的第一个,就是长度,code object长度用四个字节存储,这四个字节前是marshal中byte对象的标识,一个’s’(0x73),这四个字节后就是code object内容\nPyArmor 加壳与加密分析PyArmor 是常见的 Python 加密与授权保护工具。PyArmor是把源码/字节码用加密包装并在运行时由专有 runtime（如 pyarmor_runtime.pyd）解密后执行。因此你看到的 .py 文件通常只包含一个启动壳（stub），它调用 runtime，并把加密的二进制 blob 交给 runtime 解密并加载——这就是你看到的 __pyarmor__(__name__, __file__, b&#39;...&#39;)。\n原理图:\n\n工具：PyArmor\nGitHub: https://github.com/dashingsoft/pyarmor\n官方文档: https://pyarmor.readthedocs.io/en/latest/\n安装：\n\npip install pyarmor\n\n常用命令：\n\n# 初始化项目pyarmor init --src=src --entry=main.py my_project# 生成加密文件cd my_projectpyarmor gen# 直接加密单个文件pyarmor gen main.py\n常见特征\n目录中含 pytransform/、license.lic；\n\n存在 _pytransform.dll / pytransform.pyd；\n\n反编译 .pyc 失败；\n\n程序运行时导入 pytransform 模块。\n\n文件夹中有pyarmor字样\n\n\n解题:GitHub - Lil-House/Pyarmor-Static-Unpack-1shot: ✅ No execution ✅ Pyarmor 8.0 - latest 9.1.x ✅ Universal ✅ Statically convert obfuscated scripts to disassembly and (experimentally) source code.\n下载release\n打开文件夹\n\n如果runtime不用显式指定,在这个目录下用\npython shot.py 被混淆程序所在文件路径\n如果题目也把runtime给你了,那就用下面的包含.pyd的命令\npython shot.py -r /path/to/pyarmor_runtime.pyd /path/to/obfuscated_scripts\n有的程序为了防御这种攻击,会把PyArmor 加密文件的标识符去掉,我们给它在开头加上就行\n比如:\n#src.pyfrom pyarmor_runtime_000000 import __pyarmor____pyarmor__(__name__, __file__, b&#x27;\\x00\\x03\\r\\x00\\xf3\\r\\r\\n\\x80\\x00\\x01\\x00\\x08\\x00\\x00\\x00\\x04\\x00\\x00\\x00@\\x00\\x00\\x00d\\n\\x00\\x00\\x12\\t\\x04\\x00y&quot;\\x04&quot;\\xc0\\xa4\\t\\xad2\\\\\\x17\\x13D\\x0c\\x81\\xeb\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00[\\xc1%I\\xfe56\\xaa\\x1cc\\xc9\\xf2E\\xa3\\x86\\xc1\\x88=sB\\xf08\\x14\\&#x27;U\\xfc\\t\\x10\\xc7%\\x1a\\xb6\\xc4\\xa6QvBDK\\xfd\\xf5\\xb0&amp;NZ&amp;n\\xe41@VC\\x11&amp;j\\x8fs\\x18\\xd6\\xe3iQ\\xf8_\\x9e\\xdb\\xfa\\x92~\\xfb\\xe7f\\xdf#\\x00\\xa3fv\\xb5\\x9b\\xa13\\x99 \\x83\\xc3\\x93\\xf2\\x1d=\\xe2-\\x93zb\\xb0\\x10&amp;\\n\\xc4\\xb8\\xb9\\x83\\x99^\\xd0\\x94G9\\xb9\\xa0D\\xedX\\xff\\x01\\xbd&gt;\\xa9\\xe8\\xf03]\\xdd7\\x87\\x84\\x13;%\\xae\\xd5\\xe8\\xcc\\xd1\\xa8\\xe0\\xda\\xc2\\x9f0\\x02\\xb88J\\xac\\xe5pS-\\x14\\x86\\xdb\\xc4/\\xea\\xa8\\xd3\\x05\\x04V\\x94\\xfd_\\xf3\\xd7\\xf1\\x7f#\\x8d\\x9e\\xd71\\xb1\\xfd\\xb4\\xb9\\xd9\\xf7&gt;y\\xfb\\x12\\x8f\\x9a\\xe1\\x8d\\xe2X\\xf9\\xcb\\xe2\\xe3\\xa2\\xd7\\xfc\\xfa\\xa0\\x91n\\xb9\\xbc\\xc0\\xf0#\\xfd\\x83\\xad\\xb2\\\\K\\xee\\x88R\\x80\\xff\\xcf\\x93\\x8f\\x13\\xe5\\x01`\\xbe$)\\xad\\xa6\\xdc;\\x8e\\\\\\x0c\\xae\\x87yJ\\xd9\\xedF/P\\x89\\xe8\\xb6\\xebI\\xb1u\\x9b&quot;pt\\xc3v\\x19 \\x83\\xae\\x89\\x07\\x1fmR\\xd9AX4C\\x05fa\\x81\\xf5\\xab\\xf5\\x9a\\xfe\\xe2\\xa2\\x88HX\\&#x27;\\x9c\\x9f\\xea\\x1d\\x7f\\xeb\\n-\\xa3\\tFDsM\\x99MF\\xb6\\xa9.\\x1a\\x86n\\x95\\xc4\\x85f\\xf8\\x90\\x076\\xb5_\\xeb.\\xddn\\x94f\\x12\\xb7\\x04\\xbb_\\xd1\\x87XO\\x054&lt;\\x9a\\\\1%H\\xe4eBo)\\xf2\\xf5\\xc6\\xe1\\xbd\\x10i\\xe2\\xefD\\x98\\xdc\\xea\\xf0\\xc0\\xd1\\xdc\\x8c&amp;J\\x7fX\\x87\\xc5\\xfb\\x05d\\xb2\\xc4\\xc5\\x0b\\xfc\\xf8\\x9e0R\\xb2&#123;em\\xb2\\x98\\\\\\x05\\xd3\\xbe_\\xf3\\x07\\x04\\x05\\x82p\\x1b\\xa7\\x19\\xf2\\x02\\x8e~\\x12\\xa3;\\xb1\\xfeb\\xdd\\x83\\x04\\xf4VM\\xba\\xe1&#125;\\x8ff\\x91\\xa0\\x94&#125;\\xef\\x12(\\xdf\\xa9j\\xd4gA\\xaa\\tB\\xf0\\\\=m%\\xa4B\\xbd\\x1b\\xe2AD\\xfb\\x98\\xdf\\xfd\\xf6\\xe5\\x80-B\\x90a\\xf4E_\\xa7\\xec\\x8eBx\\xb8\\x80\\xef\\x08X]\\x0b\\x18\\xa3\\xab\\xf4\\x8b\\xe8\\t\\xfd\\xd9o\\&#x27;\\x96&lt;\\x1d\\xf6\\xdb\\xe1\\xe4\\xb5\\x8ec5o\\x85\\x92\\xf4\\x1e&lt;g\\xecJI\\xf3\\x01\\x90\\x1e\\xb7\\x00\\xda\\t:&#125;\\xc7I\\x8c\\xa5\\x01\\x13b!\\xf2\\xcd6JUy\\xc5\\xfc\\xd8Q\\x8f\\x13\\xdb\\x0f\\xfe\\xbf\\xd7\\xe8\\x992\\xe4\\xdf\\x17\\xd0\\xef\\xa5QC\\xa6przcd\\x9f\\x8aS\\x963\\xa7\\x0c\\xc4\\x97\\x11j\\xa8\\xcf\\x19\\x1a\\xc6\\xff\\xb1\\x1d|\\xe9n\\x129\\x19\\xad\\x08\\x80\\xc9\\x98=q6\\xc7U\\xc8\\x12\\xe2\\x0bSt\\xc9,\\xb4\\x07\\xd5X\\xad\\r&#125;\\xb1 \\xe4\\xf6\\xfb\\xb6m\\x11\\xf9\\x1e\\x8c|\\xd7\\xf5\\xd0\\x99\\x01t\\xa39\\xd0&amp;X\\xa8\\&#x27;^\\xa5\\xd1\\x98&#123;\\xed\\xca\\xe1\\x95E\\x08&amp;\\xd1\\x0e\\xecF^\\xc6\\xad\\x15h\\xadV\\xfe~\\xb2&lt;Xe\\xa2$\\xf6\\x82\\xa8Wk\\xd1%1\\x9d\\xcc\\x08\\x88\\xfe\\xbck\\xb6t\\xe4\\xc0\\xc8F\\xf7\\xa3\\xee\\xd8UMb(\\xeb\\xe9#\\xfa( \\x97Kp\\xe4\\xe6\\x13&gt;\\xbcZ\\xab\\x89\\x99Uy\\xe5\\xf7s\\xcda\\x8a\\xcb`\\x0f\\x02]e\\xc6:\\x84\\xf4J\\xda3n\\x1a\\x01?\\x83\\x98L\\xf2P\\xae\\x10\\x80A\\xf7\\x86\\x17F7\\xb3 7\\xe7\\xfb\\xed\\xed\\x0c&quot;v\\&#x27;\\xf0W\\x97\\xc7\\xdaMe=\\xc1\\x1c\\xf9\\xc3\\xe2\\xa3\\x08\\x0e\\xe0\\x0c\\xd9\\x10\\xd7\\x0e\\x7fJ\\xf5\\x12\\x94\\x19\\xbf\\xf3\\xc4K\\xe1\\xb2b\\x07\\xa6:\\xa6a\\x9eW\\xf9B\\x0e\\xab\\x9c5\\xd4B\\xdeN!\\xeb\\xa9\\xb5K\\xf4\\xcan\\xed\\x04\\x7fp\\x87\\x95\\x14\\x18\\r-\\xa9R\\x95H\\x9f++\\x8f!!\\xb5\\xc8W\\xbeG\\x1a\\xb0\\x1c\\x1b\\xcdb\\xb2y\\x89\\x16\\xab\\xbe\\xdb)0\\xe6\\x07\\x8a\\x1fv\\x02n\\x83\\xfd\\x88q\\xf3\\xa8\\xaf4\\x84t\\x0e\\x95I\\xf7\\x11\\x02Q\\t.K\\x10_\\x88\\x89\\xf4\\x98\\xaf\\xeb\\x9d\\xc6\\x02&quot;u\\xb6\\x1dbOv\\xc6\\xfed%\\x83-3\\x8e\\xde\\x0ed&quot;\\x16\\x95j@\\x07R\\xd5PumB@&quot;\\xa4`\\xa5\\xe7*V\\x12\\xf2\\x90A\\x95\\xd9\\xaal\\xb8\\x1a\\xe6\\xcc\\x0b1\\\\\\xca\\x03m\\xa1\\xaf;c&#123;\\x14\\&#x27;\\x14\\xb4\\xb2\\x13\\xf2\\x9e\\xe6\\xaf\\xcf&lt;\\x86\\x16\\xc6&gt;\\x86\\x01?\\xf6J\\xa4\\x9b/\\xce\\xd4\\xec+\\xc9\\xf6Y\\x9f\\xef\\x08\\x88\\x05\\xe1B\\x12\\xc4\\xca4\\x03?\\x9b\\x9e\\xa9r\\x99\\xeb\\x08\\xc9Tfm\\xb9,\\x8e&quot;\\xfcK\\xd3\\x9dx\\x97\\x0ff\\x15\\x08\\xfb\\x89\\xdd\\xd0Z\\x85W?\\x9c\\xb9\\xd3\\x10\\xaf\\x9dG\\x96f\\xae ed\\tu\\x0e\\x8e\\xccX\\xe1\\xe4\\x82\\xbc\\xe9\\xeb\\xa2\\xd6\\xa44\\xf4\\xeb]p\\xad\\xa0k\\t\\x84\\x0f\\xba\\xed\\xc8\\x18\\xbc\\xd3\\xc02\\x97\\x8a\\x97B\\xd69\\xc4\\x8c\\x11\\xca\\xeb*\\xbed\\xefv\\x95\\x96H\\xf7\\xb4\\xb6\\xbd\\xfb\\xc6q\\xc7\\x90,eCkf\\xc5\\xb5\\x91\\xb1J\\x85\\xab\\xc4\\x06\\xff\\xdb\\xae\\x03]Cd\\xa1\\xe4\\xdf\\x80\\xddk2\\xb4\\xe7\\xac\\xac\\x05i\\\\6\\xf8:\\x87Ps\\xbcM\\x06\\n\\xce\\xdc\\xafo\\xc1\\xd8\\xf4\\xd5p\\x8d\\xe1\\xa3P\\x99e\\xc6Z4t\\xc5\\xdc\\xc02.\\xa8\\x08\\x97\\xbcJ\\xc4ga\\xd1\\xe6\\xc5t\\xf1\\xf9\\x1a\\t\\xc3\\x95\\x8a\\x05\\xea\\x99\\xe3^\\xe9\\x05r\\xda\\xb5\\x97\\xd4\\xbd\\x01\\x9f\\x86\\xae!?\\x13\\xf3\\xeb\\x93\\xc5\\x80v\\x01F\\x96\\xd9\\xb6\\xf6C\\xb0w\\x9ciH\\xbc\\xd3\\x1c\\xa5R\\xd0\\x08;d\\xd8\\xac\\xbf\\x1c\\xff\\xfca\\xf2Ey\\xac\\x00rY\\xf2A\\xeb\\r\\x9f\\x8a\\xcf\\xb6\\xa97\\xf4\\x82\\x12\\xee,&lt;\\xaa\\xec\\xa7RY`\\xb1\\x1e\\xe3\\xac,\\xb8\\xee\\xe2\\xc0\\xc47\\x9e\\xf4B\\\\\\xb1?\\xd7[I\\xf8\\x19\\xd5\\xbe\\x87(S\\x9e$\\xffq\\xb0p\\x8e2\\x85XCE\\x84\\x8c\\x97\\xebw\\xa3\\x00\\\\_\\x13\\xf5Jw5\\xfeK\\x95\\xb2\\xbb\\xd4\\x92F\\xa0\\x9a\\xb54\\x97\\x03\\xaa\\xe0\\x98q\\x0b\\xdd\\xbd\\xf3\\xe3\\xfc\\xfdU\\x1aH\\xbc\\x13\\x00gP\\xe6\\xe7\\xb3\\xa6\\x91hP\\xd3\\&#x27;r\\x8c\\xab\\xa39\\xe6\\x14\\x0f\\x15;\\tt\\x9bf\\xa6\\x7f\\xc8\\xe5\\xf7\\x16\\x19\\xf8\\x9a\\xc0n\\x7fa\\x1c\\xf5I\\xefU\\xf5O\\xfb\\xfc\\xad\\x05\\xadYB\\x17\\xb3~xL\\x8d\\x9f\\x05\\xc0\\xcaWp\\xf5x\\xd4\\xcf\\xddX\\x96\\xad]P[`\\x9ei\\xfdap\\xe2\\xf4\\xc2w\\xf2\\xbc\\xd1 \\xff\\x13\\xccz\\xd0&amp;+\\xc8\\xa00\\xe2\\x11\\xdb\\xa2.\\x961\\xa2\\x0fs(R8\\xdd\\x898Ve&#125;\\x8f&gt;S\\x83\\x14\\x83P\\x8bA@s\\xe5\\x8d\\xda\\xb2\\xf9\\xba\\x00\\xb3\\xd0Q\\x1d\\xaaZ\\xae\\x03\\x9e\\x92=.\\x13|\\xb1\\x8dK4\\x96A\\xa5\\xdeM\\xbc\\xd9dOxB_\\xc5\\x10\\xbdp\\xccD1\\xc1$d\\xdc8\\xc5\\x18\\xd3e\\x1a)[s\\xecn\\xd2htl\\x8c\\x1a0y\\xd8a&amp;Q\\xb5\\xd7\\xcd\\xb2&gt;\\x1b\\xe1\\xfdKA\\xeb^v&#123;#\\xba\\x0eo\\xef\\xf5\\x1c,\\xe5X\\x05\\xc7s\\xf6\\xa7\\xfa\\xd9\\xed\\x87\\x18\\xa0&#123;C\\\\\\xc4\\xef6^\\xcf%\\xc9[\\xb7\\x87\\xb0\\xac\\tN\\xd1\\x04\\xaa\\xa2\\x10\\xa4kg\\xa1Pn\\xcb\\xfd\\xfflL]\\x92h&#125;&lt;\\xa2\\xfej1\\x83\\xe6\\xfb\\x97\\x9c\\xae\\xe8\\x88\\xf1\\xbdN\\x0f\\xde\\xfd\\x8d\\xe6\\x87^S\\x94\\x0c\\xad\\xee%\\t\\xb5\\xd6\\xfb\\xac\\xb7d0\\\\\\xe8\\xb9\\xfe\\x04\\xc2\\x92&quot;@\\xd7\\x08GY%\\xdf%\\xba\\x83\\x18\\x17\\x7f\\x00\\&#x27;\\x1c\\&#x27;/\\xa7\\x7f\\xe2\\xf7\\xc8\\x9b 2(\\x9cO\\xa7\\x7fI\\xc4\\xe7l\\x0b\\x0f\\xda\\xe9uR%\\xaeb\\x9dm\\x85\\xab\\xbf\\xe7\\x95\\x88\\xc9\\xff\\xe0\\xd2\\x85\\xaah\\x0e\\xd3\\xf8\\xe2\\x89\\xd1\\x96ix\\xe7aic\\xb8\\x10\\x08\\x9cJ,\\xc6o\\xbb\\xe0(\\x10&#125;\\x0c\\xb9\\x9a\\x11\\xdf\\rR\\x9c\\x00\\x95\\x88xO\\xeb\\xba\\xbe+Qi[`u\\x86\\xce\\xf4\\xe2C\\xd0\\xb7\\x00_#j\\x19.&#123;\\xeb4\\xecc\\xb8N^K&quot;\\xab\\x0b\\x9e\\xd7u\\xe1\\x1c\\xe8\\x1dL\\xfcC\\xf2\\xbfS\\xf5\\x95\\x00\\xe7&gt;\\x0e\\x9ew\\xf6\\x83\\xee\\n\\xd1\\x1e\\xb5\\xceV\\x93\\x9clg\\xeaV\\xab\\xf9\\xec\\xc7\\x01\\x9f\\x0c\\xe5\\xd1h0\\xafbMC\\x13\\xd8zJ\\xab\\x81\\x7f\\x88|\\x0b\\x95&lt;(\\x15d\\x90\\xb7\\xd7\\x9e,\\xb5\\x14\\n\\xfe4\\xe3\\x1a\\xa5\\x9b&#125;\\xf1\\xa0\\r\\x96.5\\x99\\xce\\xc9E\\xed\\x97\\xa3\\n4O\\xb5\\xdb\\xc8\\xbf\\xb4\\x88\\xdb\\xd5V\\x0f\\xfd\\xda\\r\\x1d9x\\xe1\\xa0\\xc5\\xc6L\\x08\\xda\\xc8\\x88\\x87Z?\\x9d\\xa8\\xd5\\xcdI\\x16\\xb5Q`&gt;\\xb8\\x1fSbN\\xd9\\xf2F\\x01\\xeb\\x07\\xf2.9\\x87\\x8e\\xab\\xb6\\x8e\\x1e\\x8b\\x04\\xc3\\xcb?\\xd3F\\x18g6r\\xc4\\x1dh$\\xc9|w\\xe5+/\\xb4X\\x94\\x1ax\\xf5a\\x05::\\x1c^\\xa1\\x8e\\x08E\\x84\\xde)2m\\x9cD\\xb7UBsE\\x82\\x01\\xf6\\xa8\\xd6E\\&#x27;\\xe4\\x7f^\\xdd\\xf7\\xbb4\\xb0*&#125;\\x12=\\x1f3\\x1b9\\x9d\\xd1\\xfc\\x8c\\xbd\\x9bC\\x83Z+\\xdb\\x06\\&#x27;_\\xf2\\xb9\\xd6\\x8d\\x8e\\xa0M\\xc8\\x8a\\x13\\xfeDC\\xc8\\xa0\\x96?h\\xba\\xb7&quot;\\xb7\\x15x\\xd2\\xb0P\\xc9\\xc3c~\\xdd`\\x81\\xb8JKJ\\xe0\\xcd\\x80\\xe6/&#125;\\xce&amp;\\x01h\\xce\\xa6\\x8e\\xfa*\\xf4(l]\\xc5\\xb1a&#123;&quot;\\xbe\\xc9\\xf3\\xd3\\xdc\\xad\\xe5!\\xd3\\xfd&quot;hR\\&#x27;&amp;\\xaf\\xad\\xf6\\xb5\\x04\\xb5\\xe1\\x98g8\\xcc\\xe3f\\xa9\\x8d\\&#x27;\\xd0\\xc4\\x94\\xf2\\x865\\x82&gt;U\\xdba\\x98:\\x02V\\xad\\xfb\\x81\\xb4PDy&lt;\\xdd\\xeb\\x01\\xa9\\x99^)\\x8bK\\xc8E\\x04AM\\x88\\xd4\\x99H\\x9a\\\\\\x8c\\x13OIxmZ\\xc5\\x19\\xe8\\xc1\\x19\\x82E\\xf7\\x01SNr\\xf70\\xa4\\xe1\\x92\\xa6\\xed\\x1d\\tZ\\xbfD0\\xc6\\x80\\xe5\\xf8\\xdd\\xa9\\xd8\\xe3\\xa2\\xb1y\\xc5;\\x9d\\xd6c\\x8as\\x07\\x0fBa&quot;\\xc2Mw\\x9f,w\\x1b\\xc7\\x98\\x8a\\xd3\\x93\\xb0\\&#x27;\\xdb\\xact\\x99\\x11Vq&lt;\\x8d$c\\x8bX\\xd3\\x04\\x9d\\x92\\x17\\xa9\\x91&#125;\\x9fc\\xc5x8\\xc3\\xea\\xb2&gt;&lt;\\x88krU\\x055\\x1cN\\x8d\\xf7\\&#x27;S&gt;\\x14\\xc9pV\\xbe\\x1fj\\xed\\xa5\\t\\xbc\\xbfD\\xed$\\x88\\x00n7&lt;\\xf5\\xd6\\xe9h\\xaf@\\x94\\xfb\\x1am\\x9a\\xa4\\x1a\\xf5Z\\xcb\\xf9\\x80\\xb6\\x9d\\xd6\\xf1\\x9f\\xce\\x1e\\xaf\\x97=\\xdcrj\\xcfh\\xc2\\x1dS\\xdd\\x18\\x15\\xb5\\xc3O=\\x0e\\xba\\x07\\x0b\\xb1J\\x01A\\x7fl\\xcf?\\&#x27;\\xb0e\\x9aO\\xed2\\xf7\\xf4\\xa1\\xd3\\xdf\\x11_H\\x8f\\x8f\\x03\\x7f\\xeej\\x954\\r\\x1aA\\xdanM\\x8f\\xef\\x9dq\\xc6\\xf5\\x16E3\\x10\\x80\\x88\\xa0\\xd0Q\\xfc\\xf1\\x8b\\xf1\\xcf\\xb5\\xed\\xa54P\\x18\\xb4\\xc9\\x02:&#125;\\xc6\\xf8\\x17\\xaa\\x8a\\xcd\\xb88\\x03\\xecI\\xe7\\x9a\\xef\\xab9\\x1e\\x7f9\\x1ah\\xef\\x1c\\xef\\x13m\\x9bfqb\\x1a\\x8a\\xe1\\x02\\x8e\\xf9\\xa1\\x9d\\x90\\xb2$\\xcbS\\x10QS\\x96\\xa8\\xea\\x8bx\\xc11\\x93\\x1c\\xb9\\x0b\\x80~\\xde\\x9b\\xc4\\xa2N\\xe0N~Q\\xaf\\xc0@\\x01\\x9d=[@\\r1T\\xec\\xb9\\xd3\\xe0q\\x94\\xd1\\xf7\\x983\\x10*\\xad\\x1a\\xd3hs\\x98&#125;\\xd8\\xfd\\x05\\n\\xd1u\\xf7d\\xd2\\x9a\\xc6\\x95\\xba\\x0cJ\\\\GSC\\xbb\\&#x27;\\x18\\x1f\\xaa\\x12/|q\\x0b\\x81\\xb4)\\x15&#125;\\xa0\\xf9S\\xb3\\xcb\\x86\\xdcQ)2OH\\x11\\xde.\\xcb\\xe1Z!DA\\xd3Q&lt;N&gt;\\xa0k\\n-Z)r5\\xa3k\\x9f\\x91&amp;\\xc7\\xb8\\xfe\\x1814\\x16xh\\x97^\\xe3\\x03:\\xb0f\\x14\\xce\\\\\\x85\\xe4k_\\xadf2\\xe5\\xb1`\\x8f8\\xfc\\xf6#x\\x1f\\x98\\xdex7+\\x98=G\\xb1M&#x27;)\n开头没有标识符,根据运行环境可知特征码是PY000000,我们帮它加上PY000000,工具才能正确识别这个pyarmor加密\nfrom pyarmor_runtime_000000 import __pyarmor____pyarmor__(__name__, __file__, b&#x27;PY000000\\x00\\x03\\r\\x00\\xf3\\r\\r\\n\\x80\\x00\\x01\\x00\\x08\\x00\\x00\\x00\\x04\\x00后面的省略\n\n成功后会出现这种图形化界面,现在我们去到被混淆的文件发现多了很多文件,后缀是.py的文件就是解密后的py源码\n总结\n\n\n\n阶段\n工具\n命令\n作用\n\n\n\n\nexe 解包\npyinstxtractor.py\npython pyinstxtractor.py target.exe\n提取 pyc\n\n\npyc 反编译\nuncompyle6\nuncompyle6 -o ./out ./file.pyc\n还原 py\n\n\npyc 反编译\npycdc\npycdc file.pyc &gt; file.py\n还原 py\n\n\n高版本 pyc\npylingual\npython pylingual.py file.pyc\n分析 py312\n\n\n字节码分析\ndis\npython -m dis file.pyc\n查看汇编\n\n\n修复花指令\nWinHex\n手动修补\n去花\n\n\n加壳识别\npyarmor\npython shot.py -r /path/to/pyarmor_runtime.pyd /path/to/obfuscated_scripts\n加密分析\n\n\n\n\n","categories":["ctf逆向中的misc","py逆向"],"tags":["py逆向"]},{"title":"godot引擎逆向","url":"/2025/10/06/ctf%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84misc/godot%E5%BC%95%E6%93%8E%E9%80%86%E5%90%91/","content":"题型识别：\nida 打开搜索字符串，看有没有godot字段\n\nida看段表，如果有.pck段就是godot engine题型\n\n\n\n解包：用这个工具：GitHub - GDRETools/gdsdecomp: Godot reverse engineering tools\n下载后运行文件夹里的exe文件\n点击图示recover project\n\n文件路径选择我们要解包的程序\n点下面的extract就可以看到解包文件夹了\n分析：脚本后缀都是 .gd：\n这是 godot 自己实现的一种脚本语言，叫 GDScript\n可以把main.gd扔给chatgpt，然后让他分析就可以了，不用特别掌握语法\n更改代码逻辑后应用如果我们更改里边的代码逻辑（比如直接输出flag）怎么实现呢？\n重新打包回.pck文件\n点这个之后文件夹路径放我们刚才改完的文件夹，下面的embed pck指要把pck嵌入到exe中替换吗，我们这里选要替换，把exe文件路径填上就可以实现自实现逻辑了\nfrida直接hookfrida是基于动态插桩的hook脚本工具，是用js写的，可以直接让ai帮你写frida脚本，这个东西非常强大，可以hook安卓apk，win中exe等程序，我会放在安卓逆向中讲用法\n","categories":["ctf逆向中的misc"],"tags":["godot engine"]},{"title":"DLL专题","url":"/2025/10/15/pe%E9%80%86%E5%90%91/dll%E4%B8%93%E9%A2%98/","content":"前言DLL（Dynamic Link Library，动态链接库）是 Windows 下的一种可执行模块，可以被多个程序同时加载使用。可以导出函数  \n常见用途：\n\n封装公共函数（比如数学库、图形库）\n\n插件系统（比如浏览器插件）\n\n逆向工程与注入（CTF、安全研究中常用）\n\n\nDLL基础：DllMain：\ndll没有 main 或 WinMain。\n\n它有一个可选的 DllMain 入口点函数。这个函数不是给普通用户调用的，而是操作系统加载器在特定事件发生时（DLL 被加载、卸载、进程创建线程、线程结束）自动调用的。\n\n它的主要目的是进行初始化和清理工作（例如，创建/销毁全局对象、初始化线程本地存储 TLS）。如果不需要这些，完全可以不实现 DllMain。\n\n\n#include &lt;windows.h&gt;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) &#123;    switch (ul_reason_for_call) &#123;        case DLL_PROCESS_ATTACH: // DLL被映射到进程的地址空间            // 初始化代码，例如创建互斥体、加载资源            break;        case DLL_THREAD_ATTACH: // 进程创建了一个新线程            // 线程相关的初始化            break;        case DLL_THREAD_DETACH: // 线程正常退出            // 线程相关的清理            break;        case DLL_PROCESS_DETACH: // DLL被从进程的地址空间卸载            // 清理代码，例如释放资源            break;    &#125;    return TRUE; // 返回TRUE表示成功&#125;\n导出函数，有两种方式：写.def文件; mylib.defLIBRARY &quot;MyLibrary&quot;EXPORTS    AddFunction @1    MultiplyFunction @2    MyExportedVariable DATA ; 导出变量需要DATA关键字\n然后在编译时链接这个文件。这种方式可以精确控制导出函数的名字和序号。\n使用关键字（更常见）可在如下所示的函数声明中使用 __declspec(dllexport) 关键字。\n__declspec(dllexport) double WINAPI my_C_export(double x)&#123;/* Modify x and return it. */    return x * 2.0;&#125;\n必须在声明的最左侧添加 __declspec(dllexport) 关键字。 这种方法的优点是该函数不需要在 DEF 文件中列出，并且导出状态与定义一致。\n如果要避免使用 C++ 名称修饰来提供 C++ 函数，必须按如下方式声明函数。\nextern &quot;C&quot;__declspec(dllexport) double WINAPI my_undecorated_Cpp_export(double x)&#123;// Modify x and return it.    return x * 2.0;&#125;\n链接器将使该函数显示为 my_undecorated_Cpp_export，即源代码中显示的名称，没有任何修饰。\n编写一个dll并编译mydll.h\n#pragma once__declspec(dllexport) int add(int a, int b);__declspec(dllexport) int mul(int a, int b);t b);\n这里我们下面的源文件是.c，所以不加extern “C”\nmydll.c\n#include &quot;mydll.h&quot;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int add(int a, int b)&#123;    return a + b;&#125;int mul(int a, int b)&#123;    return a * b;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    return TRUE;&#125;\n编译指令：\ngcc -shared -o mydll.dll mydll.c -Wl,--out-implib,libmydll.a\n解释一下参数：\n\n-shared：告诉 gcc 生成动态链接库\n\n-o mydll.dll：输出 DLL 文件\n\n-Wl,--out-implib,libmydll.a：同时生成一个静态导入库（方便别人链接）\n\n\n这里的静态导入库的作用是可以把dll和exe合成一个文件。方便发布,一般我们直接gcc -shared -o mydll.dll mydll.c就可以\nmain.c（测试函数）\n#include&lt;stdio.h&gt;#include&lt;windows.h&gt;typedef int  (*add_t)(int,int);typedef int  (*mul_t)(int,int);int main()&#123;    HMODULE h = LoadLibraryA(&quot;C:\\\\Users\\\\Lenovo\\\\OneDrive\\\\Desktop\\\\c++andpy\\\\cpp\\\\mydll\\\\mydll.dll&quot;); // 或者写绝对路径    if (!h) &#123;        printf(&quot;LoadLibrary failed: %lu\\n&quot;, GetLastError());        return 1;    &#125;    add_t add = (add_t)GetProcAddress(h, &quot;add&quot;);    mul_t mul = (mul_t)GetProcAddress(h, &quot;mul&quot;);    int a=10,b=20;    int sum;    sum=add(a,b);    printf(&quot;sum=%d\\n&quot;,sum);    int m=mul(a,b);    printf(&quot;mul=%d\\n&quot;,m);    return 0;&#125;\n运行结果：\nsum=30mul=200\nDLL调试：dll调试如果用vscode的话太逆天，掌握不好注入器和被注入exe之间的关系，用vs就很轻松\n   \n右键我们的文件夹，点最下面的属性\n\n然后配置类型需要改成动态库.dll\n\n在调试的行那，右边的命令放要注入的exe路径，然后在我们的dll对应的.c文件那直接像正常的.c文件那样下断点就可以了\n\n然后直接运行这个dll对应的.c源程序，在exe文件的进程空间导入dll文件（dll注入或loadlibrary）后，我们就可以正常调试了\nDLL注入dll注入目的是把我们写好的dll文件，通过各种方式把这个dll文件注入到已经存在的pe进程里。我们在这个dll注入专题只讲原理，具体代码实现不用深究，毕竟用的时候不需要重复造轮子，不过也可以自己练习写一遍，加深印象。\n远程线程调用：下面我们会用到一些windows库里的函数。先带大家复习一下：\nHANDLE OpenProcess(  DWORD dwDesiredAccess, //渴望得到的访问权限（标志）  BOOL bInheritHandle, // 是否继承句柄  DWORD dwProcessId// 进程标示符  );LPVOID VirtualAllocEx(  HANDLE hProcess,            // [输入] 目标进程的句柄。该句柄必须拥有 PROCESS_VM_OPERATION 访问权限。  LPVOID lpAddress,           // [输入] 指定想要分配的起始地址。通常设为 NULL，由系统自动决定分配在哪里。  SIZE_T dwSize,              // [输入] 要分配的内存大小（以字节为单位）。  DWORD  flAllocationType,    // [输入] 内存分配类型。常用 MEM_COMMIT | MEM_RESERVE (提交并保留)。  DWORD  flProtect            // [输入] 内存页面的保护属性。注入代码通常需要 PAGE_EXECUTE_READWRITE (可读可写可执行)。);// 返回值：如果成功，返回分配内存的基址；如果失败，返回 NULL。BOOL WriteProcessMemory(  HANDLE  hProcess,           // [输入] 目标进程的句柄。该句柄必须拥有 PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION 访问权限。  LPVOID  lpBaseAddress,      // [输入] 写入的目标地址。即 VirtualAllocEx 返回的那个地址。  LPCVOID lpBuffer,           // [输入] 本地缓冲区指针，包含要写入的数据（如 Shellcode 或 DLL 路径字符串）。  SIZE_T  nSize,              // [输入] 要写入的字节数。  SIZE_T  *lpNumberOfBytesWritten // [输出] 指向一个变量的指针，用于接收实际写入了多少字节。如果不需要知道，可设为 NULL。);// 返回值：如果成功，返回非零值 (TRUE)；如果失败，返回 0 (FALSE).HANDLE CreateRemoteThread(  HANDLE                 hProcess,          // [输入] 目标进程的句柄。该句柄必须拥有 PROCESS_CREATE_THREAD 等相关权限。  LPSECURITY_ATTRIBUTES  lpThreadAttributes,// [输入] 线程的安全描述符。通常设为 NULL（使用默认安全描述符）。  SIZE_T                 dwStackSize,       // [输入] 线程的初始栈大小。设为 0 表示使用默认大小。  LPTHREAD_START_ROUTINE lpStartAddress,    // [输入] 线程函数的起始地址。                                            //        如果是 DLL 注入，这里通常是 LoadLibrary 的地址；                                            //        如果是 Shellcode，这里是 Shellcode 在目标进程中的地址。  LPVOID                 lpParameter,       // [输入] 传递给线程函数的参数指针。                                            //        如果是 DLL 注入，这里是目标进程中 DLL 路径字符串的地址；                                            //        如果是 Shellcode，通常设为 NULL 或者传入上下文数据。  DWORD                  dwCreationFlags,   // [输入] 线程创建标志。0 表示立即运行；CREATE_SUSPENDED 表示创建后挂起。  LPDWORD                lpThreadId         // [输出] 指向一个变量的指针，用于接收新线程的 ID。如果不需要，可设为 NULL。);// 返回值：如果成功，返回新线程的句柄；如果失败，返回 NULL。\n远程线程注入是指一个进程在另一个进程中创建线程的技术，通常用于注入dll或shellcode\n我们有一个dll文件和和一个pe文件，我们要做的就是编写一个新的可执行文件，把这个dll文件加载进pe文件里\n1.加载pe文件：HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, &lt;pid&gt;);\n2.通过句柄向被注入进程申请可写可执行空间:LPVOID lpBaseAddress = VirtualAllocEx(hProcess, 0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n3.dll地址写入内存：char path[]=&quot;c:/test/test.dll&quot;;WriteProcessMemory(hProcess, lpBaseAddress, path, sizeof(path), NULL);\n4.获取LoadlibaryA地址：LPTHREAD_START_ROUTINE pLoadlibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);\n5.调用：CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)pLoadlibrary, lpBaseAddress, 0, 0);\n再稍微补充一下，这里如果是把注入对象是shellcode的话，第3步开始不一样：\nchar shellcode[]=&quot;XXXXXX&quot;;WriteProcessMemory(hProcess, lpBaseAddress, shellcode, sizeof(shellcode), NULL); CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)lpBaseAddress, 0, 0, 0);\n这样就把恶意代码注入并执行了。后面看有没有时间写一下对应防御怎么做\nAPC注入：APC 队列正常是干什么用的？APC 全称 ：Asynchronous Procedure Call（异步过程调用）。\n对于线程来说它的本职工作就是处理正在运行的exe里的代码。但有的时候os内核和一些驱动程序、I/O 系统等等想插队，让线程先处理他们的事，但是这时候线程有自己的事要干，所以就先把这些插队的请求塞到APC队列里\n什么时候线程会抽空看一下APC队列内的任务并执行它呢？简单来说：线程并不是随时随地都会查看 APC 队列的。\n只有当线程主动进入 “可警告状态” (Alertable State) 时，操作系统才会检查它的 APC 队列，并执行里面的任务。\n你可以把可警告状态理解为线程的一种 “待机模式”。\n\n忙碌状态：线程正在狂算数据（CPU 占用高），这时候它是个聋子，听不到 APC 的呼唤。\n\n普通等待：线程调用普通的 Sleep(1000) 或 WaitForSingleObject。这时候它在睡觉，而且告诉操作系统：“别吵我，雷打不动”。APC 任务会被积压，无法执行。\n\n可警告等待 (Alertable Wait)：线程调用了 带 Ex 后缀 的等待函数。这时候它在睡觉，但告诉操作系统：“我有空，如果有 APC 任务（比如 I/O 完成了，或者有人注入代码了），叫醒我，我先起来把任务办了再继续睡。”\n\n\n编码思路：\n获取线程列表：找到目标进程里所有的 Thread ID。\n\n实现 DLL 注入：把 LoadLibrary 当作任务分发给所有线程。\n\n实现 Shellcode 注入：把 Shellcode 的起始地址当作任务分发给所有线程。1.获取线程列表：\n\n\n// 获取目标进程的所有线程 ID    // 尽管名字带 32，但在 64 位编译下它能正确获取 64 位线程快照    std::vector&lt;DWORD&gt; GetAllThreadIds(DWORD targetPid) &#123;        std::vector&lt;DWORD&gt; threads;        // [API] CreateToolhelp32Snapshot: 创建指定进程、堆、模块和线程的快照        // 参数 TH32CS_SNAPTHREAD: 表示我们在快照中包含系统中的所有线程        // 参数 0: 对于 SNAPTHREAD 标志，进程 ID 参数被忽略（即获取全系统线程）        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);        if (hSnapshot == INVALID_HANDLE_VALUE) return threads;        THREADENTRY32 te32;        te32.dwSize = sizeof(THREADENTRY32);        // [API] Thread32First: 检索快照中遇到的第一个线程的信息        if (Thread32First(hSnapshot, &amp;te32)) &#123;            do &#123;                // 校验结构体大小，防止版本不匹配                if (te32.dwSize &gt;= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te32.th32OwnerProcessID)) &#123;                    // 筛选：只记录属于目标进程(targetPid)的线程                    if (te32.th32OwnerProcessID == targetPid) &#123;                        threads.push_back(te32.th32ThreadID);                    &#125;                &#125;                // [API] Thread32Next: 检索快照中记录的下一个线程的信息，用于循环遍历            &#125; while (Thread32Next(hSnapshot, &amp;te32));        &#125;        // [API] CloseHandle: 用完句柄必须关闭，防止资源泄露        CloseHandle(hSnapshot);        return threads;    &#125;\n2.进行dll注入\n// APC - DLL 注入    bool Inject_APC_DLL(DWORD pid, const std::wstring&amp; dllPath) &#123;        // [API] OpenProcess: 打开现有的本地进程对象        // 参数 PROCESS_ALL_ACCESS: 请求最高权限（读、写、执行等）        // 参数 FALSE: 句柄不继承        // 参数 pid: 目标进程 ID        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);        if (!hProcess) return false;        // 1. 写入 DLL 路径        size_t pathSize = (dllPath.length() + 1) * sizeof(wchar_t);        // [API] VirtualAllocEx: 在指定进程的虚拟地址空间中分配内存        // 参数 NULL: 让系统决定地址        // 参数 pathSize: 分配多大        // 参数 MEM_COMMIT: 提交物理内存        // 参数 PAGE_READWRITE: 内存保护属性，只需读写即可（存放字符串）        void* pRemoteMem = VirtualAllocEx(hProcess, NULL, pathSize, MEM_COMMIT, PAGE_READWRITE);        if (!pRemoteMem) &#123; CloseHandle(hProcess); return false; &#125;        // [API] WriteProcessMemory: 将数据写入指定进程的内存区域        // 参数 pRemoteMem: 目标地址        // 参数 dllPath.c_str(): 源数据（本地 DLL 路径字符串）        if (!WriteProcessMemory(hProcess, pRemoteMem, dllPath.c_str(), pathSize, NULL)) &#123;            // [API] VirtualFreeEx: 如果写入失败，释放刚才申请的远程内存            VirtualFreeEx(hProcess, pRemoteMem, 0, MEM_RELEASE);            CloseHandle(hProcess);            return false;        &#125;        // 2. 获取 LoadLibraryW 地址        // [API] GetModuleHandleW: 获取 kernel32.dll 的模块句柄（它常驻内存）        HMODULE hKernel32 = GetModuleHandleW(L&quot;kernel32.dll&quot;);        // [API] GetProcAddress: 获取 LoadLibraryW 函数的地址        // 注意：因为系统 DLL 在所有进程中的基址通常相同，所以我们可以直接用本地获取的地址        PAPCFUNC pLoadLibrary = (PAPCFUNC)GetProcAddress(hKernel32, &quot;LoadLibraryW&quot;);        // 3. 遍历线程并插入 APC        auto threads = GetAllThreadIds(pid);        int successCount = 0;        for (DWORD tid : threads) &#123;            // [API] OpenThread: 打开线程句柄            // 参数 THREAD_SET_CONTEXT: 这是 APC 注入的关键权限！必须拥有此权限才能修改线程上下文/插入 APC            HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, tid);            if (hThread) &#123;                // [API] QueueUserAPC: 核心函数，往线程的 APC 队列插入任务                // 参数 pLoadLibrary: 目标线程要执行的函数地址                // 参数 hThread: 目标线程句柄                // 参数 (ULONG_PTR)pRemoteMem: 传给函数的参数（这里是 DLL 路径的地址）                if (QueueUserAPC(pLoadLibrary, hThread, (ULONG_PTR)pRemoteMem)) &#123;                    successCount++;                &#125;                CloseHandle(hThread);            &#125;        &#125;        CloseHandle(hProcess);        return successCount &gt; 0;    &#125;\n3.shellcode注入逻辑\n// APC - Shellcode 注入    bool Inject_APC_Shellcode(DWORD pid, const std::vector&lt;unsigned char&gt;&amp; shellcode) &#123;        if (shellcode.empty()) return false;        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);        if (!hProcess) return false;        // 1. 写入 Shellcode        // [API] VirtualAllocEx        // 参数 PAGE_EXECUTE_READWRITE: 关键区别！因为存的是机器码，必须赋予“执行”权限，否则触发 DEP 崩溃        void* pRemoteMem = VirtualAllocEx(hProcess, NULL, shellcode.size(), MEM_COMMIT, PAGE_EXECUTE_READWRITE);        if (!pRemoteMem) &#123; CloseHandle(hProcess); return false; &#125;        // [API] WriteProcessMemory        if (!WriteProcessMemory(hProcess, pRemoteMem, shellcode.data(), shellcode.size(), NULL)) &#123;            VirtualFreeEx(hProcess, pRemoteMem, 0, MEM_RELEASE);            CloseHandle(hProcess);            return false;        &#125;        // 2. 这里的入口地址就是 Shellcode 在内存中的地址        PAPCFUNC pShellcodeEntry = (PAPCFUNC)pRemoteMem;        auto threads = GetAllThreadIds(pid);        int successCount = 0;        for (DWORD tid : threads) &#123;            HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, tid);            if (hThread) &#123;                // [API] QueueUserAPC                // 参数 pShellcodeEntry: 直接把 Shellcode 首地址作为函数执行                // 参数 0: Shellcode 通常是自包含的，不需要参数，传 0 即可                if (QueueUserAPC(pShellcodeEntry, hThread, 0)) &#123;                    successCount++;                &#125;                CloseHandle(hThread);            &#125;        &#125;        CloseHandle(hProcess);        return successCount &gt; 0;    &#125;\nAPC注入是一种隐形注入，必须等到我们注入的线程进入可警告等待，dll才会进到exe的内存空间\n消息钩子注入核心原理这种方法的逻辑是利用 Windows 的消息机制。\n\n准备：我们在注入器里加载你的 DLL。\n\n下钩：我们告诉操作系统，“我想监听目标进程（PID）的某个线程的消息（比如窗口消息 WH_GETMESSAGE）”。\n\n规则：Windows 规定，如果钩子函数在 DLL 里，那么当目标线程收到消息时，操作系统必须把这个 DLL 注入到目标进程里，才能执行那个钩子函数。\n\n触发：我们给目标线程发个空消息，Windows 就会自动完成注入。\n\n\n使用这种方法的前置条件SetWindowsHookEx 需要一个 回调函数地址 (Hook Procedure)。对于通用的注入器，我们无法预知你的 DLL 里函数名叫什么。 行业惯例：我们将尝试获取 DLL 的 第 1 个导出函数 (Ordinal 1) 作为钩子函数。\n\n这意味着：你的测试 DLL 必须至少导出一个函数（随便什么函数都行），否则注入会失败。\n\n编码思路\n寻找目标进程的ui线程\n\n写注入dll逻辑\n\n\n1.寻找目标进程的ui线程\n// =============================================================// 辅助结构与函数: 寻找目标进程的 UI 线程// =============================================================struct FindWindowData &#123;    DWORD pid;    DWORD threadId;&#125;;// EnumWindows 的回调函数 (系统每找到一个窗口就会调一次这个函数)BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) &#123;    FindWindowData* data = (FindWindowData*)lParam;    DWORD processId = 0;    // [API] GetWindowThreadProcessId    // 作用：通过窗口句柄 (hwnd) 查户口。    // 参数 1: 窗口句柄。    // 参数 2 (&amp;processId): [输出] 把这个窗口属于哪个进程 PID 写到这个变量里。    // 返回值: 这个窗口是由哪个线程 (Thread ID) 创建的。    DWORD threadId = GetWindowThreadProcessId(hwnd, &amp;processId);    // [API] IsWindowVisible    // 作用：判断窗口是否可见（肉眼能看到）。    // 逻辑：我们只关心属于目标进程(data-&gt;pid)且可见的窗口。    // 因为不可见的隐藏窗口通常不处理消息，注入进去也没法触发。    if (processId == data-&gt;pid &amp;&amp; IsWindowVisible(hwnd)) &#123;        data-&gt;threadId = threadId;        return FALSE; // 找到了，返回 FALSE 告诉系统“不用再找了”    &#125;    return TRUE; // 没找到，返回 TRUE 告诉系统“继续找下一个窗口”&#125;// 根据 PID 获取一个 UI 线程 IDDWORD GetUIThreadId(DWORD pid) &#123;    FindWindowData data = &#123; pid, 0 &#125;;    // [API] EnumWindows    // 作用：遍历屏幕上所有的顶层窗口。    // 参数 1: 回调函数地址。系统每找到一个窗口，就会去执行 EnumWindowsProc。    // 参数 2: 自定义参数。我们把 data 的地址传进去，方便回调函数把结果写回来。    EnumWindows(EnumWindowsProc, (LPARAM)&amp;data);    return data.threadId;&#125;\n2.hook逻辑\nbool Inject_Hook_DLL(DWORD pid, const std::wstring&amp; dllPath) &#123;        // 1. 寻找 UI 线程        DWORD threadId = GetUIThreadId(pid);        if (threadId == 0) &#123;            std::cerr &lt;&lt; &quot;[-] 未找到 UI 线程！Hook 注入通常需要目标有窗口。&quot; &lt;&lt; std::endl;            // [API] MessageBoxW            // 作用：弹出一个简单的提示框。            // 参数 MB_ICONERROR: 显示一个红色的错误图标 X。            MessageBoxW(NULL, L&quot;目标进程没有可见窗口，无法使用消息钩子注入。&quot;, L&quot;错误&quot;, MB_ICONERROR);            return false;        &#125;        // 2. 在注入器本地加载 DLL        // [API] LoadLibraryW        // 作用：把 DLL 文件加载到 *当前进程* (注入器) 的内存里。        // 为什么：因为 SetWindowsHookEx 需要传一个“导出函数的内存地址”。        // 我们必须先把它载入自己的内存，算出这个地址，然后告诉操作系统：“以后别的进程要用这个函数，就在这个相对位置找”。        HMODULE hDll = LoadLibraryW(dllPath.c_str());        if (!hDll) &#123;            std::cerr &lt;&lt; &quot;[-] 无法加载 DLL 文件。路径正确吗？&quot; &lt;&lt; std::endl;            return false;        &#125;        // 3. 获取导出函数地址 (Hook Procedure)        // [API] GetProcAddress        // 作用：在 DLL 的导出表里查找函数的地址。        // 参数 (LPCSTR)1: 这里我们用了“序号查找” (Ordinal 1)。        // 意思是：我不管你函数名叫什么，给我拿第 1 个导出的函数来。        // (这就是为什么你的 DLL 必须加 __declspec(dllexport))        HOOKPROC pFn = (HOOKPROC)GetProcAddress(hDll, (LPCSTR)1);        if (!pFn) &#123;            std::cerr &lt;&lt; &quot;[-] DLL 没有导出函数！Hook 注入需要 DLL 至少导出一个函数。&quot; &lt;&lt; std::endl;            // [API] FreeLibrary            // 作用：释放 DLL，减少引用计数。如果计数为0，从内存卸载。            // 既然失败了，就把刚才加载的 DLL 卸掉，别占茅坑不拉屎。            FreeLibrary(hDll);            return false;        &#125;        // 4. 安装钩子 (WH_GETMESSAGE)        // [API] SetWindowsHookExW (核心中的核心)        // 作用：设立“安检规则”。        // 参数 1 (WH_GETMESSAGE): 钩子类型。表示我们要拦截“消息队列里取出的消息”。        // 参数 2 (pFn): 钩子函数地址。就是那个“特工”的代码位置。        // 参数 3 (hDll): 特工所属的单位（DLL 模块句柄）。        // 参数 4 (threadId): 目标线程 ID。指定只监听这一个线程。        // 原理：一旦调用成功，Windows 为了让目标线程能执行 pFn，会自动把 hDll 注入到目标进程。        HHOOK hHook = SetWindowsHookExW(WH_GETMESSAGE, pFn, hDll, threadId);        if (!hHook) &#123;            // [API] GetLastError            // 作用：如果上一条 API 失败了，这里返回具体的错误代码（比如 5=拒绝访问）。            std::cerr &lt;&lt; &quot;[-] SetWindowsHookEx 失败! Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;            FreeLibrary(hDll);            return false;        &#125;        std::cout &lt;&lt; &quot;[+] 钩子已安装。正在触发...&quot; &lt;&lt; std::endl;        // 5. 触发钩子        // [API] PostThreadMessageW        // 作用：往目标线程的信箱（消息队列）里塞一封信。        // 参数 WM_NULL: 一封空信，啥内容没有。        // 目的：目标线程可能正在睡觉。塞封信把它叫醒，它一处理信件，就会触发我们的钩子，进而加载 DLL。        PostThreadMessageW(threadId, WM_NULL, 0, 0);        // 6. 等待并清理        std::cout &lt;&lt; &quot;[*] 等待注入生效...&quot; &lt;&lt; std::endl;        // [API] Sleep        // 作用：暂停 1000 毫秒 (1秒)。让子弹飞一会儿，给目标一点时间去加载 DLL。        Sleep(1000);         // [API] UnhookWindowsHookEx        // 作用：撤销“安检规则”。        // 为什么：注入已经完成了，特工已经在屋里了。如果不撤销，每来一个消息都要检查，系统会变卡。        UnhookWindowsHookEx(hHook);        // 释放本地的 DLL        FreeLibrary(hDll);        std::cout &lt;&lt; &quot;[+] 流程结束。DLL 应该已经留在目标进程里了。&quot; &lt;&lt; std::endl;        return true;    &#125;\n文件劫持注入Windows 程序在加载 DLL（比如 version.dll）时，有一套固定的搜索顺序。它会优先在应用程序当前目录寻找。\n\n正常情况：程序启动 -&gt; 当前目录没找到 version.dll -&gt; 去 C:\\Windows\\System32 找 -&gt; 找到并加载。\n\n劫持情况：你把你的 DLL 改名为 version.dll 放在程序旁边 -&gt; 程序启动 -&gt; 当前目录找到了！ -&gt; 加载你的 DLL -&gt; 你的代码执行。\n\n\n简单来说：就是冒充系统 DLL，站在门口截胡。\n但是我们需要在想要注入的dll转发原dll中有的函数，我们需要在dll中再进行转发，否则进程可能找不到对应函数会崩溃\n实现代码也比较简单：\n/** * 文件名: src/methods/method_hijack.cpp * 作用: 实现智能 DLL 劫持 * 修复: 解决了 &#x27;jump to label crosses initialization&#x27; 编译错误 * (将变量声明提前到 goto 之前) */#include &quot;injector_methods.h&quot;#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;shlwapi.h&gt; // PathRemoveFileSpec#pragma comment(lib, &quot;shlwapi.lib&quot;)namespace methods &#123;    const std::vector&lt;std::wstring&gt; HIJACK_CANDIDATES = &#123;        L&quot;version.dll&quot;,        L&quot;winmm.dll&quot;,        L&quot;dwmapi.dll&quot;,        L&quot;uxtheme.dll&quot;,        L&quot;dbghelp.dll&quot;,        L&quot;wtsapi32.dll&quot;,        L&quot;cryptbase.dll&quot;,        L&quot;userenv.dll&quot;    &#125;;    std::wstring GetDirectoryFromPath(const std::wstring&amp; path) &#123;        wchar_t buffer[MAX_PATH];        wcscpy_s(buffer, path.c_str());        PathRemoveFileSpecW(buffer);        return std::wstring(buffer);    &#125;    DWORD RvaToOffset(DWORD rva, PIMAGE_SECTION_HEADER pSections, WORD nSections) &#123;        for (WORD i = 0; i &lt; nSections; i++) &#123;            if (rva &gt;= pSections[i].VirtualAddress &amp;&amp;                 rva &lt; pSections[i].VirtualAddress + pSections[i].Misc.VirtualSize) &#123;                return rva - pSections[i].VirtualAddress + pSections[i].PointerToRawData;            &#125;        &#125;        return 0;    &#125;    std::set&lt;std::wstring&gt; GetImportedDlls(const std::wstring&amp; exePath) &#123;        std::set&lt;std::wstring&gt; imports;        // 变量提前声明 (修复 goto 报错)        PIMAGE_DOS_HEADER pDos = nullptr;        PIMAGE_NT_HEADERS pNt = nullptr;        DWORD importRva = 0;        PIMAGE_SECTION_HEADER pSections = nullptr;        WORD nSections = 0;        DWORD importOffset = 0;        PIMAGE_IMPORT_DESCRIPTOR pImportDesc = nullptr;        HANDLE hFile = CreateFileW(exePath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);        if (hFile == INVALID_HANDLE_VALUE) return imports;        HANDLE hMap = CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL);        if (!hMap) &#123; CloseHandle(hFile); return imports; &#125;        LPVOID pBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);        if (!pBase) &#123; CloseHandle(hMap); CloseHandle(hFile); return imports; &#125;        // 开始解析        pDos = (PIMAGE_DOS_HEADER)pBase;        if (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE) goto Cleanup;        pNt = (PIMAGE_NT_HEADERS)((BYTE*)pBase + pDos-&gt;e_lfanew);        if (pNt-&gt;Signature != IMAGE_NT_SIGNATURE) goto Cleanup;        // 获取 Section 信息        pSections = IMAGE_FIRST_SECTION(pNt);        nSections = pNt-&gt;FileHeader.NumberOfSections;        // 获取导入表 RVA        if (pNt-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;            PIMAGE_NT_HEADERS64 pNt64 = (PIMAGE_NT_HEADERS64)pNt;            importRva = pNt64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;        &#125; else &#123;            PIMAGE_NT_HEADERS32 pNt32 = (PIMAGE_NT_HEADERS32)pNt;            importRva = pNt32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;        &#125;        if (importRva == 0) goto Cleanup;        // RVA 转 Offset        importOffset = RvaToOffset(importRva, pSections, nSections);        if (importOffset == 0) goto Cleanup;        // 遍历导入表        pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pBase + importOffset);        while (pImportDesc-&gt;Name != 0) &#123;            DWORD nameOffset = RvaToOffset(pImportDesc-&gt;Name, pSections, nSections);            if (nameOffset != 0) &#123;                char* pName = (char*)((BYTE*)pBase + nameOffset);                int len = MultiByteToWideChar(CP_ACP, 0, pName, -1, NULL, 0);                if (len &gt; 0) &#123;                    std::vector&lt;wchar_t&gt; wName(len);                    MultiByteToWideChar(CP_ACP, 0, pName, -1, wName.data(), len);                    std::wstring dllName = wName.data();                    std::transform(dllName.begin(), dllName.end(), dllName.begin(), ::towlower);                    imports.insert(dllName);                &#125;            &#125;            pImportDesc++;        &#125;    Cleanup:        if (pBase) UnmapViewOfFile(pBase);        if (hMap) CloseHandle(hMap);        if (hFile) CloseHandle(hFile);        return imports;    &#125;    bool Deploy_Hijack(const std::wstring&amp; targetExePath, const std::wstring&amp; myDllPath) &#123;        std::wstring targetDir = GetDirectoryFromPath(targetExePath);        if (targetDir.empty()) &#123;            MessageBoxW(NULL, L&quot;无法解析目标目录&quot;, L&quot;错误&quot;, MB_ICONERROR);            return false;        &#125;        std::wcout &lt;&lt; L&quot;[*] 正在分析目标导入表: &quot; &lt;&lt; targetExePath &lt;&lt; std::endl;        std::set&lt;std::wstring&gt; importedDlls = GetImportedDlls(targetExePath);        std::wstring bestCandidate = L&quot;&quot;;        for (const auto&amp; candidate : HIJACK_CANDIDATES) &#123;            if (importedDlls.count(candidate)) &#123;                std::wstring checkPath = targetDir + L&quot;\\\\&quot; + candidate;                DWORD attr = GetFileAttributesW(checkPath.c_str());                if (attr == INVALID_FILE_ATTRIBUTES) &#123;                    bestCandidate = candidate;                    break;                &#125;            &#125;        &#125;        if (bestCandidate.empty()) &#123;            std::cout &lt;&lt; &quot;[!] 未找到最佳劫持目标，尝试默认目标 version.dll&quot; &lt;&lt; std::endl;            bestCandidate = L&quot;version.dll&quot;;        &#125;        std::wcout &lt;&lt; L&quot;[+] 选定劫持目标: &quot; &lt;&lt; bestCandidate &lt;&lt; std::endl;        std::wstring hijackPath = targetDir + L&quot;\\\\&quot; + bestCandidate;        if (GetFileAttributesW(hijackPath.c_str()) != INVALID_FILE_ATTRIBUTES) &#123;            MessageBoxW(NULL, L&quot;目标目录下已存在同名文件，停止劫持以策安全。&quot;, L&quot;错误&quot;, MB_ICONERROR);            return false;        &#125;        if (CopyFileW(myDllPath.c_str(), hijackPath.c_str(), FALSE)) &#123;            std::wstring msg = L&quot;劫持成功！\\n\\nPayload 已伪装成: &quot; + bestCandidate + L&quot;\\n请重启目标程序生效。&quot;;            MessageBoxW(NULL, msg.c_str(), L&quot;部署完成&quot;, MB_ICONINFORMATION);            return true;        &#125; else &#123;            MessageBoxW(NULL, L&quot;文件复制失败 (权限不足？)&quot;, L&quot;错误&quot;, MB_ICONERROR);            return false;        &#125;    &#125;&#125; L&quot;错误&quot;, MB_ICONERROR);            return false;        &#125;    &#125;&#125;\ndll中转发函数例子：\n对于g++编译和伪装version.dll：创建.def文件后填入\nLIBRARY &quot;version.dll&quot;EXPORTS    GetFileVersionInfoA=C:/Windows/System32/version.dll.GetFileVersionInfoA    GetFileVersionInfoByHandle=C:/Windows/System32/version.dll.GetFileVersionInfoByHandle    GetFileVersionInfoExA=C:/Windows/System32/version.dll.GetFileVersionInfoExA    GetFileVersionInfoExW=C:/Windows/System32/version.dll.GetFileVersionInfoExW    GetFileVersionInfoSizeA=C:/Windows/System32/version.dll.GetFileVersionInfoSizeA    GetFileVersionInfoSizeExA=C:/Windows/System32/version.dll.GetFileVersionInfoSizeExA    GetFileVersionInfoSizeExW=C:/Windows/System32/version.dll.GetFileVersionInfoSizeExW    GetFileVersionInfoSizeW=C:/Windows/System32/version.dll.GetFileVersionInfoSizeW    GetFileVersionInfoW=C:/Windows/System32/version.dll.GetFileVersionInfoW    VerFindFileA=C:/Windows/System32/version.dll.VerFindFileA    VerFindFileW=C:/Windows/System32/version.dll.VerFindFileW    VerInstallFileA=C:/Windows/System32/version.dll.VerInstallFileA    VerInstallFileW=C:/Windows/System32/version.dll.VerInstallFileW    VerLanguageNameA=C:/Windows/System32/version.dll.VerLanguageNameA    VerLanguageNameW=C:/Windows/System32/version.dll.VerLanguageNameW    VerQueryValueA=C:/Windows/System32/version.dll.VerQueryValueA    VerQueryValueW=C:/Windows/System32/version.dll.VerQueryValueW\n反射型注入：基本原理参照stephen fewer的ReflectiveDLLInjection项目。\n普通dll注入就是靠LoadLibrary函数，把dll按照正常操作系统能接受的方式加载进去。dll进去之后直接就可以调用dll中的函数\n但是反射型注入是把整个dll文件当作二进制数据写到exe运行内存中，这个时候它肯定是不能正常运行的，但是反射型dll中有一个特殊的函数叫做\n ReflectiveLoader 函数，可以自己把这些二进制数据组装起来，修复导入导出表什么的，然后这个dll文件就和正常dll文件一样，可以正常使用了。\n这种方法隐蔽性很高，但是对我们的dll文件编写有很高的要求\n反射型注入流程：\n注入器 (Injector)：将 DLL 的原始文件数据写入目标进程，并创建一个远程线程，线程的入口点指向 DLL 里的导出函数 ReflectiveLoader。\n\nReflectiveLoader 运行：这个函数开始工作（申请内存、复制节、修复重定位、加载导入表）。此时 DLL 只是内存里的一坨数据，还没“活”过来。\n\nReflectiveLoader 完工：当它把一切都准备好，DLL 已经变成了一个合法的内存镜像。\n\n调用入口：ReflectiveLoader 的最后一行代码，通常就是调用 DllMain(..., DLL_PROCESS_ATTACH, ...)。\n\nDllMain 运行：这时候你的业务逻辑（弹窗、挂钩等）才开始执行。\n\n\n反射型注入代码逻辑：bool Inject_Reflective(DWORD pid, const std::vector&lt;unsigned char&gt;&amp; rawDllData) &#123;    if (rawDllData.empty()) return false;    // 1. 在本地解析 DLL，找到 ReflectiveLoader 在文件中的偏移    // 这里必须使用 vector 的副本或者引用，因为我们要读取其内存    std::vector&lt;unsigned char&gt; buffer = rawDllData;     DWORD offset = GetReflectiveLoaderOffset(buffer);    if (offset == 0) &#123;        std::cerr &lt;&lt; &quot;[-] 错误：在 DLL 中未找到导出函数 &#x27;ReflectiveLoader&#x27;。&quot; &lt;&lt; std::endl;        MessageBoxW(NULL, L&quot;注入失败：\\n目标 DLL 不是反射式 DLL。\\n它必须导出 &#x27;ReflectiveLoader&#x27; 函数。\\n\\n请不要使用普通的 test_payload.dll 测试此功能。&quot;, L&quot;格式错误&quot;, MB_ICONERROR);        return false;    &#125;    std::cout &lt;&lt; &quot;[+] 成功定位 ReflectiveLoader 偏移: +0x&quot; &lt;&lt; std::hex &lt;&lt; offset &lt;&lt; std::dec &lt;&lt; std::endl;    // 2. 打开目标进程    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);    if (!hProcess) &#123;        std::cerr &lt;&lt; &quot;[-] OpenProcess 失败。&quot; &lt;&lt; std::endl;        return false;    &#125;    // 3. 分配内存 (RWX - 读写执行)    // 关键点：我们要把整个 DLL 文件作为数据写进去，所以申请的大小是文件大小 (buffer.size())    // 必须给执行权限，因为等会儿我们要运行里面的 ReflectiveLoader 代码    void* pRemoteMem = VirtualAllocEx(hProcess, NULL, buffer.size(), MEM_COMMIT, PAGE_EXECUTE_READWRITE);    if (!pRemoteMem) &#123;        std::cerr &lt;&lt; &quot;[-] VirtualAllocEx 失败。&quot; &lt;&lt; std::endl;        CloseHandle(hProcess);        return false;    &#125;    // 4. 写入整个 DLL 文件内容    if (!WriteProcessMemory(hProcess, pRemoteMem, buffer.data(), buffer.size(), NULL)) &#123;        std::cerr &lt;&lt; &quot;[-] WriteProcessMemory 失败。&quot; &lt;&lt; std::endl;        VirtualFreeEx(hProcess, pRemoteMem, 0, MEM_RELEASE);        CloseHandle(hProcess);        return false;    &#125;    // 5. 计算远程线程的入口地址    // 远程入口 = 远程内存基址 (pRemoteMem) + ReflectiveLoader 的偏移 (offset)    // 这样线程一启动，就会直接跳到 ReflectiveLoader 函数的第一行代码    LPTHREAD_START_ROUTINE pEntry = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pRemoteMem + offset);    std::cout &lt;&lt; &quot;[*] 正在创建远程线程，入口地址: &quot; &lt;&lt; pEntry &lt;&lt; std::endl;    // 6. 执行！创建远程线程，让它运行 ReflectiveLoader    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, pEntry, NULL, 0, NULL);    if (!hThread) &#123;        std::cerr &lt;&lt; &quot;[-] CreateRemoteThread 失败。&quot; &lt;&lt; std::endl;        // 如果线程创建失败，我们可以安全地释放内存        VirtualFreeEx(hProcess, pRemoteMem, 0, MEM_RELEASE);        CloseHandle(hProcess);        return false;    &#125;    // 7. 善后    // 注意：这里我们**不能**释放 pRemoteMem。    // 因为 ReflectiveLoader 运行在里面，如果释放了，线程就崩了。    // 至于什么时候释放？通常 ReflectiveLoader 会申请一块新内存把 DLL 展开过去，    // 这块原始内存（安装包）就变成了垃圾。有些高级的 Loader 会在最后自己清理它。    // 等待一下线程启动，确保注入器不立刻退出    WaitForSingleObject(hThread, 1000);    CloseHandle(hThread);    CloseHandle(hProcess);    std::cout &lt;&lt; &quot;[+] 反射式注入线程已启动。&quot; &lt;&lt; std::endl;    return true;&#125;\n其中rva转foa的函数非常重要，在pe文件结构那一节也讲过这个函数\n找导出表定位reflectloader部分就不说了，看过pe文件结构部分也都会，代码可以看总结部分仓库\ndll设计：直接拿开源项目的函数实现过来编译就可以了\nReflectiveDLLInjection/dll/src/ReflectiveLoader.c at master · stephenfewer/ReflectiveDLLInjection · GitHub\nReflectiveDLLInjection/dll/src/ReflectiveLoader.h at master · stephenfewer/ReflectiveDLLInjection · GitHub\n#include &lt;winsock2.h&gt;#include &lt;windows.h&gt;#include &quot;ReflectiveLoader.h&quot; // [关键] 包含开源的加载器头文件// 注意：你不在这里实现 ReflectiveLoader，它的实现在 ReflectiveLoader.c 里。// 只要把那个 .c 文件加入项目一起编译，链接器会自动把它链接进来。extern &quot;C&quot; void* _ReturnAddress(void) &#123;    return __builtin_return_address(0);&#125;// 你的业务逻辑线程DWORD WINAPI MainThread(LPVOID lpParam) &#123;    MessageBoxA(NULL, &quot;Reflective Injection Success!&quot;, &quot;Hacker&quot;, MB_OK);    return 0;&#125;// 标准的 DllMainBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) &#123;    switch (fdwReason) &#123;        case DLL_PROCESS_ATTACH:            // [重点] 这里是被 ReflectiveLoader 主动调用的            // 当代码走到这里时，环境已经由 Loader 准备好了            DisableThreadLibraryCalls(hinstDLL);            // 启动你的核心业务            CreateThread(NULL, 0, MainThread, NULL, 0, NULL);            break;        case DLL_PROCESS_DETACH:            break;    &#125;    return TRUE;&#125;\n编译：\ng++ -shared -o reflective_payload.dll dll_reflectivedemo.cpp ReflectiveLoader.c -static -DWIN_X64 -DREFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR -DREFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN -Wl,--allow-multiple-definition\n总结：dll注入部分代码都放在我的集成项目GitHub - som1ng/c-injector: c++编写的dll注入器和代码注入器里了\n","categories":["pe逆向","pe逆向基础"],"tags":["DLL"]},{"title":"tauri框架逆向","url":"/2025/10/27/ctf%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84misc/tauri%E6%A1%86%E6%9E%B6%E9%80%86%E5%90%91/","content":"什么是tauri框架？Tauri 是一个用于构建桌面应用的开源框架：前端用任意会输出 HTML/JS/CSS 的框架（如 React/Vue/Svelte），后端用 Rust（或平台原生）打包成本地可执行文件。它通过 WebView 显示前端页面，并通过安全的 IPC（消息调用）把前端和 Rust 后端连接起来。\n简单来说就是tarti框架构建出来的exe文件，集成了前端和后端代码，打包进了exe。运行这个exe，前端代码通过系统webview就可以在界面显示而不需要借助任何浏览器\n\n通常tauri框架写出的app长上面那样\ntauri框架逆向：运行逻辑：\n你双击 .exe；\n\nRust 程序启动；\n\n创建一个原生窗口；\n\n在窗口中加载 WebView；\n\nWebView 渲染 HTML/JS（从内嵌或外部资源读取）；\n\nJS 通过 IPC 调用 Rust 函数，Rust 返回数据给前端。\n\n\n逆向步骤：一般flag都放在exe的静态资源部分。Tauri 会根据配置文件中是否开启压缩来打包静态资源文件，若压缩选项开启（默认情况），其会使用 brotli 算法对资源进行压缩后再打包。\n我们可以找到静态资源所在地，然后dump下来用brotli解密后分析静态资源\n拿2025年羊城杯的easyTauri.exe举例\n定位静态资源：先shift+f12搜flag，如果没有就去找index.html，index.html就是最开始的web页面\n定位到这个字符串后交叉引用，找到一个形似文件表结构的部分\n\n其中\n\n0x0000000140642A40是文件名\n\n0x0000000140642A48 ~ 0x0000000140642A4F是文件名长度，正好”/index_flag.html”就是16字节\n\n0x0000000140642A50存储文件内容\n\n0x0000000140642A58 ~ 0x0000000140642A5F是文件内容长度\n\n\n我们找到这个结构之后就把文件内容dump下来解密就好了\n注意 brotli 对文件的完整性要求似乎很高，多一个或少一个字节都会报错。\n这里给一个ida python的dump脚本：\nimport os, idcstart_ea = 0x14063C8C1size = 0x231out_path = os.path.join(os.path.dirname(idc.get_idb_path()) or os.getcwd(), &quot;dump.bin&quot;) //拼接ida分析程序地址和自定义的文件名data = idc.get_bytes(start_ea, size)with open(out_path, &quot;wb&quot;) as f:    if isinstance(data, str): //这里if分支是在处理python2中get_bytes函数返回str类型的问题        f.write(data.encode(&#x27;latin-1&#x27;)) //latin-1是 1 字节一对一映射，如果用utf-8可能报错    else:        f.write(data)print(&quot;Wrote:&quot;, out_path)\n然后拿到这个新的dump.bin文件后再用brotli算法解密\nimport brotlia = open(r&quot;C:\\Users\\Lenovo\\OneDrive\\Desktop\\dump.bin&quot;, &quot;rb&quot;).read()print(len(a))decompressed = brotli.decompress(a)open(&quot;dump&quot;, &quot;wb&quot;).write(decompressed)\n然后就拿到js写的前端文件了\n前端分析&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Tauri App&lt;/title&gt;    &lt;script type=&quot;module&quot; src=&quot;js/main.js&quot; defer&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;main class=&quot;container&quot;&gt;      &lt;div class=&quot;row&quot;&gt;        &lt;a href=&quot;https://tauri.app&quot; target=&quot;_blank&quot;&gt;          &lt;h1&gt;Welcome to Tauri 2.0&lt;/h1&gt;        &lt;/a&gt;      &lt;/div&gt;      &lt;p&gt;你知道的，这个文件往往是测试的时候使用的，当你找到了这个文件，说明你可以阅读以下hint：&lt;/p&gt;      &lt;p&gt;   1. 我混淆了js，当你觉得那是一大坨恶心玩意的时候，应该试试开发一个最简Tauri项目&lt;/p&gt;      &lt;p&gt;   2. 出题人吃过release无pdb的这一坨，当你分析完js一定能找到对应的native函数&lt;/p&gt;      &lt;form class=&quot;row&quot; id=&quot;greet-form&quot;&gt;        &lt;input id=&quot;greet-input&quot; placeholder=&quot;Enter a Flag...&quot; /&gt;        &lt;button type=&quot;submit&quot;&gt;Check&lt;/button&gt;      &lt;/form&gt;      &lt;p id=&quot;greet-msg&quot;&gt;&lt;/p&gt;    &lt;/main&gt;  &lt;/body&gt;&lt;/html&gt;\n如果前端文件index没有flag，那就把所有js文件都dump下来看看\n\n找到这种形似文件结构的最开始的地址，然后把他们全dump下来\n把要求扔给ai写下面的脚本，但要求要说清楚\n从0x140642660开始是文件结构，每个文件开始8个字节存储文件名地址，后8字节按小端序存储文件名对应字符串字节数，然后8个字节存文件内容地址，后8个字节存文件内容占大小，然后是下一个文件结构，帮我把所有的文件内容dump出来，然后通过brotli算法解密，还原js静态资源。只读js文件和html文件\nag-0-1j8in2hh6ag-1-1j8in2hh6# dump_js_html_only.py# 功能：仅从文件结构中导出 .js 和 .html 文件，并尝试 brotli 解压import os, sys, idc, idaapi, subprocess, tempfile, shutilTABLE_START = 0x140642660   # 文件表起始地址ENTRY_SIZE = 32             # 每个条目大小：8+8+8+8MAX_ENTRIES = 10000OUT_DIR = os.path.join(os.path.dirname(idc.get_idb_path()) or os.getcwd(), &quot;dump_js_html&quot;)if not os.path.exists(OUT_DIR):    os.makedirs(OUT_DIR)def read_qword(ea):    try:        return idc.get_qword(ea)    except:        b = idc.get_bytes(ea, 8)        if not b:            return None        v = 0        for i, by in enumerate(b if isinstance(b, bytes) else b.encode(&#x27;latin-1&#x27;)):            v |= (by &amp; 0xFF) &lt;&lt; (i*8)        return vdef read_bytes(ea, size):    return idc.get_bytes(ea, size)# 尝试导入 brotli 模块或 CLIbrotli_decompress = Nonetry:    import brotli    brotli_decompress = brotli.decompress    print(&quot;[*] Using Python brotli module.&quot;)except:    try:        import brotlicffi as brotli        brotli_decompress = brotli.decompress        print(&quot;[*] Using brotlicffi module.&quot;)    except:        brotli_decompress = Nonehave_brotli_cli = shutil.which(&quot;brotli&quot;) is not Noneif not brotli_decompress and have_brotli_cli:    print(&quot;[*] Using brotli CLI for decompression.&quot;)elif not brotli_decompress:    print(&quot;[!] Warning: no brotli module/CLI found; will save raw data only.&quot;)ea = TABLE_STARTentry_idx = 0results = []for i in range(MAX_ENTRIES):    name_addr = read_qword(ea)    name_len  = read_qword(ea + 8)    content_addr = read_qword(ea + 16)    content_size = read_qword(ea + 24)    if not name_addr or name_addr == 0:        print(f&quot;[*] End of table at &#123;hex(ea)&#125;&quot;)        break    name_bytes = read_bytes(name_addr, name_len)    if not name_bytes:        ea += ENTRY_SIZE        continue    try:        filename = name_bytes.decode(&quot;utf-8&quot;)    except:        filename = name_bytes.decode(&quot;latin-1&quot;, errors=&quot;replace&quot;)    filename_clean = filename.replace(&quot;\\\\&quot;, &quot;_&quot;).replace(&quot;/&quot;, &quot;_&quot;).strip()    if not (filename_clean.endswith(&quot;.js&quot;) or filename_clean.endswith(&quot;.html&quot;)):        ea += ENTRY_SIZE        continue  # ⛔ 跳过非 js/html 文件    print(f&quot;[+] Dumping &#123;filename_clean&#125; ...&quot;)    data = read_bytes(content_addr, content_size)    if not data:        print(f&quot;    [!] Failed to read &#123;filename_clean&#125;&quot;)        ea += ENTRY_SIZE        continue    # 尝试 brotli 解压    decompressed = None    if brotli_decompress:        try:            decompressed = brotli_decompress(data)        except Exception as e:            print(f&quot;    [!] Brotli module failed: &#123;e&#125;&quot;)    elif have_brotli_cli:        try:            with tempfile.NamedTemporaryFile(delete=False) as tmpf:                tmpf.write(data)                tmp_br = tmpf.name            tmp_out = tmp_br + &quot;.out&quot;            proc = subprocess.run([&quot;brotli&quot;, &quot;-d&quot;, &quot;-o&quot;, tmp_out, tmp_br],                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE)            if proc.returncode == 0 and os.path.exists(tmp_out):                with open(tmp_out, &quot;rb&quot;) as tf:                    decompressed = tf.read()            os.remove(tmp_br)            if os.path.exists(tmp_out): os.remove(tmp_out)        except Exception as e:            print(f&quot;    [!] CLI brotli failed: &#123;e&#125;&quot;)    # 写出文件    out_path = os.path.join(OUT_DIR, filename_clean)    if decompressed:        with open(out_path, &quot;wb&quot;) as f:            f.write(decompressed)        print(f&quot;    [+] Wrote decompressed -&gt; &#123;out_path&#125;&quot;)        results.append((filename_clean, &quot;decompressed&quot;))    else:        with open(out_path + &quot;.br&quot;, &quot;wb&quot;) as f:            if isinstance(data, str):                f.write(data.encode(&#x27;latin-1&#x27;))            else:                f.write(data)        print(f&quot;    [-] Saved raw brotli file -&gt; &#123;out_path&#125;.br&quot;)        results.append((filename_clean, &quot;raw_only&quot;))    ea += ENTRY_SIZE    entry_idx += 1print(&quot;\\n=== Dump Finished ===&quot;)for name, status in results:    print(f&quot;&#123;status:12&#125; &#123;name&#125;&quot;)print(f&quot;\\nOutput folder: &#123;OUT_DIR&#125;&quot;)\n出来的js文件里没有\nwindow.__TAURI__.core\n的可以直接删了，因为最后逻辑要交给后端rust的话，必须要用win内核调用\nconst &#123; invoke &#125; = window.__TAURI__.core;\n通常设为变量名invoke，但也可能是自定义的调用名，所以只搜索window.__TAURI__.core就可以了\n最后我们在html_actuator.js里找到get_flag的变量名\n分析这个js文件：\n用在线网站解混淆一下\nJS Deobfuscator\nfunction HTMLActuator() &#123;  this.tileContainer = document.querySelector(&quot;.tile-container&quot;);  this.scoreContainer = document.querySelector(&quot;.score-container&quot;);  this.bestContainer = document.querySelector(&quot;.best-container&quot;);  this.messageContainer = document.querySelector(&quot;.game-message&quot;);  this.score = 0;&#125;HTMLActuator.prototype.actuate = function (grid, metadata) &#123;  var self = this;  if (metadata.game) &#123;    checkBox = document.querySelector(&quot;.check-form&quot;);    checkBoxHtml = `        &lt;form class=&quot;above-game&quot; id=&quot;greet-form&quot;&gt;          &lt;input id=&quot;greet-input&quot; placeholder=&quot;Enter a Flag...&quot; /&gt;          &lt;button type=&quot;submit&quot;&gt;Check&lt;/button&gt;        &lt;/form&gt;      `;    checkBox.innerHTML = checkBoxHtml;  &#125;  window.requestAnimationFrame(function () &#123;    self.clearContainer(self.tileContainer);    grid.cells.forEach(function (column) &#123;      column.forEach(function (cell) &#123;        if (cell) &#123;          self.addTile(cell);        &#125;      &#125;);    &#125;);    self.updateScore(metadata.score);    self.updateBestScore(metadata.bestScore);    if (metadata.terminated) &#123;      if (metadata.over) &#123;        self.message(false); // You lose      &#125; else if (metadata.won) &#123;        self.message(true); // You win!      &#125;    &#125;  &#125;);&#125;;// Continues the game (both restart and keep playing)HTMLActuator.prototype.continueGame = function () &#123;  this.clearMessage();&#125;;HTMLActuator.prototype.clearContainer = function (container) &#123;  while (container.firstChild) &#123;    container.removeChild(container.firstChild);  &#125;&#125;;HTMLActuator.prototype.addTile = function (tile) &#123;  var self = this;  var wrapper = document.createElement(&quot;div&quot;);  var inner = document.createElement(&quot;div&quot;);  var position = tile.previousPosition || &#123;    x: tile.x,    y: tile.y  &#125;;  var positionClass = this.positionClass(position);  // We can&#x27;t use classlist because it somehow glitches when replacing classes  var classes = [&quot;tile&quot;, &quot;tile-&quot; + tile.value, positionClass];  if (tile.value &gt; 2048) &#123;    classes.push(&quot;tile-super&quot;);  &#125;  this.applyClasses(wrapper, classes);  inner.classList.add(&quot;tile-inner&quot;);  inner.textContent = tile.value;  if (tile.previousPosition) &#123;    // Make sure that the tile gets rendered in the previous position first    window.requestAnimationFrame(function () &#123;      classes[2] = self.positionClass(&#123;        x: tile.x,        y: tile.y      &#125;);      self.applyClasses(wrapper, classes); // Update the position    &#125;);  &#125; else if (tile.mergedFrom) &#123;    classes.push(&quot;tile-merged&quot;);    this.applyClasses(wrapper, classes);    // Render the tiles that merged    tile.mergedFrom.forEach(function (merged) &#123;      self.addTile(merged);    &#125;);  &#125; else &#123;    classes.push(&quot;tile-new&quot;);    this.applyClasses(wrapper, classes);  &#125;  // Add the inner part of the tile to the wrapper  wrapper.appendChild(inner);  // Put the tile on the board  this.tileContainer.appendChild(wrapper);&#125;;HTMLActuator.prototype.applyClasses = function (element, classes) &#123;  element.setAttribute(&quot;class&quot;, classes.join(&quot; &quot;));&#125;;HTMLActuator.prototype.normalizePosition = function (position) &#123;  return &#123;    x: position.x + 1,    y: position.y + 1  &#125;;&#125;;HTMLActuator.prototype.positionClass = function (position) &#123;  position = this.normalizePosition(position);  return &quot;tile-position-&quot; + position.x + &quot;-&quot; + position.y;&#125;;HTMLActuator.prototype.updateScore = function (score) &#123;  this.clearContainer(this.scoreContainer);  var difference = score - this.score;  this.score = score;  this.scoreContainer.textContent = this.score;  if (difference &gt; 0) &#123;    var addition = document.createElement(&quot;div&quot;);    addition.classList.add(&quot;score-addition&quot;);    addition.textContent = &quot;+&quot; + difference;    this.scoreContainer.appendChild(addition);  &#125;&#125;;HTMLActuator.prototype.updateBestScore = function (bestScore) &#123;  this.bestContainer.textContent = bestScore;&#125;;HTMLActuator.prototype.message = function (won) &#123;  var type = won ? &quot;game-won&quot; : &quot;game-over&quot;;  var message = won ? &quot;You win!&quot; : &quot;Game over!&quot;;  this.messageContainer.classList.add(type);  this.messageContainer.getElementsByTagName(&quot;p&quot;)[0].textContent = message;&#125;;HTMLActuator.prototype.clearMessage = function () &#123;  // IE only takes one value to remove at a time.  this.messageContainer.classList.remove(&quot;game-won&quot;);  this.messageContainer.classList.remove(&quot;game-over&quot;);&#125;;const &#123;  invoke&#125; = window.__TAURI__.core;let greetInputEl;let greetMsgEl;(function (_0x97aee2, _0x14d3d9) &#123;  const _0x151017 = _0x363b;  const _0x2b0390 = _0x97aee2();  while (true) &#123;    try &#123;      const _0x3b9dd4 = parseInt(_0x151017(176)) / 1 + parseInt(_0x151017(172)) / 2 + parseInt(_0x151017(170)) / 3 + -parseInt(_0x151017(171)) / 4 + -parseInt(_0x151017(167)) / 5 * (parseInt(_0x151017(168)) / 6) + -parseInt(_0x151017(174)) / 7 * (-parseInt(_0x151017(166)) / 8) + -parseInt(_0x151017(173)) / 9;      if (_0x3b9dd4 === _0x14d3d9) &#123;        break;      &#125; else &#123;        _0x2b0390.push(_0x2b0390.shift());      &#125;    &#125; catch (_0x34886e) &#123;      _0x2b0390.push(_0x2b0390.shift());    &#125;  &#125;&#125;)(_0x3a0b, 452532);function Encrypt_0xa31304(_0x5031b3, _0xa31304) &#123;  const _0x22bac7 = _0x363b;  const _0x5d7b84 = new TextEncoder()[_0x22bac7(169)](_0x5031b3);  const _0x2db5b9 = new TextEncoder()[_0x22bac7(169)](_0xa31304);  const _0x1f7f86 = new Uint8Array(256);  let _0x562e52 = 0;  for (let _0x24ca0d = 0; _0x24ca0d &lt; 256; _0x24ca0d++) &#123;    _0x1f7f86[_0x24ca0d] = _0x24ca0d;    _0x562e52 = (_0x562e52 + _0x1f7f86[_0x24ca0d] + _0x5d7b84[_0x24ca0d % _0x5d7b84[_0x22bac7(175)]]) % 256;    [_0x1f7f86[_0x24ca0d], _0x1f7f86[_0x562e52]] = [_0x1f7f86[_0x562e52], _0x1f7f86[_0x24ca0d]];  &#125;  let _0x5b36c3 = 0;  let _0x205ec1 = 0;  const _0x444cf9 = new Uint8Array(_0x2db5b9[_0x22bac7(175)]);  for (let _0x527286 = 0; _0x527286 &lt; _0x2db5b9[_0x22bac7(175)]; _0x527286++) &#123;    _0x5b36c3 = (_0x5b36c3 + 1) % 256;    _0x205ec1 = (_0x205ec1 + _0x1f7f86[_0x5b36c3]) % 256;    [_0x1f7f86[_0x5b36c3], _0x1f7f86[_0x205ec1]] = [_0x1f7f86[_0x205ec1], _0x1f7f86[_0x5b36c3]];    const _0x326832 = (_0x1f7f86[_0x5b36c3] + _0x1f7f86[_0x205ec1]) % 256;    _0x444cf9[_0x527286] = _0x2db5b9[_0x527286] ^ _0x1f7f86[_0x326832];  &#125;  return _0x444cf9;&#125;function _0x363b(_0x3e7d70, _0x4a2c88) &#123;  const _0x3a0bb6 = _0x3a0b();  _0x363b = function (_0x363b1f, _0x4025c1) &#123;    _0x363b1f = _0x363b1f - 166;    let _0x387f5b = _0x3a0bb6[_0x363b1f];    return _0x387f5b;  &#125;;  return _0x363b(_0x3e7d70, _0x4a2c88);&#125;function _0x3a0b() &#123;  const _0x37fb1e = [&quot;3283052tzDAvB&quot;, &quot;542866JdmzNj&quot;, &quot;4112658rTyTXQ&quot;, &quot;16954tUYpad&quot;, &quot;length&quot;, &quot;457163LwGIuU&quot;, &quot;2696pusaTH&quot;, &quot;233035azfeoA&quot;, &quot;66oGYEyB&quot;, &quot;encode&quot;, &quot;2094372kZRrIa&quot;];  _0x3a0b = function () &#123;    return _0x37fb1e;  &#125;;  return _0x3a0b();&#125;function uint8ArrayToBase64(array) &#123;  const binary = Array.from(array).map(byte =&gt; String.fromCharCode(byte)).join(&quot;&quot;);  return btoa(binary);&#125;async function _0x9a2c6e7() &#123;  greetInputEl = document.querySelector(&quot;#greet-input&quot;);  greetMsgEl = document.querySelector(&quot;#greet-msg&quot;);  let getFlag = greetInputEl.value;  const ciphertext = Encrypt_0xa31304(&quot;SadTongYiAiRC4HH&quot;, getFlag);  greetMsgEl.textContent = await invoke(&quot;ipc_command&quot;, &#123;    name: uint8ArrayToBase64(ciphertext)  &#125;);&#125;window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;  document.getElementById(&quot;check-form&quot;).addEventListener(&quot;submit&quot;, e =&gt; &#123;    e.preventDefault();    _0x9a2c6e7();  &#125;);&#125;);\n发现是先rc4加密，再base64后传给后端逻辑\n然后rc4由于是流密码，拿到密钥流就可以异或回去，注意这里不能把加密当解密函数用，因为加密数据是可读字符串，但解密数据ascii可能&gt;128\nconst _0x5d7b84 = new TextEncoder().encode(key)const _0x2db5b9 = new TextEncoder().encode(input)\n在这个rc4实现中，&gt;128的字符被当成两个utf-8ag-0-1j8in2hh6ag-1-1j8in2hh6\n正确获取密钥流代码：\n// 原始混淆代码保持不变(function(_0x97aee2,_0x14d3d9)&#123;const _0x151017=_0x363b,_0x2b0390=_0x97aee2();while(!![])&#123;try&#123;const _0x3b9dd4=parseInt(_0x151017(0xb0))/0x1+parseInt(_0x151017(0xac))/0x2+parseInt(_0x151017(0xaa))/0x3+-parseInt(_0x151017(0xab))/0x4+-parseInt(_0x151017(0xa7))/0x5*(parseInt(_0x151017(0xa8))/0x6)+-parseInt(_0x151017(0xae))/0x7*(-parseInt(_0x151017(0xa6))/0x8)+-parseInt(_0x151017(0xad))/0x9;if(_0x3b9dd4===_0x14d3d9)break;else _0x2b0390[&#x27;push&#x27;](_0x2b0390[&#x27;shift&#x27;]());&#125;catch(_0x34886e)&#123;_0x2b0390[&#x27;push&#x27;](_0x2b0390[&#x27;shift&#x27;]());&#125;&#125;&#125;(_0x3a0b,0x6e7b4));function Encrypt_0x5031b3(_0x5031b3, _0xa31304)&#123;const _0x22bac7=_0x363b,_0x5d7b84=new TextEncoder()[_0x22bac7(0xa9)](_0x5031b3),_0x2db5b9=new TextEncoder()[_0x22bac7(0xa9)](_0xa31304),_0x1f7f86=new Uint8Array(0x100);let _0x562e52=0x0;for(let _0x24ca0d=0x0; _0x24ca0d&lt;0x100; _0x24ca0d++)&#123;_0x1f7f86[_0x24ca0d]=_0x24ca0d,_0x562e52=(_0x562e52+_0x1f7f86[_0x24ca0d]+_0x5d7b84[_0x24ca0d%_0x5d7b84[_0x22bac7(0xaf)]])%0x100,[_0x1f7f86[_0x24ca0d],_0x1f7f86[_0x562e52]]=[_0x1f7f86[_0x562e52],_0x1f7f86[_0x24ca0d]];&#125;let _0x5b36c3=0x0,_0x205ec1=0x0;const _0x444cf9=new Uint8Array(_0x2db5b9[_0x22bac7(0xaf)]);for(let _0x527286=0x0; _0x527286&lt;_0x2db5b9[_0x22bac7(0xaf)]; _0x527286++)&#123;_0x5b36c3=(_0x5b36c3+0x1)%0x100,_0x205ec1=(_0x205ec1+_0x1f7f86[_0x5b36c3])%0x100,[_0x1f7f86[_0x5b36c3],_0x1f7f86[_0x205ec1]]=[_0x1f7f86[_0x205ec1],_0x1f7f86[_0x5b36c3]];const _0x326832=(_0x1f7f86[_0x5b36c3]+_0x1f7f86[_0x205ec1])%0x100;_0x444cf9[_0x527286]=_0x2db5b9[_0x527286]^_0x1f7f86[_0x326832];&#125;return _0x444cf9;&#125;function _0x363b(_0x3e7d70, _0x4a2c88)&#123;const _0x3a0bb6=_0x3a0b();return _0x363b=function(_0x363b1f, _0x4025c1)&#123;_0x363b1f=_0x363b1f-0xa6;let _0x387f5b=_0x3a0bb6[_0x363b1f];return _0x387f5b;&#125;,_0x363b(_0x3e7d70,_0x4a2c88);&#125;function _0x3a0b()&#123;const _0x37fb1e=[&#x27;3283052tzDAvB&#x27;,&#x27;542866JdmzNj&#x27;,&#x27;4112658rTyTXQ&#x27;,&#x27;16954tUYpad&#x27;,&#x27;length&#x27;,&#x27;457163LwGIuU&#x27;,&#x27;2696pusaTH&#x27;,&#x27;233035azfeoA&#x27;,&#x27;66oGYEyB&#x27;,&#x27;encode&#x27;,&#x27;2094372kZRrIa&#x27;];_0x3a0b=function()&#123;return _0x37fb1e;&#125;;return _0x3a0b();&#125;// 提取keystream的代码const key = &quot;SAdt0ngY1AIrC4hH&quot;;const plaintext = &#x27;a&#x27;.repeat(64);  // 64个&#x27;a&#x27;// 使用原始函数加密const encrypted = Encrypt_0x5031b3(key, plaintext);// 提取keystream: ciphertext XOR plaintext = keystreamconst keystream = [];const aCharCode = &#x27;a&#x27;.charCodeAt(0);  // 97for (let i = 0; i &lt; encrypted.length; i++) &#123;    keystream.push(encrypted[i] ^ aCharCode);&#125;// 按要求的格式输出console.log(&#x27;KEYSTREAM = [&#x27;, keystream.join(&#x27;,&#x27;), &#x27;]&#x27;);\nKEYSTREAM = [ 232,0,230,97,0,0,88,88,0,118,233,0,91,8,29,213,0,224,188,251,252,20,20,0,0,0,0,0,0,0,222,119,0,0,177,0,0,0,0,0,0,0,149,8,120,233,187,175,0,3,3,0,238,96,0,0,241,87,73,96,0,31,31,0 ]\n后端分析：定位关键函数：\n由于我们传入参数时js代码是这样：\ngreetMsgEl.textContent = await invoke(&quot;ipc_command&quot;, &#123;  name: uint8ArrayToBase64(ciphertext)&#125;);\n所以直接在ida pro找ipc_command和name字符串就能定位到后端逻辑函数了\n找到后发现\n\n把name（前端加密结果）传入v89，后边就分析v89就可以了\n把这整个函数扔给ai，ai分析出是一个tea加密+一个base64加密\nexp:\nimport base64# 后端 .rdata 那串 base64（你给出的）b64 = &quot;daF/DkQxixGmzn0aPFW2E2PhM8NabRtLjp6pI+c8TtY3WMuPxfnvlAsp9aluf8noZy/T6Sz9DJg=&quot;ct = base64.b64decode(b64)# 你给的 KEYSTREAM（RC4 xor 流）KEYSTREAM = [232,0,230,97,0,0,88,88,0,118,233,0,91,8,29,213,0,224,188,251,252,20,20,0,0,0,0,0,0,0,222,119,0,0,177,0,0,0,0,0,0,0,149,8,120,233,187,175,0,3,3,0,238,96,0,0,241,87,73,96,0,31,31,0]KS = bytes(KEYSTREAM)# 从反编译还原的常数（对应 C++ 中出现的那些十进制常量）C1 = 1668048215   # 0x636c6557C2 = 1949527375   # 0x74336d4fC3 = 1937076784   # 0x73757230C4 = 1432441972   # 0x55615474DELTA = 2117703607  # 0x7e3997b7def swap32(x):    return ((x &amp; 0xFF) &lt;&lt; 24) | ((x &amp; 0xFF00) &lt;&lt; 8) | ((x &gt;&gt; 8) &amp; 0xFF00) | ((x &gt;&gt; 24) &amp; 0xFF)def decrypt_block(block8):    # block8: 8 bytes (as stored in ct)    a = int.from_bytes(block8[0:4], &#x27;little&#x27;)    b = int.from_bytes(block8[4:8], &#x27;little&#x27;)    v11 = swap32(a)    v12 = swap32(b)    sum_ = DELTA * 32    for _ in range(32):        v12 = (v12 - ( ((16 * v11 + C3) ^ (sum_ + v11)) ^ ((v11 &gt;&gt; 5) + C4) )) &amp; 0xFFFFFFFF        v11 = (v11 - ( ((16 * v12 + C1) ^ (v12 + sum_)) ^ ((v12 &gt;&gt; 5) + C2) )) &amp; 0xFFFFFFFF        sum_ = (sum_ - DELTA) &amp; 0xFFFFFFFFFFFFFFFF    return v11.to_bytes(4,&#x27;little&#x27;) + v12.to_bytes(4,&#x27;little&#x27;)# 1) TEA-like 解密（对 ct 按 8 字节块）plain = bytearray()for i in range(0, len(ct), 8):    block = ct[i:i+8]    plain += decrypt_block(block)# 2) 解出的是个 base64 字符串，去除尾部可能的 0x00，再 decodeplain_b64 = bytes(plain).rstrip(b&#x27;\\x00&#x27;)middle = base64.b64decode(plain_b64)# 3) 用你给的 KEYSTREAM 异或（取 middle 长度）res = bytes(middle[i] ^ KS[i] for i in range(len(middle)))print(res.decode())# -&gt; flag&#123;cf8be09b1c8a415f8b5e8f1dac71d4af&#125;\nreference:Tauri 框架的静态资源提取方法探究 | yllhwa&#39;s blog\nhttps://110.41.78.46/bk/index.php/archives/548/\n","categories":["ctf逆向中的misc"],"tags":["tauri"]},{"title":"pe文件结构","url":"/2025/10/09/pe%E9%80%86%E5%90%91/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","content":"前言：pe文件指在windows平台上的可执行文件(.exe，.dll，.com)了解他们的结构虽然对做题没什么用，但如果想开发新型外挂，防御新型外挂都是基于底层原理创新的\npe文件结构总览：\n\n地址的基本概念\nVA（Virtual Address）：虚拟地址PE 文件映射到内存空间时，数据在内存空间中对应的地址。\n\nImageBase：映射基址PE 文件在内存空间中的映射起始位置，是个 VA 地址。\n\nRVA（Relative Virtual Address）：相对虚拟地址PE 文件在内存中的 VA 相对于 ImageBase 的偏移量。\n\nFOA（File Offset Address，FOA）：文件偏移地址PE 文件在磁盘上存放时，数据相对于文件开头位置的偏移量，文件偏移地址等于文件地址。\n\n\n转换关系：\n\nVA = ImageBase + RVA\n\nRVA-节区段首地址的RVA=FOA-节区段首地址的FOA\n\n\npe文件格式DOS_HEADERtypedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header    WORD   e_magic;                     // Magic number    WORD   e_cblp;                      // Bytes on last page of file    WORD   e_cp;                        // Pages in file    WORD   e_crlc;                      // Relocations    WORD   e_cparhdr;                   // Size of header in paragraphs    WORD   e_minalloc;                  // Minimum extra paragraphs needed    WORD   e_maxalloc;                  // Maximum extra paragraphs needed    WORD   e_ss;                        // Initial (relative) SS value    WORD   e_sp;                        // Initial SP value    WORD   e_csum;                      // Checksum    WORD   e_ip;                        // Initial IP value    WORD   e_cs;                        // Initial (relative) CS value    WORD   e_lfarlc;                    // File address of relocation table    WORD   e_ovno;                      // Overlay number    WORD   e_res[4];                    // Reserved words    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)    WORD   e_oeminfo;                   // OEM information; e_oemid specific    WORD   e_res2[10];                  // Reserved words    LONG   e_lfanew;                    // File address of new exe header&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n这是dos头在微软的定义，我们只需要了解\n（1）e_magic： DOS 映像文件格式标记，与 MS-DOS 兼容的 PE 文件都将该值设为 0x4D5A，对应的 ASCII 字符为：MZ。（2）e_ip： DOS 代码的初始化指令入口。（3）e_cs： DOS 代码的初始化代码段入口。（4）e_lfanew：PE 文件头 _IMAGE_NT_HEADERS 结构的 FA 偏移地址，即指向 _IMAGE_NT_HEADERS 结构。\nDOS_STUB该结构未在 winnt.h 中定义，其内容随着链接时使用的链接器不同而不同，通常用于保存在 DOS 环境中的可执行代码。例如：该结构中的代码用于显示字符串：“This program cannot run in DOS mode”。\nNT_HEADER位于 e_lfanew 处，结构\ntypedef struct _IMAGE_NT_HEADERS &#123;    DWORD Signature; // &quot;PE\\0\\0&quot;    IMAGE_FILE_HEADER FileHeader;    IMAGE_OPTIONAL_HEADER OptionalHeader;&#125; IMAGE_NT_HEADERS;\n\nSignature 必须是 PE\\0\\0（0x00004550）。\n\nFileHeader 是 pe文件头，OptionalHeader（尽管名字叫 optional）几乎对可执行文件必需，包含入口点、ImageBase、节对齐等。\n\n\nFILE_HEADERtypedef struct _IMAGE_FILE_HEADER &#123;    WORD    Machine;    WORD    NumberOfSections;    DWORD   TimeDateStamp;    DWORD   PointerToSymbolTable;    DWORD   NumberOfSymbols;    WORD    SizeOfOptionalHeader;    WORD    Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n要掌握的只有：\n（1）Machine：平台类型，映像文件只能在指定的平台或模拟指定平台的系统上运行。在 winnt.h 中定义的 Machine 如下：\n#define IMAGE_FILE_MACHINE_UNKNOWN           0#define IMAGE_FILE_MACHINE_TARGET_HOST       0x0001  // Useful for indicating we want to interact with the host and not a WoW guest.#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-endian#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian#define IMAGE_FILE_MACHINE_THUMB             0x01c2  // ARM Thumb/Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_ARMNT             0x01c4  // ARM Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_AM33              0x01d3#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon#define IMAGE_FILE_MACHINE_CEF               0x0CEF#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)#define IMAGE_FILE_MACHINE_M32R              0x9041  // M32R little-endian#define IMAGE_FILE_MACHINE_ARM64             0xAA64  // ARM64 Little-Endian#define IMAGE_FILE_MACHINE_CEE               0xC0EE\n（2）NumberOfSections：Section 的数目，即 Section Table 数组的元素个数。Windows Loader 限制 Section 的数目为 96 。（3）TimeDateStamp：文件创建的日期和时间。（4）PointerToSymbolTable：PE符号表的 RVA 偏移量，如果 PE符号表不存在，则该值为 0 。（5）NumberOfSymbols：PE符号表中的符号个数。（6）SizeOfOptionalHeader：_IMAGE_OPTIONAL_HEADER 结构的大小，对于 obj 文件，该值为 0 。（7）Characteristics：PE 文件的属性。在 winnt.h 中定义的 Characteristics 如下：\n#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved external references).#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Aggressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle &gt;2gb addresses#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.#define IMAGE_FILE_SYSTEM                    0x1000  // System File.#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.\nOPTIONAL_HEADERtypedef struct _IMAGE_OPTIONAL_HEADER &#123;    //    // Standard fields.    //    WORD    Magic;    BYTE    MajorLinkerVersion;    BYTE    MinorLinkerVersion;    DWORD   SizeOfCode;    DWORD   SizeOfInitializedData;    DWORD   SizeOfUninitializedData;    DWORD   AddressOfEntryPoint;    DWORD   BaseOfCode;    DWORD   BaseOfData;    //    // NT additional fields.    //    DWORD   ImageBase;    DWORD   SectionAlignment;    DWORD   FileAlignment;    WORD    MajorOperatingSystemVersion;    WORD    MinorOperatingSystemVersion;    WORD    MajorImageVersion;    WORD    MinorImageVersion;    WORD    MajorSubsystemVersion;    WORD    MinorSubsystemVersion;    DWORD   Win32VersionValue;    DWORD   SizeOfImage;    DWORD   SizeOfHeaders;    DWORD   CheckSum;    WORD    Subsystem;    WORD    DllCharacteristics;    DWORD   SizeOfStackReserve;    DWORD   SizeOfStackCommit;    DWORD   SizeOfHeapReserve;    DWORD   SizeOfHeapCommit;    DWORD   LoaderFlags;    DWORD   NumberOfRvaAndSizes;    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;typedef struct _IMAGE_OPTIONAL_HEADER64 &#123;    WORD        Magic;    BYTE        MajorLinkerVersion;    BYTE        MinorLinkerVersion;    DWORD       SizeOfCode;    DWORD       SizeOfInitializedData;    DWORD       SizeOfUninitializedData;    DWORD       AddressOfEntryPoint;    DWORD       BaseOfCode;    ULONGLONG   ImageBase;    DWORD       SectionAlignment;    DWORD       FileAlignment;    WORD        MajorOperatingSystemVersion;    WORD        MinorOperatingSystemVersion;    WORD        MajorImageVersion;    WORD        MinorImageVersion;    WORD        MajorSubsystemVersion;    WORD        MinorSubsystemVersion;    DWORD       Win32VersionValue;    DWORD       SizeOfImage;    DWORD       SizeOfHeaders;    DWORD       CheckSum;    WORD        Subsystem;    WORD        DllCharacteristics;    ULONGLONG   SizeOfStackReserve;    ULONGLONG   SizeOfStackCommit;    ULONGLONG   SizeOfHeapReserve;    ULONGLONG   SizeOfHeapCommit;    DWORD       LoaderFlags;    DWORD       NumberOfRvaAndSizes;    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;#ifdef _WIN64typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;#elsetypedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;#endif\n需要记的：\n\nMagic 指示 PE32（0x10b）或 PE32+（0x20b，用于 x64）。PE32+ 没有某些 32-bit 字段（如 BaseOfData）。\n\n重要字段：\n\nAddressOfEntryPoint（RVA） — 程序入口点（EP）。\n\nImageBase — 默认加载基址（x86 常 0x400000，x64 常 0x140000000）。\n\nSectionAlignment 内存对齐粒度，即 PE 文件映射到内存时的对齐粒度；默认值为系统页面大小 0x1000（4KB）；该值必须大于或等于 FileAligment 的值。\n\nFileAlignment — 磁盘对齐粒度，即 PE 文件在磁盘中存储时的对齐粒度；默认值为磁盘页面大小 0x200（512B）；如果 SectionAlignment 的值小于系统页面大小，则该值必须与 SectionAlignment 的值相同。\n\nSizeOfImage — 映像在内存中的总大小（按 SectionAlignment 对齐）。\n\nSizeOfHeaders — 所有头部（包括节表）在文件中的合占大小（按 FileAlignment 对齐）。\n\nDataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] — 数据目录数组，指向导入表/导出表/资源/重定位/证书等。每个目录是 (RVA, Size)。这是进入各种表的门。\n\n\n\n\nSection Table（节表 / Section Headers）在 IMAGE_NT_HEADERS 之后，紧跟 NumberOfSections 个 IMAGE_SECTION_HEADER。每个节描述文件和内存中的一个区域（例如 .text, .rdata, .data, .rsrc 等）。\ntypedef struct _IMAGE_SECTION_HEADER &#123;    BYTE  Name[8];             // 节名（如 &quot;.text&quot;）    union &#123;      DWORD PhysicalAddress;      DWORD VirtualSize;    &#125; Misc;    DWORD VirtualAddress;      // RVA（节在内存中的起始 RVA）    DWORD SizeOfRawData;       // 文件中该节占用字节数（按 FileAlignment）    DWORD PointerToRawData;    // 文件偏移（file offset）到节数据    DWORD PointerToRelocations;    DWORD PointerToLinenumbers;    WORD  NumberOfRelocations;    WORD  NumberOfLinenumbers;    DWORD Characteristics;     // 可读/可写/可执行 等标志&#125; IMAGE_SECTION_HEADER;\n常见节：\n\n.text — 代码段（可执行、只读）。\n\n.rdata — 只读数据（导出表、字符串、常量）。\n\n.data — 已初始化的可读写数据。\n\n.bss / uninitialized data — 在 PE 通常以 VirtualSize 指定但 SizeOfRawData 可能为 0。\n\n.rsrc — 资源（图标、对话框、版本信息等）。\n\n.reloc — 基址重定位表（如果启用了 ASLR 或 ImageBase 不是默认值时需要）。\n\n.pdata / .xdata（x64 异常/函数表）等。\n\n\n可选文件头中的数据目录表：Data Directory 位于 IMAGE_OPTIONAL_HEADER 内，是一个固定长度的数组（通常 16 项，IMAGE_NUMBEROF_DIRECTORY_ENTRIES）。每项结构如下：\ntypedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD VirtualAddress; // RVA（或对于某些目录是 file offset 特例）    DWORD Size;&#125; IMAGE_DATA_DIRECTORY;\n我们只需要记住里面的导出表，导入表，重定位表\n导出表：位于 数据目录表第 0 项（IMAGE_DIRECTORY_ENTRY_EXPORT = 0）\ntypedef struct _IMAGE_EXPORT_DIRECTORY &#123;    DWORD   Characteristics;       // 通常为0，保留字段    DWORD   TimeDateStamp;         // 时间戳（编译时间）    WORD    MajorVersion;          // 主版本号（可选）    WORD    MinorVersion;          // 次版本号（可选）    DWORD   Name;                  // 模块名字符串的 RVA（如 &quot;KERNEL32.dll&quot;）    DWORD   Base;                  // 导出序号起始值（通常为1）    DWORD   NumberOfFunctions;     // EAT (Export Address Table) 的函数总数    DWORD   NumberOfNames;         // 按名称导出的函数数量    DWORD   AddressOfFunctions;    // RVA → DWORD 数组（EAT），每项为函数的 RVA    DWORD   AddressOfNames;        // RVA → DWORD 数组，保存函数名的 RVA    DWORD   AddressOfNameOrdinals; // RVA → WORD 数组，保存函数名对应的序号索引&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\nName 导出表文件名首地址Base 导出函数起始序号NumberOfFunctions是dll文件中导出函数的个数：最大的序号-最小序号+1NumberOfNames以名称导出函数的个数：即在dll文件中函数后面不加noname的数量\n首先我们要知道dll文件通常怎么编写导出哪些函数，一般是用.def文件存储函数和序号,编译时指定这个def文件\nLIBRARY mydllEXPORTS    sum @2    Add @3 NONAME    mul @7\n上面这个例子里NumberOfFunctions就是6=7-2+1；\nNumberOfNames就是2\n在DLL文件中如何找到要用的函数呢？AddressOfNames存的是函数名称起始位置的偏移。AddressOfNameOrdinals存的是序号，加上Base等于dll文件中函数后面的序号。AddressOfFunctions存的是真正函数存储位置的偏移。\n从右向左看\n要找到MessageBoxW的函数地址，首先从AddressOfNames在AddressOfNameOrdinals中的索引找到MessageBoxW的序号，在AddressOfFunctions按序号找到地址。\n\n导入表一个文件只有一个导出表，有多个导入表\nINT：导入名称表，无论在文件中还是在内存中都是指向函数的名称\nIAT: 导入地址表，在文件中时，与INT是一样的指向函数名称，在内存中保存的是函数实际地址\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD   Characteristics;        // 原先叫 OriginalFirstThunk        DWORD   OriginalFirstThunk;     // 指向 IMAGE_THUNK_DATA 数组    &#125; DUMMYUNIONNAME;    DWORD   TimeDateStamp;              // 时间戳（若为绑定导入，则非零）    DWORD   ForwarderChain;             // 转发器链表索引（一般为 0）    DWORD   Name;                       // 导入模块名字符串的 RVA（如 &quot;USER32.dll&quot;）    DWORD   FirstThunk;                 // 指向 IAT（IMAGE_THUNK_DATA 数组）&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;\ntypedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString;      // 转发字符串 RVA        DWORD Function;             // 实际函数地址（IAT 填充后）        DWORD Ordinal;              // 按序号导入时，高位标志+序号        DWORD AddressOfData;        // 指向 IMAGE_IMPORT_BY_NAME 的 RVA    &#125; u1;&#125; IMAGE_THUNK_DATA32;\ntypedef struct _IMAGE_IMPORT_BY_NAME &#123;    WORD    Hint;       // 建议序号（可加快查找速度）    CHAR    Name[1];    // 函数名字符串（以 &#x27;\\0&#x27; 结束）&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;\n这三个结构体之间的关系可以用图表示\n\n_IMAGE_THUNK_DATA32四个字段的工作方式：u1.AddressOfData 按名称导入时的初始状态。这是最常见的导入方式。它是一个 RVA，指向 IMAGE_IMPORT_BY_NAME 结构体。\nLoader 执行时：\n\n检查高位标志（是否为按序号导入）\n\n如果按名称导入 → 从 AddressOfData 找到字符串 &quot;MessageBoxA&quot;\n\n调用 GetProcAddress(&quot;MessageBoxA&quot;)\n\n把查到的实际函数地址 写回到同一个 thunk 里→ 此时该 DWORD 的含义变成了 Function\n\n\nu1.Function\n\n\n\n阶段\n字段含义\n\n\n\n\n程序加载前\nAddressOfData（指向函数名结构）\n\n\n程序徐加载后\nFunction（函数实际地址）\n\n\n\n\n所以你用 IDA 或 PE-Bear 打开导入表时，可以看到一列是函数地址（已经被修正），那就是 u1.Function 的值。\nu1.Ordinal如果是 按序号导入（而不是按名称），那么 IMAGE_THUNK_DATA 的最高位会被置为 1,这个时候序号是ordinal的低16位\nLoader 检查后，会直接按序号查找导出表中的对应函数。\nu1.ForwarderString具体工作流程\n\n程序启动，系统加载器解析其导入表。\n\n加载器看到需要从 Old.dll 导入一个函数。\n\n加载器检查该函数对应的 IMAGE_THUNK_DATA 结构。\n\n如果发现这个条目被标记为一个转发（Loader 看到字符串里有 .，就知道它是转发函数），那么 u1.ForwarderString 字段中存储的值就是一个 RVA。\n\n这个 RVA 指向 PE 文件内部的一个字符串，这个字符串就是转发的目标，例如 &quot;NewDLL.NewFunction&quot;。\n\n加载器于是会转而加载 NewDLL.dll，获取 NewFunction 的地址，并填充到程序的 IAT 中。\n\n\n重定位表为什么需要重定位表：假设你编译了一个 DLL：\n编译期设定的镜像基址 (ImageBase) = 0x10000000\n代码里可能存在这样的指令：\nmov eax, [0x10003000]  ; 访问全局变量的绝对地址\n但是当系统加载这个 DLL 时，如果地址 0x10000000 已经被别的模块占用，Windows 就会把它加载到另一个位置，比如 0x20000000。\n 那么所有访问 0x10003000 的指令都错了！\n重定位表的任务：告诉系统：“文件里哪些地方用了绝对地址”，好让 Loader 在加载时给它们加上偏移量修正\n重定位表的结构层级:整体结构是由若干个 重定位块 (Base Relocation Block) 组成。\ntypedef struct _IMAGE_BASE_RELOCATION &#123;    DWORD VirtualAddress; // 该块对应的页基址（相对整个镜像）    DWORD SizeOfBlock;    // 该块的大小（包括头和所有偏移项）    // 后面紧跟若干个 WORD 类型的重定位项（类型 + 偏移）&#125; IMAGE_BASE_RELOCATION;//采取这种基址加偏移的存储结构优点是能节省空间，这种结构只需要8+4n字节可以存n个，但不是这种结构需要8n字节才能存n个\n重定位项 (WORD) 结构\n每个 WORD 包含两个部分（共 16 位）：\n\n\n\n\n位段\n名称\n含义\n\n\n\n\n高 4 位\nType\n重定位类型\n\n\n低 12 位\nOffset\n该页内偏移\n\n\n\n\ntype类型在微软中的定义：\n\n\n\n\nType 值\n名称\n用途\n\n\n\n\n0\nIMAGE_REL_BASED_ABSOLUTE\n无效项（跳过/对齐用）\n\n\n1\nIMAGE_REL_BASED_HIGH\n高16位修正（16位系统遗留）\n\n\n2\nIMAGE_REL_BASED_LOW\n低16位修正\n\n\n3\nIMAGE_REL_BASED_HIGHLOW\n32位绝对地址修正（最常用）\n\n\n10\nIMAGE_REL_BASED_DIR64\n64位绝对地址修正\n\n\n\n\n在内存中的结构：\n\n重定位表的工作原理（Windows Loader 处理流程）1.系统加载映像文件：\n\n期望基址 = ImageBase（例如 0x10000000）\n\n实际加载地址 = LoadBase（例如 0x20000000）\n\n\n2.计算偏移差：\nDelta = LoadBase - ImageBase;   // = 0x10000000\n3.遍历每个重定位块：\n\n找到 IMAGE_BASE_RELOCATION.VirtualAddress\n\n遍历其中的所有 WORD 项\n\n\n4.按类型修正目标地址：\n\n如果类型是 IMAGE_REL_BASED_HIGHLOW：\n\nDWORD* pAddr = (DWORD*)(imageBase + VirtualAddress + Offset);*pAddr += Delta;\n5.加载器修正完这些地址后：\n\n所有全局变量、函数指针都指向正确的绝对地址；\n\n.reloc 区域在内存中可以被释放（某些加载器会保留用于卸载）\n\n\n\n\n\n\n阶段\n内容\n\n\n\n\n编译期\n生成以固定 ImageBase 链接的可执行文件\n\n\n加载期\n如果装入地址 ≠ ImageBase，则触发重定位\n\n\n.reloc\n记录所有需要修改绝对地址的地方\n\n\nLoader\n根据差值修正每个位置的值\n\n\n类型\nHIGHLOW（32位） 或 DIR64（64位）\n\n\n\n\nTLS表什么是TLS?TLS是 Thread Local Storage的缩写线程局部存储。主要是为了解决多线程中变量同步的问题。\ntls变量：TLS变量只需要定义一次，类似全局变量，但定义完后每一个线程都能获取TLS变量的副本，解决了不能同步访问TLS的问题。节约了时间和成本。\ntls回调函数：typedef VOID (NTAPI *PIMAGE_TLS_CALLBACK)(    PVOID DllHandle,    DWORD Reason,      // DLL_PROCESS_ATTACH / DLL_THREAD_ATTACH / DLL_THREAD_DETACH / DLL_PROCESS_DETACH    PVOID Reserved);\n它会在进程附加（1），线程附加（2），线程脱离（3），进程脱离（0）时调用（小括号内数字指这四个状态对应整数）：\n\n回调会在 Loader 设置好 TLS 数据后被调用。因此回调内部可以读取/写入静态 TLS 变量（以每线程视图访问）。\n\n调用时机：\n\n当模块被装载（process attach）时，Loader 为当前存在的线程分配/初始化 TLS 模板（把模板拷贝给每个线程），然后调用模块的 TLS 回调，回调通常以 DLL_PROCESS_ATTACH 为 Reason。\n\n当一个新线程被创建时，Loader 会为该线程拷贝 TLS 模板并调用已加载模块的 TLS 回调（DLL_THREAD_ATTACH）。\n\n当线程退出时，Loader 会先调用 DLL_THREAD_DETACH 回调，然后释放该线程的 TLS 数据。\n\n当模块卸载或进程退出时，会按顺序调用 DLL_PROCESS_DETACH 回调。\n\n\n\n执行时的约束：\n\nTLS 回调在 Loader Lock 下执行（与 DllMain 的执行约束类似），因此在回调中调用可能导致死锁的 API（如 LoadLibrary、某些同步函数）可能不安全。\n\n回调可能在非常早的阶段执行（在 DllMain 被调用之前），所以某些运行时/全局初始化可能尚未完成。\n\n\n\n多个回调：AddressOfCallBacks 指向的回调数组中回调按数组顺序被调用（从低地址到高地址），数组以 NULL 结束。多个模块的回调调用顺序涉及模块加载顺序。\n\n\n代码(包含tls变量和回调函数)#include&lt;Windows.h&gt;#include&lt;iostream&gt;#pragma comment(linker,&quot;/INCLUDE:__tls_used&quot;) //要声明连接tls_declspec(thread) int g_number = 100;  //tls变量HANDLE hEvent = NULL;DWORD WINAPI threadProc1(LPVOID lparam)&#123;    g_number = 200;    printf(&quot;threadProc1 g_number=%d\\n&quot;, g_number);    SetEvent(hEvent);    return 0;&#125;DWORD WINAPI threadProc2(LPVOID lparam)&#123;    WaitForSingleObject(hEvent, -1);    printf(&quot;threadProc2 g_number=%d\\n&quot;, g_number);    return 0;&#125;void NTAPI t_TlsCallBack_A(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    printf(&quot;TLS函数执行了\\n&quot;);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)//存储回调函数地址PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; t_TlsCallBack_A,0 &#125;;#pragma data_seg()int main()&#123;    hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);    HANDLE hThread1 = CreateThread(NULL, NULL, threadProc1, NULL, NULL, NULL);    HANDLE hThread2 = CreateThread(NULL, NULL, threadProc2, NULL, NULL, NULL);    WaitForSingleObject(hThread1,-1);    WaitForSingleObject(hThread2,-1);    CloseHandle(hEvent);    system(&quot;pause&quot;);    return 0;&#125;\ntls反调试：既然我们知道了TLS是最先执行的，那么我们在TLS回调函数中加上判断是否被调试的API，若被调试直接在OEP之前终止程序，即可做到反调试。\n#include&lt;Windows.h&gt;#include&lt;iostream&gt;#pragma comment(linker,&quot;/INCLUDE:__tls_used&quot;)void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    if (Reason == DLL_PROCESS_ATTACH)    &#123;        BOOL result = FALSE;        HANDLE hNewHandle = 0;        DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), GetCurrentProcess(), &amp;hNewHandle, NULL, NULL, DUPLICATE_SAME_ACCESS);        CheckRemoteDebuggerPresent(hNewHandle, &amp;result);//微软提供的API 判断该文件有没有被调试        if (result)        &#123;            MessageBoxA(0, &quot;程序被调试了！&quot;, &quot;警告&quot;, MB_OK);            ExitProcess(0);        &#125;    &#125;    return;&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1,0 &#125;; #pragma data_seg()int main()&#123;    printf(&quot;main函数执行了&quot;);    system(&quot;pause&quot;);    return 0;&#125;\ntls表typedef struct _IMAGE_TLS_DIRECTORY &#123;    DWORD StartAddressOfRawData;      // TLS 数据的起始 VA（虚拟地址）    DWORD EndAddressOfRawData;        // TLS 数据的结束 VA（虚拟地址）    DWORD AddressOfIndex;             // 存放 TLS 索引的指针（VA）    DWORD AddressOfCallBacks;         // TLS 回调函数数组的指针（VA）    DWORD SizeOfZeroFill;             // 填充 0 的大小    DWORD Characteristics;            // 特性标志，一般为0&#125; IMAGE_TLS_DIRECTORY32;\npe文件结构代码：文件结构：\n头文件：Main.cpp,CPeUtil.h\n源文件：CPeUtil.cpp\nCPeUtil.cpp:#include &quot;CPeUtil.h&quot;CPeUtil::CPeUtil()&#123;    FileBuff=NULL;    FileSize=0;    pDosHeader = NULL;    pNtHeaders = NULL;    pFileHeader = NULL;    pOptionHeader = NULL;&#125;CPeUtil::~CPeUtil()&#123;    if (FileBuff)    &#123;        delete[]FileBuff;        FileBuff = NULL;    &#125;&#125;//载入文件BOOL CPeUtil::loadFile(const char* patch)&#123;    HANDLE hFile = CreateFileA(patch, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);    if (hFile==0)     &#123;        return FALSE;    &#125;    //私有成员变量获取文件大小并初始化缓冲区    FileSize = GetFileSize(hFile, 0);    FileBuff = new char[FileSize]&#123;0&#125;;    DWORD realReadBytes = 0;    //是否读取成功    BOOL readSuccess =ReadFile(hFile,FileBuff,FileSize,&amp;realReadBytes,0);    if (readSuccess==0)    &#123;        return FALSE;    &#125;    if (InitPeInfo())    &#123;        CloseHandle(hFile);        return TRUE;    &#125;    return FALSE;&#125;//加载文件后初始化不同头位置BOOL CPeUtil::InitPeInfo()&#123;    //用以下两个判断该文件是否为PE文件    pDosHeader = (PIMAGE_DOS_HEADER)FileBuff;    if (pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)    &#123;        return FALSE;    &#125;    pNtHeaders = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + FileBuff);    if (pNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)    &#123;        return FALSE;    &#125;    pFileHeader = &amp;pNtHeaders-&gt;FileHeader;    pOptionHeader = &amp;pNtHeaders-&gt;OptionalHeader;    return TRUE;&#125;//输出区段头void CPeUtil::PrintSectionHeaders()&#123;    PIMAGE_SECTION_HEADER pSectionHeaders = IMAGE_FIRST_SECTION(pNtHeaders);//获取第一个区段头地址    //遍历不同区段    for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++)    &#123;        char name[9]&#123; 0 &#125;;        memcpy_s(name, 9, pSectionHeaders-&gt;Name, 8);        printf(&quot;区段名称：%s\\n&quot;, name);        pSectionHeaders++;    &#125;&#125;//解析导出表void CPeUtil::GetExportTable()&#123;    IMAGE_DATA_DIRECTORY directory = pOptionHeader-&gt;DataDirectory[0];    PIMAGE_EXPORT_DIRECTORY pexport = (PIMAGE_EXPORT_DIRECTORY)RvaToFoa(directory.VirtualAddress);    char *dllName = RvaToFoa(pexport-&gt;Name)+FileBuff;    printf(&quot;文件名称：%s\\n&quot;, dllName);    //遍历不同函数的地址    DWORD* funaddr = (DWORD*)(RvaToFoa(pexport-&gt;AddressOfFunctions) + FileBuff);    WORD* peot = (WORD*)(RvaToFoa(pexport-&gt;AddressOfNameOrdinals) + FileBuff);    DWORD* pent = (DWORD*)(RvaToFoa(pexport-&gt;AddressOfNames) + FileBuff);    for (int i = 0; i &lt; pexport-&gt;NumberOfFunctions; i++)    &#123;        printf(&quot;函数地址为：%x\\n&quot;,*funaddr);        for (int j = 0; j &lt; pexport-&gt;NumberOfNames; j++)        &#123;            if (peot[j]==i)            &#123;                char* funName = RvaToFoa(pent[j])+FileBuff;                printf(&quot;函数名称为：%s\\n&quot;, funName);                break;            &#125;        &#125;        funaddr++;    &#125;&#125;//获取导入表void CPeUtil::GetImportTables()&#123;    //导入表也是数据目录表的一部分，作为第二个    IMAGE_DATA_DIRECTORY directory = pOptionHeader-&gt;DataDirectory[1];    //获取真正导入表地址    PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(RvaToFoa(directory.VirtualAddress) + FileBuff);    //判断联合体中是否有数据    while (pImport-&gt;OriginalFirstThunk)    &#123;        char* dllName = RvaToFoa(pImport-&gt;Name) + FileBuff;        printf(&quot;dll文件名称为：%s\\n&quot;, dllName);        PIMAGE_THUNK_DATA pThunkData = (PIMAGE_THUNK_DATA)(RvaToFoa(pImport-&gt;OriginalFirstThunk) + FileBuff);        //判断联合体中是否有数据        while (pThunkData-&gt;u1.Function)        &#123;            //判断是按序号导入还是按名称导入            if (pThunkData-&gt;u1.Ordinal &amp; 0x80000000)            &#123;                printf(&quot;按序号导入:%d\\n&quot;, pThunkData-&gt;u1.Ordinal &amp; 0x7FFFFFFF);            &#125;            else            &#123;                PIMAGE_IMPORT_BY_NAME importName = (PIMAGE_IMPORT_BY_NAME)(RvaToFoa(pThunkData-&gt;u1.AddressOfData) + FileBuff);                printf(&quot;按名称导入:%s\\n&quot;, importName-&gt;Name);            &#125;            pThunkData++;        &#125;        pImport++;    &#125;&#125;//RVA转化FOADWORD CPeUtil::RvaToFoa(DWORD rva)&#123;    PIMAGE_SECTION_HEADER pSectionHeaders = IMAGE_FIRST_SECTION(pNtHeaders);//获取第一个区段头地址    //遍历不同区段    for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++)    &#123;        if (rva &gt;= pSectionHeaders-&gt;VirtualAddress &amp;&amp; rva &lt; pSectionHeaders-&gt;VirtualAddress + pSectionHeaders-&gt;Misc.VirtualSize)        &#123;            //数据的FOA=数据的RVA-区段的RVA+区段的FOA            return rva - pSectionHeaders-&gt;VirtualAddress + pSectionHeaders-&gt;PointerToRawData;        &#125;        pSectionHeaders++;    &#125;    return 0;&#125;\nCPeUtil.h#pragma once#include&lt;Windows.h&gt;#include&lt;iostream&gt;class CPeUtil &#123;public:    CPeUtil();    ~CPeUtil();    BOOL loadFile(const char* patch);    BOOL InitPeInfo();    void PrintSectionHeaders();    void GetExportTable();    void GetImportTables();private:    char* FileBuff;    DWORD FileSize;    PIMAGE_DOS_HEADER pDosHeader;    PIMAGE_NT_HEADERS pNtHeaders;    PIMAGE_FILE_HEADER pFileHeader;    PIMAGE_OPTIONAL_HEADER pOptionHeader;    DWORD RvaToFoa(DWORD rva);&#125;;\nmain.cpp#include&lt;iostream&gt;#include&quot;CPeUtil.h&quot;int main()&#123;    CPeUtil peUtil;    BOOL ifSuccess = peUtil.loadFile(&quot;D:\\\\code\\\\VisualStudio2022\\\\FirstDLL\\\\Debug\\\\FirstDLL.dll&quot;);    if (ifSuccess)    &#123;        peUtil.GetImportTables();        //peUtil.GetExportTable();        //peUtil.PrintSectionHeaders();        return 0;    &#125;    printf(&quot;加载PE文件失败！\\n&quot;);    return 0;&#125;\nReference:https://blog.csdn.net/weixin_44143678/article/details/120044602?spm=1001.2014.3001.5506\n【【保姆级教程】16 节吃透 Windows PE 文件格式！从解析到 Hook 攻防全覆盖】https://www.bilibili.com/video/BV1cXT4z7Etf?p=8&amp;vd_source=ef1be23ebedc3f547905767af45d9f93\n","categories":["pe逆向","pe逆向基础"],"tags":["pe文件结构"]},{"title":"windows窗口运行逻辑和常用api","url":"/2025/10/15/pe%E9%80%86%E5%90%91/windows%E7%AA%97%E5%8F%A3%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%E5%92%8C%E5%B8%B8%E7%94%A8api/","content":"前言：windows窗口编程就是创造一个窗口并实现消息循环，我们需要逆向的是窗口消息处理函数\n流程：入口点：窗口的入口点是WinMain()函数\nint WINAPI WinMain(    HINSTANCE hInstance,     HINSTANCE hPreInstance,    LPSTR lpCmdeLine,    int nCmdShow) \n\nHINSTANCE hInstance ：\n\n含义：当前模块（process module）的实例句柄。\n\n现代 Windows（32/64 位）中 HINSTANCE 与 HMODULE 等价，表示模块基址（即 exe 或 dll 的加载基址）。也就是说 HINSTANCE == HMODULE。\n\n常用场景：作为资源加载的句柄参数（LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APP))、FindResource(hInstance, ...) 等）；也常用来创建窗口类 WNDCLASSEX.hInstance。\n\n获取方式：程序入口 WinMain 会直接给出；也可以在任意地方用 GetModuleHandle(NULL) 获取当前可执行模块句柄，或 GetModuleHandle(&quot;mylib.dll&quot;) 获取指定 DLL 的句柄。\n\nx86/x64 区别：无差别。都是指向模块基址的句柄（底层为值型，大小随平台指针宽度而定）。\n\n只有在16位可执行程序里会有差别，因为16位同时多开exe，并不是独立的分割内存，而如今都是每个进程分配4gb\n\n\n\nHINSTANCE hPreInstance 已废弃，填null即可\n\nLPSTR lpcmdeline：含义：指向以空字符结尾的命令行字符串（char*，ANSI 版 WinMain 使用）。\n\nint nCmdShow：含义：程序窗口的初始显示状态，由操作系统或调用者（例如从快捷方式的“运行方式”设置或 ShowWindow 参数）传入。通常传给 ShowWindow(hwnd, nCmdShow)。\n\n\n1.创建一个窗口类WNDCLASSW myClass = &#123; 0 &#125;;myClass.lpszClassName = L&quot;51hook&quot;;myClass.lpfnWndProc = WindowProc;\n其中WNDCLASSW的定义：\ntypedef struct tagWNDCLASSEX &#123;    UINT cbSize;    UINT style;    WNDPROC lpfnWndProc;    // 窗口过程指针    int cbClsExtra;    int cbWndExtra;    HINSTANCE hInstance;    HICON hIcon;    HCURSOR hCursor;    HBRUSH hbrBackground;    LPCTSTR lpszMenuName;    LPCTSTR lpszClassName;    HICON hIconSm;&#125; WNDCLASSEX;\n其中最重要的就是   WNDPROC lpfnWndProc;    // 窗口过程指针。做逆向只需要学会它的用法\n2.注册窗口类RegisterClassW(&amp;myClass);\n3.创建窗口用 CreateWindowW\n//3.创建窗口    HWND hwindow = CreateWindowW(        myClass.lpszClassName,        L&quot;51hook&quot;,        WS_OVERLAPPEDWINDOW,        CW_USEDEFAULT,        0,        CW_USEDEFAULT,        0,        NULL,        NULL,        hInstance,        0    );\n函数定义：\nHWND CreateWindowEx(  DWORD dwExStyle,  LPCTSTR lpClassName,  LPCTSTR lpWindowName,  DWORD dwStyle,  int x, int y, int nWidth, int nHeight,  HWND hWndParent,  HMENU hMenu,  HINSTANCE hInstance,  LPVOID lpParam);\n\ndwExStyle/dwStyle：窗口扩展样式 / 样式（WS、WS_EX）\n\nlpClassName：类名（或 Atom）\n\nlpWindowName：窗口标题（Caption）\n\nhMenu：菜单或子控件 ID（对于子窗口/控件是控件 ID）\n\nlpParam：传递给 WM_CREATE 的 CREATESTRUCT* 的 lpCreateParams 字段（常用于传递指针）逆向：\n\nCreateWindowEx 返回的 HWND 常会被存到全局或成员变量中，搜索 mov [global], eax（x86）或 mov [rip+..], rax（x64）可定位。\n\n若使用类 atom（整数），lpClassName 参数的高位为小值。\n\n\n补充：winapi中A版本和W版本（就是函数后的字母）区别只有参数可不可以是unicode的区别，W版本可以用unicode编码，比如说可以写字符串L’这是unicode编码’\n4.显示窗口ShowWindow(hwindow, SW_SHOWNORMAL);\nBOOL ShowWindow(HWND hWnd, int nCmdShow);BOOL UpdateWindow(HWND hWnd);\n\nShowWindow 常在窗口创建后调用以显示窗口（nCmdShow=SW_SHOW, SW_SHOWNORMAL 等）\n\nUpdateWindow 触发 WM_PAINT（如果需要）\n\n\n5.消息循环MSG msg;    while (GetMessage(&amp;msg, NULL, 0, 0))    &#123;        TranslateMessage(&amp;msg);        DispatchMessage(&amp;msg);    &#125;\nGetMessage:获取消息，如果不是WM_quit就接着循环\nTranslateMessage / DispatchMessage\nTranslateMessage：将虚拟键消息转换为字符消息（WM_KEYDOWN -&gt; WM_CHAR）\n\nDispatchMessage：把消息派发到目标窗口的 WndProc（最终调用 CallWindowProc）\n\n\n6.分析WndProcLRESULT CALLBACK WindowProc(   //消息处理函数    _In_ HWND   hwnd, //窗口句柄    _In_ UINT   uMsg, // 接收的消息    _In_ WPARAM wParam, //小参数，低6位放    _In_ LPARAM lParam //long 参数，高16位放鼠标x坐标，低16位放鼠标y坐标) &#123;    switch (uMsg)    &#123;    case WM_CREATE:        MessageBoxW(hwnd, L&quot;窗口创建了&quot;, L&quot;提示&quot;, MB_OK);        break;    case WM_CLOSE:        MessageBoxW(hwnd, L&quot;窗口关闭了&quot;, L&quot;提示&quot;, MB_OK);        DestroyWindow(hwnd);        PostQuitMessage(0);        break;    default:        break;    &#125;    return DefWindowProcW(hwnd,uMsg,wParam,lParam);&#125;\n其中函数参数：\n\n\n\n\n参数\n类型\n典型用途\n注意点\n\n\n\n\nHWND hwnd\n窗口句柄\n唯一标识窗口实例\n用于区分不同窗口\n\n\nUINT uMsg\n消息ID\n指定当前消息类型\n用于 switch 分发\n\n\nWPARAM wParam\n辅助参数\n消息相关状态/标志/ID\n含义因消息而异\n\n\nLPARAM lParam\n扩展参数\n附加数据，如坐标、句柄\n依赖消息类型解释\n\n\n\n\n最常见的wparam和lparam的用法：\n\n\n\n\n消息类型\nwParam 含义\n\n\n\n\nWM_KEYDOWN\n虚拟键码（VK_XXX）\n\n\nWM_LBUTTONDOWN\n鼠标按键状态（MK_CONTROL / MK_SHIFT 等标志）\n\n\nWM_COMMAND\n高16位是通知码（如按钮点击），低16位是控件ID(父窗口内的代号)\n\n\nWM_TIMER\n定时器ID\n\n\n\n\n\n\n\n\n消息\nlParam 含义\n\n\n\n\nWM_MOUSEMOVE(鼠标移动), WM_LBUTTONDOWN(鼠标左键被按下) 等\n低16位 = X坐标， 高16位 = Y坐标\n\n\nWM_COMMAND(操作菜单、控件，快捷键、加速键，或程序调用 SendMessage(hwnd, WM_COMMAND, …) 时，系统就会发送这个消息给对应的窗口过程。)\n如果来自控件（子窗口）：lParam 是该控件的 HWND。如果来自菜单/加速键：lParam 为 0（因此可以用来区分）\n\n\n\n\n具体消息和处理逆向我们还需要进一步积累，这里只是起抛砖引玉的作用 \n实际例子：#include&lt;Windows.h&gt;#include&lt;iostream&gt;LRESULT CALLBACK WindowProc(   //消息处理函数    _In_ HWND   hwnd,    _In_ UINT   uMsg,    _In_ WPARAM wParam,    _In_ LPARAM lParam) &#123;    switch (uMsg)    &#123;    case WM_CREATE:        MessageBoxW(hwnd, L&quot;窗口创建了&quot;, L&quot;提示&quot;, MB_OK);        break;    case WM_CLOSE:        MessageBoxW(hwnd, L&quot;窗口关闭了&quot;, L&quot;提示&quot;, MB_OK);        DestroyWindow(hwnd);        PostQuitMessage(0);        break;    default:        break;    &#125;    return DefWindowProcW(hwnd,uMsg,wParam,lParam);&#125;int WINAPI WinMain(    HINSTANCE hInstance,    HINSTANCE hPreInstance,    LPSTR lpCmdeLine,    int nCmdShow) &#123;    //1.创建一个窗口类    WNDCLASSW myClass = &#123; 0 &#125;;    myClass.lpszClassName = L&quot;51hook&quot;;    myClass.lpfnWndProc = WindowProc;    //2.注册窗口类    RegisterClassW(&amp;myClass);    //3.创建窗口    HWND hwindow = CreateWindowW(        myClass.lpszClassName,         L&quot;51hook&quot;,        WS_OVERLAPPEDWINDOW,        CW_USEDEFAULT,        0,        CW_USEDEFAULT,        0,        NULL,        NULL,        hInstance,        0    );    //4.显示窗口    ShowWindow(hwindow, SW_SHOWNORMAL);​    //5.获取消息    MSG msg = &#123; 0 &#125;;    while (GetMessageW(&amp;msg, 0,0,0)) &#123;        DispatchMessageW(&amp;msg);//分发消息给消息处理函数    &#125;​    return 0;&#125;\n","categories":["pe逆向","pe逆向基础"],"tags":["窗口逆向"]},{"title":"rust逆向基础-rust基础语法","url":"/2025/10/01/rust%E9%80%86%E5%90%91%E9%A2%98%E5%8D%95/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","content":"前言:拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下\nrust相比其他编程语言的优势:\nrust不通过GC(garbage collection)机制管理内存,例如python,golang等基于GC机制的编程语言会在exe运行时不断寻找虚拟地址中无用的内存空间.这会大大降低运行速度\n\nrust使用所有权机制管理内存,这也使得它相比与手动开辟内存的c/c++更安全\n\n\n我们rust在逆向中通常用于网络编程,游戏编程,wasm,嵌入式.所以写游戏外挂,实现检测外挂都必须要学习rust.\n语法:变量:rust中变量声明要用let.rust中每个变量类型可以自己指定,也可交给编译器推断,每个变量类型可以声明可变也可声明不可变.(注:如果要声明常量类型时,常量名一定要全大写,并且必须显示指定类型.例如const MAX:u32=10;)\n整数类型\n有符号：i8, i16, i32, i64, i128, isize\n\n无符号：u8, u16, u32, u64, u128, usize\n\n\n浮点数\nf32（32 位单精度）\n\nf64（64 位双精度，默认）\n\n\n布尔型\ntrue\n\nfalse\n\n\nchar型字符串型\n&amp;str → 字符串切片（不可变）\n\nString → 堆分配的可变字符串\n\n\nfn main() &#123;    let n: i32= 5; // 变量后的：i32可以自己指定，也可让编译器推断    let mut i: u32 = 5; // u32 表示32位无符号整数,mut表示可变    println!(&quot;The value of n is &#123;&#125;&quot;,n); // println! 用来打印字符串到终端，n代表换行，!代表宏    println!(&quot;The value of i is &#123;&#125;&quot;,i);    i=7;    println!(&quot;The value of i is &#123;&#125;&quot;,i);    let x: f64 = 5.2;    println!(&quot;The value of x is &#123;&#125;&quot;,x);    let y: char =&#x27;d&#x27;;    println!(&quot;The value of y is &#123;&#125;&quot;,y);    let t=true;    println!(&quot;The value of t is &#123;&#125;&quot;,t);    let str: &amp;str=&quot;hello&quot;;    println!(&quot;The value of str is &#123;&#125;&quot;,str);    let mut s2: String = String::from(&quot;Hello&quot;);    s2.push_str(&quot;, Rust!&quot;);        // 可变字符串    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n输出结果:\nThe value of n is 5The value of i is 5The value of i is 7The value of x is 5.2The value of y is dThe value of t is trueThe value of str is helloHello, Rust!\n控制语句:if-else if-else// iflet n = 5;if n &lt; 0 &#123;    println!(&quot;负数&quot;);&#125; else &#123;    println!(&quot;非负数&quot;);&#125;\n循环\nloop 一直循环\n\nwhile 有条件的循环\n\nfor\n\n\n可以通过break跳出循环,也可以通过continue继续当前循环.这和c++是一样的\n// looplet mut counter = 0;let result = loop &#123;    counter += 1;    if counter == 10 &#123;        break counter * 2; // 返回值    &#125;&#125;;// whilelet mut i = 3;while i &gt; 0 &#123;    println!(&quot;&#123;&#125;&quot;, i);    i -= 1;&#125;// forlet arr = [10, 20, 30];for val in arr &#123;    println!(&quot;&#123;&#125;&quot;, val);&#125;\nMatchmatch的用法和if-else很像,但是要注意match要把所有情况包含在内,不然编译阶段就报错\nlet x = 5;match x &#123;    1 | 2 =&gt; println!(&quot;一或二&quot;),    3..=7 =&gt; println!(&quot;三到七之间&quot;), // 范围匹配    _ =&gt; println!(&quot;其他&quot;),&#125;\n函数函数使用基本的函数定义是fn fucnction(a:i32,b:i32) -&gt; i32其中箭头右面的是返回值类型.rust函数表达力非常强\nfn add(a:i32,b:i32)-&gt;i32&#123;    a+b //不加分号，rust会将最后一行作为返回值&#125;fn main() &#123;    let a=1;    let b=3;    let res=add(a,b);    println!(&quot;&#123;&#125;&quot;,res);//println!()是rust的输出函数，其中第一个参数必须是&quot;&quot;包裹的字符串(不能用&#x27;&#x27;替代)，第二个参数是占位符，占位符的值通过&#123;&#125;来传递&#125;\n闭包:闭包可以理解成python里的lambda差不多,相当于匿名函数\nfn main() &#123;    let sum=|a:i32,b:i32|-&gt;i32&#123;a+b&#125;;//这里定义时是用||包裹参数，调用时和正常函数一样    let res=sum(1,2);    println!(&quot;The sum is &#123;&#125;&quot;,res);&#125;\nrust复合类型枚举:简单来说，枚举（enum）就是用来表示“一个值可能属于几种互斥情况之一”，也就是“有限状态或选择”。\n换句话说，它适合表示有多种可能性，但每次只能选一个的场景。\nenum TrafficLight &#123;    Red,    Yellow,    Green,&#125;let light = TrafficLight::Red;match light &#123;    TrafficLight::Red =&gt; println!(&quot;停&quot;),    TrafficLight::Yellow =&gt; println!(&quot;准备&quot;),    TrafficLight::Green =&gt; println!(&quot;走&quot;),&#125;\n结构体基础:结构体和enum不一样的点在于声明结构体时,要把内部变量的类型写出来.而enum就不用\n其中对#[derive(Debug)]的解释:\n\n\n\n\n部分\n含义\n记忆小技巧\n\n\n\n\n#[]\nRust 的 属性（attribute）标记，用来告诉编译器对后面的结构体/枚举做某些处理\n“井号括号 → 给编译器的指令”\n\n\nderive\n自动 派生/生成实现 trait 的代码\n“derive = 自动生成某种功能”\n\n\n(Debug)\n指定生成的 trait 是 Debug\n“Debug = 调试打印能力”\n\n\n\n\n#[derive(Debug)]struct Node&#123;    x: i32,    y: i32&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    println!(&quot;&#123;&#125;&quot;, x);    println!(&quot;&#123;&#125;&quot;, y);    println!(&quot;&#123;:?&#125;&quot;, n); //打印结构体或enum类型，要用&#123;:?&#125;,配合结构体定义上方的#[derive(Debug)]打印结构体&#125;\n结构体进阶:Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 key: value 语法来实现定义：\n实例化时:\n结构体类名 {    字段名 : 字段值,    …}\n(1)在结构体内部用impl关键字实现内联函数:\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn area(x:i32,y:i32)-&gt;i32&#123;        x*y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    let s=Node::area(x, y);    println!(&quot;&#123;&#125;&quot;,s);&#125;\n (2)用结构体中self指针实现\nstruct Node&#123;    x: i32,    y: i32,&#125;// impl Node&#123;//     fn area(x:i32,y:i32)-&gt;i32&#123;//         x*y//     &#125;// &#125;impl Node&#123;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    //let s=Node::area(x, y);    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n(3)结构体实现构造函数\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn new(x:i32,y:i32)-&gt;Self&#123;//默认构造函数名都叫new，但这不是个关键字        Node&#123;            x:x,            y:y        &#125;    &#125;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node::new(1,2);    let x=n.x;    let y=n.y;    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n(4)self的用法:\n\nself 小写 = 当前对象实例指针。\n\nSelf 大写 = 当前类型名。\n\n\nself指针也分为可变和不可变的,可变的要在self前加关键字mut\n#[derive(Debug)]struct Person&#123;    name:String,    age:u32&#125;impl Person&#123;    fn new(name:String,age:u32)-&gt;Self&#123;        Person&#123;name,age&#125;    &#125;    //不可变的this指针    fn greet(&amp;self)-&gt;String&#123;        format!(&quot;Hello,my name is &#123;&#125; and I am &#123;&#125; years old.&quot;,self.name,self.age)    &#125;    //可变的this指针    fn up_age(&amp;mut self)-&gt;u32&#123;        self.age+=1;        self.age    &#125;&#125;fn main() &#123;    let a=Person::new(&quot;原子&quot;.to_string(), 18); //“原子”是静态str.&amp;str类型，要转成可变的String    println!(&quot;&#123;:#?&#125;&quot;,a); //&#123;:#?&#125;是调试格式，和&#123;:?&#125;的区别是，&#123;:#?&#125;会多出缩进，方便阅读    println!(&quot;&#123;&#125;&quot;,a.greet());    let mut b =a;    b.up_age();    println!(&quot;&#123;&#125;&quot;,b.greet());&#125;\n输出:\nPerson &#123;    name: &quot;原子&quot;,    age: 18,&#125;Hello,my name is 原子 and I am 18 years old.Hello,my name is 原子 and I am 19 years old.\nself还有一个不经常用的用法:就是如果传入参数是self(不带&amp;)的话:\nstruct Node &#123;    x: i32,    y: i32,&#125;impl Node &#123;    // 这里的 self 是按值传递，意味着把 Node 本身交给这个方法    fn into_tuple(self) -&gt; (i32, i32) &#123;        (self.x, self.y)    &#125;&#125;fn main() &#123;    let n = Node &#123; x: 1, y: 2 &#125;;    let t = n.into_tuple();  //  这里 n 被 move 走    println!(&quot;&#123;:?&#125;&quot;, t);    // println!(&quot;&#123;:?&#125;&quot;, n.x); //  报错：因为 n 的所有权已经交出，不能再用&#125;\n元组:1.基本定义:元组就是把多个不同类型的值组合在一起的复合类型。语法：\nlet tup: (i32, f64, char) = (500, 6.4, &#x27;a&#x27;);\n2.访问元素\n有两种方式：\n方式一：解构\nlet tup = (500, 6.4, &#x27;a&#x27;);let (x, y, z) = tup;println!(&quot;y 的值是: &#123;&#125;&quot;, y);\n方式二：点语法（下标访问）\n注意第一个元素下标是0\nlet tup = (500, 6.4, &#x27;a&#x27;);println!(&quot;第一个元素是: &#123;&#125;&quot;, tup.0);println!(&quot;第二个元素是: &#123;&#125;&quot;, tup.1);println!(&quot;第三个元素是: &#123;&#125;&quot;, tup.2);\n3.特点:可以包含不同类型的值\n长度固定，不能改变\n4.打印可利用{:?}来打印\n核心机制&amp;数据结构栈和堆存放\n栈 (Stack) 的特点\n\n\n后进先出 (LIFO) 的数据结构，内存分配和释放都非常快。\n\n大小在编译时必须确定。\n\n栈上的数据一般是 固定大小、生命周期明确的值。\n\n\nlet x = 42;       // i32，大小固定 4 字节let y = true;     // bool，1 字节let z = &#x27;a&#x27;;      // char，4 字节let s : &amp;str = &#x27;hello&#x27;  //静态字符串切片,长度固定,在栈上\n\n堆 (Heap) 的特点\n\n\n内存大小运行时才能确定。\n\n需要手动申请（在 Rust 中由所有权系统管理，避免泄漏）。\n\n分配和释放开销比栈大，但适合存放 动态大小或不确定大小的数据。\n\n\n所有权机制堆和栈上数据都有所有权的这个概念,但是栈上数据拷贝时不会move(转移所有权),而是使用copy(复制一个样本),堆会move\n栈上的数据：如果它的类型实现了 Copy trait（比如 i32、bool、char、浮点数、简单元组），那么赋值时不会发生“严格意义上的 move”，而是直接 复制一份值。\n\n所以原变量不会失效，看起来像“转移没事”。\n\n实际上这不是“move”，而是 copy。\nfn main() &#123;    let x = 10;    let y = x;  // Copy，不是 move    println!(&quot;x=&#123;&#125;, y=&#123;&#125;&quot;, x, y); //  x 还能用&#125;\n堆上的数据：比如 String、Vec，它们没实现 Copy，赋值时会发生 move。\n\n所有权转移后，原变量会失效，防止两个变量同时指向同一块堆内存。\n\nfn main() &#123;    let s1 = String::from(&quot;hi&quot;);    let s2 = s1;   // Move    // println!(&quot;&#123;&#125;&quot;, s1); // 报错：s1 已经失效    println!(&quot;&#123;&#125;&quot;, s2);   //  只有 s2 能用了&#125;\n引用和可变引用:引用 (Reference)\n\n引用本质上就是 借用 (borrow)。\n\n借用不会转移所有权，值的所有者依然是原来的变量。\n\n分为：\n不可变引用 (&amp;T)：可以有多个，但不能和可变引用同时存在。\n可变引用 (&amp;mut T)：只能有一个，且不能和不可变引用共存。(可变引用要求被引用的变量是可变的)\n\n\nfn main() &#123;    let a:String =&quot;hello world&quot;.to_string();    let r1=&amp;a; //这里就算拷贝给r1,也能成功输出    println!(&quot;&#123;&#125;&quot;,a);&#125;\nclone的使用:#[derive(Debug,Clone)] //必须结构体里的所有字段都是可拷贝的，才可像正常u32，i32那样使用struct man&#123;    name:String,    age:u32&#125;fn main() &#123;    let a = man&#123;        name:&quot;原子&quot;.to_string(),        age:18    &#125;;    let m=a.clone();    println!(&quot;&#123;:?&#125;&quot;,a);&#125;\nclone就相当于c++中的深拷贝,解决了两个指针指向同一块内存的问题,所以clone之后就可以正常赋值,并接着使用\n生命周期:生命周期用语法 &#39;a 表示：\nfn example&lt;&#x27;a&gt;(s: &amp;&#x27;a str) &#123;    println!(&quot;&#123;&#125;&quot;, s);&#125;\n当结构体里有引用时，必须标注生命周期：\nstruct Person&lt;&#x27;a&gt; &#123;    name: &amp;&#x27;a str,    age: u32,&#125;fn main() &#123;    let name = String::from(&quot;Alice&quot;);    let p = Person &#123; name: &amp;name, age: 20 &#125;; // name 生命周期必须 ≥ p 生命周期&#125;\n生命周期的核心思想:引用永远不能比它指向的数据活得长。\n编译器在编译期检查生命周期，保证安全。\n&#39;a 是标识符，用来关联多个引用的生命周期。\n常用数据结构:String:&amp;str:是String类型的一个切片.长度确定放在栈上.\nString一般长度不确定,放在堆上\n创建:let s1 = String::new();              // 空字符串let s2 = String::from(&quot;hello&quot;);      // 从字面量创建let s3 = &quot;world&quot;.to_string();        // &amp;str 转 String\n添加:let mut s = String::from(&quot;Hello&quot;);s.push(&#x27;!&#x27;);          // 添加单个字符s.push_str(&quot; World&quot;); // 添加字符串切片\n拼接:let s1 = String::from(&quot;Hello&quot;);let s2 = String::from(&quot;World&quot;);// 使用 + 或 format! 宏let s3 = s1 + &amp;s2;           // s1 被移动，s2 被借用let s4 = format!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, &quot;!!!&quot;);  // 不移动任何变量\n获取长度和容量let s = String::from(&quot;hello&quot;);println!(&quot;length: &#123;&#125;&quot;, s.len());    // 字节数println!(&quot;capacity: &#123;&#125;&quot;, s.capacity()); // 堆上分配的容量\n删除内容let mut s = String::from(&quot;Hello World&quot;);s.pop();              // 删除最后一个字符s.clear();            // 清空整个字符串\n索引与切片let s = String::from(&quot;hello&quot;);// let c = s[0]; //  String 不支持直接索引let slice = &amp;s[0..2]; //  切片，返回 &amp;str，必须按字节边界\n查找和替换let s = String::from(&quot;hello world&quot;);println!(&quot;&#123;&#125;&quot;, s.contains(&quot;world&quot;));  // trueprintln!(&quot;&#123;&#125;&quot;, s.find(&quot;world&quot;).unwrap()); // 6，找到索引let new_s = s.replace(&quot;world&quot;, &quot;Rust&quot;);println!(&quot;&#123;&#125;&quot;, new_s); // hello Rust\n分割字符串let s = String::from(&quot;a,b,c&quot;);let v: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();println!(&quot;&#123;:?&#125;&quot;, v); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n遍历let s = String::from(&quot;hello&quot;);// 遍历字符for c in s.chars() &#123;    println!(&quot;&#123;&#125;&quot;, c);&#125;// 遍历字节for b in s.bytes() &#123;    println!(&quot;&#123;&#125;&quot;, b);&#125;\nVector:创建:let mut v: Vec&lt;i32&gt; = Vec::new();   // 空 vectorlet mut v = vec![1, 2, 3];          // 使用宏 vec! 初始化\n添加元素let mut v = Vec::new();v.push(10);   // 尾部插入v.push(20);\n访问元素let v = vec![1, 2, 3, 4];println!(&quot;&#123;&#125;&quot;, v[0]);        // 下标访问 (可能 panic 越界)println!(&quot;&#123;:?&#125;&quot;, v.get(2));  // 安全访问 -&gt; Some(3)println!(&quot;&#123;:?&#125;&quot;, v.get(10)); // None，不会 panic\n修改元素let mut v = vec![10, 20, 30];v[1] = 200;\n删除元素let mut v = vec![1, 2, 3, 4];v.pop();          // 删除最后一个 -&gt; Some(4)v.remove(0);      // 删除指定下标 -&gt; 返回删除的元素 (这里删除 1)\n遍历let v = vec![10, 20, 30];for x in &amp;v &#123;              // 只读遍历    println!(&quot;&#123;&#125;&quot;, x);&#125;for x in &amp;mut v &#123;          // 可修改遍历    *x += 1;&#125;\nHashMap:相当于c++中stl里的map\nuse std::collections::HashMap;fn main() &#123;    // 1. 创建一个 HashMap    let mut scores = HashMap::new();    // 2. 增加（插入）元素    scores.insert(&quot;Alice&quot;, 10);    scores.insert(&quot;Bob&quot;, 20);    // 3. 修改（如果 key 已存在，会覆盖旧值）    scores.insert(&quot;Alice&quot;, 30);  // Alice 的值从 10 -&gt; 30    // 4. 访问（用 get，返回 Option&lt;&amp;V&gt;）    if let Some(score) = scores.get(&quot;Alice&quot;) &#123;        println!(&quot;Alice 的分数是 &#123;&#125;&quot;, score);    &#125;    // 5. 删除（移除某个 key）    scores.remove(&quot;Bob&quot;);    println!(&quot;&#123;:?&#125;&quot;, scores);&#125;\n","categories":["rust逆向基础"],"tags":["rust"]},{"title":"异常处理机制-SEH","url":"/2025/10/09/pe%E9%80%86%E5%90%91/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8A-SEH/","content":"SEH结构化异常处理（SEH）是 C 的Microsoft扩展，C++用于处理某些异常代码情况（如硬件故障）正常。 尽管 Windows 和 Microsoft C++支持 SEH，但我们建议在 C++ 代码中使用 ISO 标准C++异常处理。 它使代码更具可移植性和灵活性。 但是，若要维护现有代码或特定类型的程序，仍可能需要使用 SEH。\n异常出现流程：首先异常被交给内核态 / 最底层**\n当 CPU 检测到一个错误（如无效内存访问），它会中断当前进程，并将控制权交给 Windows 内核。内核会为进程创建一个异常记录（EXCEPTION_RECORD），其中包含异常代码、地址等信息。然后内核会查看进程是否正在被调试。\n\n如果进程被调试：内核将异常事件发送给调试器（第一机会异常）。调试器可以决定处理这个异常（继续执行）或不处理。\n\n如果进程未被调试，或调试器不处理：内核开始在用户态中寻找能处理这个异常的函数。\n\n\n如果异常未能被处理，则在用户态等待被veh处理，若无veh，则交给seh\n如果链式seh，veh未能处理，\n\n当进程中发生异常时,此时会调用系统的kernel32!UnhandledExceptionFIlter()API。\n该API会运行系统的最后一个异常处理器——Top Level Exception Filter或Last Exception Filter（通常行为是弹出错误消息框、终止进程）。\nkernel32!UnhandledExceptionFilter()调用了ntdll!QueryInformationProcess(ProcessDebugPort)。来判断是否正在调试进程。如果正在进行调试，则将异常传递给调试器。否则系统异常处理器终止进程。\n\nSEH结构体typedef struct _EXCEPTION_REGISTRATION_RECORD&#123;    // 链表以Next成员为FFFFFFFF的结构体结束，表示链表的最后一个结点    PEXCEPTION_REGISTRATION_RECORD Next;    // Handler：异常处理函数    PEXCEPTION_DISPOSITION Handler;&#125; EX\nSEH语法try-except-statement ：  __try compound-statement __except ( filter-expression ) compound-statementtry-finally-statement ：  __try compound-statement __finally compound-statement\n正向实例：(a) __try / __except - 异常处理程序#include &lt;windows.h&gt;#include &lt;excpt.h&gt;#include &lt;stdio.h&gt;int main() &#123;    __try &#123;        // 可能会引发异常的代码        int* p = NULL;        *p = 42; // 这将引发一个访问违规异常 (EXCEPTION_ACCESS_VIOLATION)    &#125;    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) &#123;        // 异常过滤器返回 EXCEPTION_EXECUTE_HANDLER 时，执行这个块        printf(&quot;Caught an access violation exception!\\n&quot;);        // 这里可以进行错误恢复、清理、记录日志等操作    &#125;    printf(&quot;Program continues after handling the exception.\\n&quot;);    return 0;&#125;\n\n__try 块：包含可能出错的代码。\n\n__except 块：异常处理程序。它是否能执行取决于其括号内的“异常过滤器表达式”。\n\n异常过滤器表达式：这是一个必须返回以下三个值之一的表达式：\n\nEXCEPTION_EXECUTE_HANDLER (1)： 执行处理程序。系统会展开堆栈（清理 __try 块中已构造的局部 C++ 对象可能会成为问题），然后跳转到 __except 块。\n\nEXCEPTION_CONTINUE_SEARCH (0)： 不处理。系统继续向上一个（外层）的异常处理程序寻找能处理的 __except 块。\n\nEXCEPTION_CONTINUE_EXECUTION (-1)： 继续执行。从异常发生处重新开始执行。极其危险！ 除非你能在过滤器里修复导致异常的问题（如虚拟内存分配），否则通常会立刻再次触发同一个异常，导致死循环。\n\n\n\n\n其中的GetExceptionCode()函数值包含EXCEPTION_ACCESS_VIOLATION, EXCEPTION_INT_DIVIDE_BY_ZERO, EXCEPTION_STACK_OVERFLOW等等，对应不同出错类型\n(b) __try / __finally - 终止处理程序这种结构不处理异常，而是保证无论 __try 块是如何退出的（正常执行完毕、return、goto、break 或由于异常），__finally 块中的代码一定会被执行。用于实现资源清理（如关闭文件、释放锁）。\nHANDLE hFile = INVALID_HANDLE_VALUE;__try &#123;    hFile = CreateFileA(&quot;test.txt&quot;, ...);    if (hFile == INVALID_HANDLE_VALUE) &#123;        __leave; // 跳转到 __finally 块的另一种方式    &#125;    // 对文件进行一些操作，可能会引发异常    SomeRiskyOperation(hFile);&#125;__finally &#123;    // 无论上面如何退出，这里都会执行    if (hFile != INVALID_HANDLE_VALUE) &#123;        CloseHandle(hFile);        hFile = INVALID_HANDLE_VALUE;    &#125;&#125;// 执行完 __finally 后，异常（如果有）会继续向外传播\n逆向实战：注意：32位pe和64位peSEH使用方式不同，注意甄别\n1.32位例题：.text:00401140                 push    ebp.text:00401141                 mov     ebp, esp.text:00401143                 push    0FFFFFFFEh.text:00401145                 push    offset stru_403758.text:0040114A                 push    offset SEH_401140.text:0040114F                 mov     eax, large fs:0.text:00401155                 push    eax\n在使用SEH的函数汇编你会看到这样一段\n第一第二行是创建函数的基本操作，这里不多解释，第三行0xFFFFFFFE叫做Trylevel/enclosing``\n-1 (0xFFFFFFFF) 表示：函数中没有任何 try/except（即编译器没生成 ScopeTable）。\n-2 (0xFFFFFFFE) 表示：函数有 ScopeTable，但当前没有任何激活的 try 块。\n所以翻译过来就是目前这个seh只有一层(还没进入try)，具体进入try的部分见什么修改了Trylevel,如下最后是try结束\n.text:004011B3                 mov     [ebp+ms_exc.registration.TryLevel], 0 //try开始.text:004011BA                 mov     [ebp+var_38], 0.text:004011C1                 mov     eax, [ebp+var_1C].text:004011C4                 mov     edx, [ebp+var_24].text:004011C7                 mov     ecx, [ebp+var_20].text:004011CA                 mov     ebx, [ebp+arg_0].text:004011CD                 div     [ebp+var_38]    //明显除0异常.text:004011D0                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh //try结束\n第4行push offset stru_403758\n\n把指向 .rdata 中 scope table（你之前贴的 stru_403758） 的地址压栈。\n\n这个表包含了 filter/handler 的地址、cookie 偏移等，运行时的异常处理器用它来决定哪个 try/except（或 finally）块应该响应当前异常\n\n\n第5行push offset SEH_401140\n\n把一个“handler 地址”或“该函数专用的异常处理 stub”的地址压栈。IDA 给它取名为 SEH_401140（或许是个局部的 handler/veneer）。\n\n当异常发生并且运行时走到这个注册记录时，系统会调用这个 handler（这个 handler 通常是编译器生成的代码 / 运行时枢纽，它会读取 scope table，调用相应的 filter/handler 函数\n\n\n第6行mov eax, large fs:0\n\n从 fs:[0] 读取当前线程的 SEH 链表头（在 x86 Windows 中，FS 段基址指向 TIB，TIB 的第一个 dword 就是 SEH 链表头）。large 是汇编器的语法，表示读取完整的 32 位值。\n\n把当前链表头（即“之前的注册记录”的指针）读出来保存到 EAX。\n\n\n第7行push eax\n\n把旧的 fs:[0]（即之前的链表头）压栈 —— 这就是新注册记录的 Next 字段（保存链表的前驱，以便函数退出时能恢复）。\n\n在压栈/设置 fs:[0] 后，新的记录就会被插到链表最前面，变成当前活动的异常注册记录。\n\n\n退出函数时解除seh\nloc_401268:    mov     ecx, [ebp+ms_exc.registration.Next]    mov     large fs:0, ecx        ; 恢复 fs:[0] = 上一个 SEH 节点    pop     ecx    pop     edi    pop     esi    pop     ebx    mov     esp, ebp    pop     ebp    retn\n总结逆向流程：我们需要在stru_403758找到相应的过滤函数，和处理异常函数，该题中\n                stru_403758     dd 0FFFFFFFEh           ; GSCookieOffset.rdata:00403758                                         ; DATA XREF: sub_401140+5↑o.rdata:0040375C                 dd 0                    ; GSCookieXOROffset.rdata:00403760                 dd 0FFFFFFB0h           ; EHCookieOffset.rdata:00403764                 dd 0                    ; EHCookieXOROffset.rdata:00403768                 dd 0FFFFFFFEh           ; ScopeRecord.EnclosingLevel.rdata:0040376C                 dd offset loc_4011D9    ; ScopeRecord.FilterFunc.rdata:00403770                 dd offset loc_4011DF    ; ScopeRecord.HandlerFunc\n前3个没什么用，第四个是我们上面的Trylevel，第5个是过滤函数，第6个是我们的处理函数，也就是ctf中反调试替换掉的逻辑\n               loc_4011D9:                             ; DATA XREF: .rdata:stru_403758↓o.text:004011D9                 mov     eax, 1.text:004011DE                 retn.text:004011DF ; ---------------------------------------------------------------------------.text:004011DF.text:004011DF loc_4011DF:                             ; DATA XREF: .rdata:stru_403758↓o.text:004011DF                 mov     esp, [ebp+ms_exc.old_esp].text:004011E2                 mov     edi, [ebp+var_24].text:004011E5                 mov     ecx, edi.text:004011E7                 shr     ecx, 4.text:004011EA                 mov     eax, edi.text:004011EC                 shl     eax, 5.text:004011EF                 xor     ecx, eax.text:004011F1                 add     ecx, edi.text:004011F3                 mov     eax, [ebp+arg_0].text:004011F6                 mov     eax, [eax].text:004011F8                 add     eax, [ebp+var_20].text:004011FB                 xor     ecx, eax.text:004011FD                 xor     [ebp+var_1C], ecx.text:00401200                 push    offset Buffer   ; &quot;Something happend...&quot;.text:00401205                 call    ds:puts.text:0040120B                 add     esp, 4.text:0040120E                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh.text:00401215                 mov     esi, [ebp+var_28]\n这里过滤函数返回值保存在eax中，这里也就是返回了1，说明EXCEPTION_EXECUTE_HANDLER要处理这个异常，把原函数逻辑替换为下面的处理函数然后就可以接着进行逆向分析了，try中遇到error，那条出错指令汇编跳过，执行exception指令，然后执行try{}下面的语句。\n","categories":["pe逆向","反调试技术"],"tags":["反调试技术"]},{"title":"异常处理机制-VEH","url":"/2025/10/09/pe%E9%80%86%E5%90%91/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8B-VEH/","content":"VEH这是 SEH 的一个增强扩展，通过 AddVectoredExceptionHandler 添加。VEH 处理器会在调试器和所有 SEH 处理器之前被调用。它们更像是一种“通知”机制，可以观察或拦截进程中的所有异常。\n与veh有关的函数\n\n\n\n函数名\n作用\n参数解释\n\n\n\n\nAddVectoredExceptionHandler\n注册一个新的向量化异常处理函数（VEH）。注册后，当线程出现异常（例如访问违规、除零、RaiseException）时，系统会回调你提供的函数。\nULONG FirstHandler：是否把此 handler 放在最前面。 1 → 高优先级（最先被调用） 0 → 低优先级（放在队列后面）PVECTORED_EXCEPTION_HANDLER VectoredHandler：回调函数地址，函数类型为 LONG CALLBACK handler(EXCEPTION_POINTERS* ExceptionInfo)。返回值控制异常是否继续传播。\n\n\nRemoveVectoredExceptionHandler\n移除已注册的 VEH。\nPVOID HandlerHandle：AddVectoredExceptionHandler 返回的句柄。\n\n\nRaiseException\n主动抛出一个软件异常，会触发 VEH。\nDWORD dwExceptionCode：异常码（自定义或系统定义）。DWORD dwExceptionFlags：是否可继续执行。0 表示可继续，EXCEPTION_NONCONTINUABLE 表示不可继续。DWORD nNumberOfArguments：额外参数个数。*_const ULONG_PTR _lpArguments__：异常参数数组（可选）。\n\n\nEXCEPTION_POINTERS\nVEH 的回调参数结构，包含异常上下文。\n成员有两个：ExceptionRecord：描述异常的详细信息（代码、参数、地址等）。ContextRecord：保存异常发生时 CPU 的寄存器状态（Rip/Eip, Rsp/Esp, Rax, Rcx…）。可读写！修改后返回 EXCEPTION_CONTINUE_EXECUTION 可以改变执行流。\n\n\n\n\n正向实例：// veh_demo.cpp#include &lt;windows.h&gt;#include &lt;iostream&gt;using namespace std;// ======================= 1. 被“隐藏”的函数 =======================void SecretFunc()&#123;    cout &lt;&lt; &quot;[SecretFunc] VEH 修改 RIP 后跳转到这里执行！&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！&quot; &lt;&lt; endl;    ExitProcess(0);&#125;// ======================= 2. VEH 回调函数 =======================LONG CALLBACK MyVectoredHandler(EXCEPTION_POINTERS* ExceptionInfo)&#123;    cout &lt;&lt; &quot;[VEH] 异常捕获！&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;  ExceptionCode: 0x&quot; &lt;&lt; hex &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode &lt;&lt; endl;    cout &lt;&lt; &quot;  ExceptionAddress: &quot; &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress &lt;&lt; endl;    // 判断是不是我们自己触发的异常（0xDEADC0DE）    if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == 0xDEADC0DE)    &#123;        cout &lt;&lt; &quot;[VEH] 捕获到自定义异常，修改上下文...&quot; &lt;&lt; endl;#ifdef _M_X64        ExceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)&amp;SecretFunc; // x64#else        ExceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;SecretFunc;   // x86#endif        // 返回 EXCEPTION_CONTINUE_EXECUTION，让程序从修改后的地址继续执行        return EXCEPTION_CONTINUE_EXECUTION;    &#125;    // 其他异常交给系统处理    return EXCEPTION_CONTINUE_SEARCH;&#125;// ======================= 3. 主函数 =======================int main()&#123;    cout &lt;&lt; &quot;[Main] 注册 VEH...&quot; &lt;&lt; endl;    // 注册 VEH，优先级高    PVOID hHandler = AddVectoredExceptionHandler(1, MyVectoredHandler);    if (!hHandler)    &#123;        cerr &lt;&lt; &quot;AddVectoredExceptionHandler failed! error=&quot; &lt;&lt; GetLastError() &lt;&lt; endl;        return 1;    &#125;    cout &lt;&lt; &quot;[Main] 准备触发自定义异常...&quot; &lt;&lt; endl;    // 手动触发异常    RaiseException(0xDEADC0DE, 0, 0, nullptr);    cout &lt;&lt; &quot;[Main] 如果看到这行，说明 VEH 没有拦截执行流。&quot; &lt;&lt; endl;    // 移除 VEH    RemoveVectoredExceptionHandler(hHandler);    return 0;&#125;\n输出：\n[Main] 注册 VEH...[Main] 准备触发自定义异常...[VEH] 异常捕获！  ExceptionCode: 0xdeadc0de  ExceptionAddress: 00007FF6F8B21000[VEH] 捕获到自定义异常，修改上下文...[SecretFunc] VEH 修改 RIP 后跳转到这里执行！[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！\n总结：\n\n\n\n函数\n用途\n常用返回\n\n\n\n\nAddVectoredExceptionHandler\n注册 VEH\n返回 handler 句柄\n\n\nRemoveVectoredExceptionHandler\n移除 VEH\n成功返回非 0\n\n\nRaiseException\n主动抛出异常\n会调用 VEH\n\n\nMyVectoredHandler\n回调处理异常\n返回 CONTINUE_EXECUTION 或 CONTINUE_SEARCH\n\n\nExceptionInfo-&gt;ContextRecord\n保存寄存器上下文\n可修改以改变执行流\n\n\n\n\n","categories":["pe逆向","反调试技术"],"tags":["反调试技术"]},{"title":"pe中的hook实现","url":"/2025/10/09/pe%E9%80%86%E5%90%91/pe_hook/","content":"前言：pe中的hook技术是指通过 DLL 注入（例如 CreateRemoteThread 注入、SetWindowsHookEx、frida-gadget 等实现方式）将代码注入目标进程，替换目标exe文件中的某个函数为自己的函数，而在这过程中我们没办法获得目标exe源码，只能用另一个进程去操作目标进程。本篇记录了IAT HOOK和inline hook。在日常生活中hook更多还是用frida的插桩技术实现（封装好了），不过底层hook的机制还是要了解，因为frida一旦被全方位检测拦截就没招了\n注意：代码来自文末链接，但他讲的有问题，我把正确的代码改进后放在我的文章了\nIAT hook原理：\n进程运行时IAT表里存储了我们函数的真实地址rva，我们如果用注入的dll更改IAT里的地址为我们dll里实现的函数地址，就实现了hook。相当于elf文件中的got表劫持 \n头文件：\n#pragma once#include &lt;Windows.h&gt;void* g_IATaddr = NULL;                // 指向 IAT 条目（存放函数指针的内存地址）void* g_originalMessageBoxW = NULL;    // 保存原始 MessageBoxW 的函数地址BOOL installhook(); // 安装钩子BOOL uninstallhook(); // 卸载钩子DWORD* getIATaddr(const char* dllname, const char* funcname, WORD ordinal); // 获取IAT地址\n#include &quot;mydll.h&quot;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include&lt;string.h&gt;int WINAPI hookMessageboxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)&#123;    MessageBoxA(NULL, &quot;Hooked!&quot;, &quot;Hooked&quot;, MB_OK);    // 如果需要调用原函数，可以在这里调用    return 0;&#125;DWORD* getIATaddr(const char* dllname, const char* funcname, WORD ordinal)&#123;    HMODULE hModule = GetModuleHandle(0);    if (hModule == NULL)    &#123;        printf(&quot;GetModuleHandle failed\\n&quot;);        return 0;    &#125;    printf(&quot;GetModuleHandle success\\n&quot;);    DWORD dwmodule = (DWORD)hModule;    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwmodule;    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(dwmodule + pDosHeader-&gt;e_lfanew);    PIMAGE_OPTIONAL_HEADER pOptionalHeader = &amp;pNtHeader-&gt;OptionalHeader;    PIMAGE_IMPORT_DESCRIPTOR pImageImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(        pOptionalHeader-&gt;DataDirectory[1].VirtualAddress + dwmodule);    while (pImageImportTable-&gt;Name)    &#123;        char* iatDllName = (char*)(pImageImportTable-&gt;Name + dwmodule);        if (_stricmp(iatDllName, dllname) == 0)        &#123;            PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)(pImageImportTable-&gt;OriginalFirstThunk + dwmodule);            PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(pImageImportTable-&gt;FirstThunk + dwmodule);            while (pINT-&gt;u1.Function)            &#123;                if (pINT-&gt;u1.Ordinal &amp; 0x80000000)                &#123;                    WORD importOrdinal = (WORD)(pINT-&gt;u1.Ordinal &amp; 0xFFFF);                    if (importOrdinal == ordinal)                    &#123;                        return (DWORD*)pIAT;                    &#125;                &#125;                else                &#123;                    PIMAGE_IMPORT_BY_NAME pIBN = (PIMAGE_IMPORT_BY_NAME)(pINT-&gt;u1.AddressOfData + dwmodule);                    // 字符串内容比较                    if (strcmp((char*)pIBN-&gt;Name, funcname) == 0)                    &#123;                        return (DWORD*)pIAT;                    &#125;                &#125;                pINT++;                pIAT++;            &#125;        &#125;        pImageImportTable++; // 遍历下一个 DLL    &#125;    return 0;&#125;BOOL installhook()&#123;    if (!g_IATaddr) return FALSE;    SIZE_T ptrSize = sizeof(void*);    DWORD oldProtect;    if (!VirtualProtect(g_IATaddr, ptrSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) &#123;        OutputDebugStringA(&quot;installhook: VirtualProtect failed\\n&quot;);        return FALSE;    &#125;    // 从 IAT 条目读取并保存原始函数指针    g_originalMessageBoxW = *(void**)g_IATaddr;    // 写入 hook 函数地址（按指针宽度写入）    *(void**)g_IATaddr = (void*)hookMessageboxW;    // 恢复保护    VirtualProtect(g_IATaddr, ptrSize, oldProtect, &amp;oldProtect);    return TRUE;&#125;BOOL uninstallhook()&#123;    if (!g_IATaddr) return FALSE;    SIZE_T ptrSize = sizeof(void*);    DWORD oldProtect;    if (!VirtualProtect(g_IATaddr, ptrSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) &#123;        OutputDebugStringA(&quot;uninstallhook: VirtualProtect failed\\n&quot;);        return FALSE;    &#125;    // 恢复原始函数地址（若已保存）    if (g_originalMessageBoxW) &#123;        *(void**)g_IATaddr = g_originalMessageBoxW;    &#125;    VirtualProtect(g_IATaddr, ptrSize, oldProtect, &amp;oldProtect);    return TRUE;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    if (fdwReason == DLL_PROCESS_ATTACH)    &#123;        DisableThreadLibraryCalls(hinstDLL); // 建议保留        OutputDebugStringA(&quot;DLL_PROCESS_ATTACH\\n&quot;);        g_IATaddr = getIATaddr(&quot;user32.dll&quot;, &quot;MessageBoxW&quot;, 0);        if (g_IATaddr) &#123;            if (!installhook()) &#123;                OutputDebugStringA(&quot;DllMain: installhook failed\\n&quot;);            &#125;            else &#123;                OutputDebugStringA(&quot;DllMain: hook installed\\n&quot;);            &#125;        &#125;        else &#123;            OutputDebugStringA(&quot;DllMain: getIATaddr returned NULL\\n&quot;);        &#125;    &#125;    else if (fdwReason == DLL_PROCESS_DETACH)    &#123;        OutputDebugStringA(&quot;DLL_PROCESS_DETACH\\n&quot;);        uninstallhook();    &#125;    return TRUE;&#125;\n我们可以随便写个主进程函数，然后把这个dll文件注入看能否hook成功。注入dll的方式有很多，可以看我注入dll的那篇。当然最简单是用github上别人造好的轮子来搞dll注入。这里放一个我觉得还不错的项目GitHub - Joe1sn/S-inject: 支持x86/x64的DLL和Shellcode 的Windows注入的免杀工具，支持图形化界面\n主进程函数：\n// main.c#include &lt;windows.h&gt;#define ID_BTN_SHOW 1001// 窗口过程LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123;    switch (msg)    &#123;    case WM_CREATE:        // 在窗口上创建一个按钮        CreateWindowW(L&quot;BUTTON&quot;, L&quot;点击我弹窗&quot;,                      WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,                      20, 20, 150, 30,                      hwnd, (HMENU)ID_BTN_SHOW, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), NULL);        return 0;    case WM_COMMAND:        if (LOWORD(wParam) == ID_BTN_SHOW &amp;&amp; HIWORD(wParam) == BN_CLICKED) &#123;            // 按钮被点击 — 弹窗            MessageBoxW(hwnd, L&quot;Hello World&quot;, L&quot;Hello&quot;, MB_OK | MB_ICONINFORMATION);        &#125;        return 0;    case WM_DESTROY:        PostQuitMessage(0);        return 0;    &#125;    return DefWindowProcW(hwnd, msg, wParam, lParam);&#125;// 程序入口（GUI 程序使用 WinMain）int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123;    const wchar_t CLASS_NAME[] = L&quot;SampleWindowClass&quot;;    WNDCLASSW wc = &#123; 0 &#125;;    wc.lpfnWndProc = WndProc;    wc.hInstance = hInstance;    wc.lpszClassName = CLASS_NAME;    wc.hCursor = LoadCursor(NULL, IDC_ARROW);    if (!RegisterClassW(&amp;wc)) &#123;        MessageBoxW(NULL, L&quot;RegisterClass failed&quot;, L&quot;Error&quot;, MB_OK | MB_ICONERROR);        return 0;    &#125;    HWND hwnd = CreateWindowExW(        0,        CLASS_NAME,        L&quot;示例 - 点击按钮弹窗&quot;,        WS_OVERLAPPEDWINDOW,        CW_USEDEFAULT, CW_USEDEFAULT, 300, 150,        NULL,        NULL,        hInstance,        NULL    );    if (!hwnd) &#123;        MessageBoxW(NULL, L&quot;CreateWindow failed&quot;, L&quot;Error&quot;, MB_OK | MB_ICONERROR);        return 0;    &#125;    ShowWindow(hwnd, nShowCmd);    UpdateWindow(hwnd);    // 消息循环    MSG msg;    while (GetMessage(&amp;msg, NULL, 0, 0)) &#123;        TranslateMessage(&amp;msg);        DispatchMessage(&amp;msg);    &#125;    return (int)msg.wParam;&#125;\n在x64复现成功了，上面代码兼容x86，如果想hookx86程序要在编译时编译成x86dll。我把复现过程的问题列下面：\n可能出现问题1：int WINAPI hookMessageboxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)&#123;    MessageBoxA(NULL, &quot;Hooked!&quot;, &quot;Hooked&quot;, MB_OK);    // 如果需要调用原函数，可以在这里调用    return 0;&#125;\n\n这里面hook时用的MessageBoxW，会导致循环调用，会卡死\n\n定义hookMessageboxW时没加WINAPI ，这会导致调用约定不一致，会报错\n\n\n可能出现问题2：不要用他视频里的DWORD来一味声明，不然64位系统里地址是64位，会被截断导致地址错误\n可能出现问题3：if (strcmp((char*)pIBN-&gt;Name, funcname) == 0)&#123;    return (DWORD*)pIAT;&#125;\n症状：函数查找失败（总找不到目标函数）。原因：pIBN-&gt;Name == funcname 比较的是地址而非内容。修复：用 _stricmp((char*)pIBN-&gt;Name, funcname) 或 strcmp（按是否区分大小写）。\ninline hook上面的IAT表有个问题，就是不在导入表里的函数你没办法hook啊，所以inline hook就是用来解决这个问题的。\n\n原理：\n\n直接修改目标函数的前几条机器指令（通常是函数入口），替换成跳转指令（如 b  或 ldr pc, [addr]）；\n\n优点：\n\n可以 Hook 几乎任意函数（导出或非导出、静态或动态）\n精细控制，适合保护/加壳/代码注入等底层用途\n\n缺点：\n\n对 CPU 架构高度依赖（ARM64、ARMv7）\n对汇编、内存保护、缓存等有要求（必须关闭写保护）\n稳定性较低，不当使用可能 crash\n代码：\nmain.h\n#pragma once#include&lt;iostream&gt;#include&lt;Windows.h&gt;int WINAPI MyMessageBoxW(    _In_opt_ HWND hWnd,    _In_opt_ LPCWSTR lpText,    _In_opt_ LPCWSTR lpCaption,    _In_ UINT uType);BOOL InstallHook();BOOL UnInstallHook();\nmain.cpp\n#include &quot;mydll.h&quot;#include &lt;Windows.h&gt;#include &lt;stdint.h&gt;uintptr_t g_unhookfun = 0;BYTE g_oldcode[16] = &#123; 0 &#125;; // 保存原函数前16个字节BYTE g_newcode[16] = &#123; 0 &#125;; // hook 指令占用前12字节，剩余用 NOP 填充// 思路：// 1、找到我们要HOOK函数地址// 2、保存要HOOK的函数的前16个字节// 3、构建 mov rax, imm64; jmp rax （12字节）指令写入目标函数前// 4、安装/卸载时写回/恢复这16字节int WINAPI MyMessageBoxW(    HWND hWnd,    LPCWSTR lpText,    LPCWSTR lpCaption,    UINT uType)&#123;    UnInstallHook();    int result = MessageBoxW(hWnd, L&quot;51HOOK&quot;, lpCaption, uType);    InstallHook();    return result;&#125;// 构建 mov rax, imm64; jmp rax （12 字节）static void BuildMovRaxJmp(BYTE* buf, uintptr_t target)&#123;    buf[0] = 0x48; buf[1] = 0xB8; // mov rax, imm64    memcpy(buf + 2, &amp;target, 8);  // imm64 (little endian)    buf[10] = 0xFF; buf[11] = 0xE0; // jmp rax&#125;// 安装钩子BOOL InstallHook()&#123;    DWORD oldProtect = 0;    if (g_unhookfun == 0)    &#123;        return FALSE;    &#125;    // 改写前12字节为 mov rax, imm64; jmp rax    BuildMovRaxJmp(g_newcode, (uintptr_t)MyMessageBoxW);    // 把剩下的字节用 NOP 填充（保证覆盖 16 字节）    for (int i = 12; i &lt; 16; ++i) g_newcode[i] = 0x90;    if (!VirtualProtect((LPVOID)g_unhookfun, sizeof(g_newcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect)) return FALSE;    memcpy((void*)g_unhookfun, g_newcode, sizeof(g_newcode));    VirtualProtect((LPVOID)g_unhookfun, sizeof(g_newcode), oldProtect, &amp;oldProtect);    FlushInstructionCache(GetCurrentProcess(), (LPCVOID)g_unhookfun, sizeof(g_newcode));    return TRUE;&#125;// 卸载钩子BOOL UnInstallHook()&#123;    DWORD oldProtect = 0;    if (g_unhookfun == 0)    &#123;        return FALSE;    &#125;    if (!VirtualProtect((LPVOID)g_unhookfun, sizeof(g_oldcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect)) return FALSE;    memcpy((void*)g_unhookfun, g_oldcode, sizeof(g_oldcode));    VirtualProtect((LPVOID)g_unhookfun, sizeof(g_oldcode), oldProtect, &amp;oldProtect);    FlushInstructionCache(GetCurrentProcess(), (LPCVOID)g_unhookfun, sizeof(g_oldcode));    return TRUE;&#125;// 初始化函数BOOL InitHook()&#123;    // 找到要Hook函数的地址    HMODULE hModule = LoadLibraryA(&quot;user32.dll&quot;);    if (hModule == 0)    &#123;        return FALSE;    &#125;    g_unhookfun = (uintptr_t)GetProcAddress(hModule, &quot;MessageBoxW&quot;);    // 保存函数的前16个字节（旧函数的前若干字节）    memcpy(g_oldcode, (void*)g_unhookfun, sizeof(g_oldcode));    // 构建 hook 指令到 g_newcode（在 InstallHook 会写入）    BuildMovRaxJmp(g_newcode, (uintptr_t)MyMessageBoxW);    for (int i = 12; i &lt; 16; ++i) g_newcode[i] = 0x90; // NOP 填充    return TRUE;&#125;BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD callReason, LPVOID lpReserved)&#123;    if (callReason == DLL_PROCESS_ATTACH)    &#123;        InitHook();        InstallHook();    &#125;    else if (callReason == DLL_PROCESS_DETACH)    &#123;        UnInstallHook();    &#125;    return TRUE;&#125;\n我是在x64程序上复现的，关键在于对jmp指令的处理，x86版本要稍作修改，按视频里的来\nReference：【【保姆级教程】16 节吃透 Windows PE 文件格式！从解析到 Hook 攻防全覆盖】https://www.bilibili.com/video/BV1cXT4z7Etf?p=8&amp;vd_source=ef1be23ebedc3f547905767af45d9f93\n","categories":["pe逆向","pe逆向基础"],"tags":["pe_hook"]},{"title":"vm逆向基础及做题套路","url":"/2025/10/06/vm%E9%80%86%E5%90%91/vm%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/","content":"前言：学过计算机组成原理的应该都知道，程序的运行是靠cpu解释可执行文件中操作码来实现的功能，vm逆向顾名思义就是自己定义了小型cpu并定义了指令集，将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。\nvm逆向基本原理：vm_init：虚拟机的入口函数，对虚拟机环境进行初始化，初始化一般包括\n\n寄存器初始化(eax,ebx,ecx,edx,eip)\n\n把handle函数和操作码连接在一起\n\n给虚拟机的栈空间vm_stack分配内存\n\n\nvm_run:虚拟机开始运行的地方\nvm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。\nvm_handle:处理器，当rip走到对应操作码时调用对应操作函数，并接受操作数。\nopcode :程序可执行代码转换成的操作码\n在这种情况下，如果要逆向程序，就需要对整个emulator结构进行逆向，理解程序功能，还需要结合opcode进行分析，整个程序逆向工程将会十分繁琐。这是一个一般虚拟机结构：\nvm_lables:有的虚拟机涉及lable的创造和调用，起到跳转目的\n分析方法在比赛中，虚拟机题目常常有两种考法：\n\n给可执行程序和opcode，逆向emulator，结合opcode文件，推出flag\n\n只给可执行程序，逆向emulator，构造opcode，读取flag\n\n\n拿到一个虚拟机之后，一般有以下几个逆向过程：\n\n分析虚拟机入口，搞清虚拟机的输入，或者opcode位置\n\n理清虚拟机结构，包括Dispatcher和各个Handler\n\n逆向各个Handler，分析opcode的意义\n\n根据opcode运行时打印出对应汇编代码，根据汇编代码逻辑进行逆向\n\n\n一个简单vm虚拟机实例：vm_cpu结构体typedef struct&#123;    unsigned long r1;    //虚拟寄存器r1    unsigned long r2;    //虚拟寄存器r2    unsigned long r3;    //虚拟寄存器r3    unsigned char *eip;    //指向正在解释的opcode地址    vm_opcode op_list[OPCODE_N];    //opcode列表，存放了所有的opcode及其对应的处理函数&#125;vm_cpu;\nvm_opcode结构体typedef struct&#123;    unsigned char opcode;    void (*handle)(void*);&#125;vm_opcode;\nvm_init()void *vm_init()&#123;    vm_vpu *cpu;    cpu-&gt;r1 = 0;    cpu-&gt;r2 = 0;    cpu-&gt;r3 = 0;    cpu-&gt;eip = (unsigned char *)vm_code;//将eip指向opcode的地址    cpu-&gt;op_list[0].opcode = 0x1;    cpu-&gt;op_list[0].handle = (void (*)(void *))mov;//将操作字节码与对应的handle函数关联在一起    cpu-&gt;op_list[1].opcode = 0xf2;    cpu-&gt;op_list[1].handle = (void (*)(void *))xor;    cpu-&gt;op_list[2].opcode = 0xf5;    cpu-&gt;op_list[2].handle = (void (*)(void *))read_;    vm_stack = malloc(0x512);    memset(vm_stack,0,0x512);&#125;\nhandles(示例)void mov(vm_cpu *cpu);void xor(vm_cpu *cpu);    //xor flagvoid read_(vm_cpu *cpu);    //call read, read the flagvoid xor(vm_cpu *cpu)&#123;    int temp;    temp = cpu-&gt;r1 ^ cpu-&gt;r2;    temp ^= 0x12;    cpu-&gt;r1 = temp;    cpu-&gt;eip += 1;    //xor指令占一个字节&#125;void read_(vm_cpu *cpu)&#123;    char *dest = vm_stack;    read(0,dest,12);    //用于往虚拟机的栈上读取数据    cpu-&gt;eip += 1;    //read_指令占一个字节&#125;void mov(vm_cpu *cpu)&#123;    //mov指令的参数都因曾在字节码也就是vm_code中，指令表示后的一个字节是寄存器表示，第二到//第五是要mov的数据在vm_stack上的偏移    //这里只是实现了从vm_stack上取数据和存数据到vm_stack上    unsigned char *res = cpu-&gt;eip + 1;    //寄存器标识    int *offset = (int *)(cpu-&gt;eip + 2);    //寄存器在vm_stack上的偏移    char *dest = 0;    dest = vm_stack;    switch (*res) &#123;        case 0xe1:            cpu-&gt;r1 = *(dest + *offset);            break;           case 0xe2:            cpu-&gt;r2 = *(dest + *offset);            break;           case 0xe3:            cpu-&gt;r3 = *(dest + *offset);            break;           case 0xe4:        &#123;            int x = cpu-&gt;r1;            *(dest + *offset) = x;            break;        &#125;    &#125;       cpu-&gt;eip += 6;    //mov指令占六个字节，所以eip要向后移6位&#125;\nvm_code​unsigned char vm_code[] = &#123;    0xf5,    0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00,    0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00,    0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00,    0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00,    0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00,    0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00,    0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00,    0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00,    0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00,    0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00,    0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00,    0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00,    0xf4&#125;;​\nvm_stack一般是一个全局数组，用于存放虚拟机的栈\nvm_stack = malloc(0x512);memset(vm_stack,0,0x512);\nvm_runvoid vm_run(vm_cpu *cpu)&#123;    /*    进入虚拟机    eip指向要被解释的opcode地址    */    cpu-&gt;eip = (unsigned char*)opcodes;    while((*cpu-&gt;eip) != 0xf4)//如果opcode不为RET，就调用vm_dispatcher来解释执行    &#123;        vm_dispatcher(*cpu-&gt;eip)    &#125;&#125;\nvm_dispatchervoid vm_dispatcher(vm_cpu *cpu)&#123;    int i;    for(i = 0; i &lt; OPCODE_N; i++)    &#123;            if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode)        &#123;            cpu-&gt;op_list[i].handle(cpu);            break;        &#125;    &#125;&#125;\n做题流程：\n先根据上面的特征静态分析判断函数是vm中的哪一部分，如果静态分析困难，那就动调一下\n\n找到对应部分后创建上述结构体来帮助分析\n\n自己把vm还原在vscode里，并在dispatcher部分加上打印这条指令的代码，有的时候也可以打印stack，和当前执行完指令的内存状态(各个变量的值)\n\n根据打印出的汇编指令，手动逆向\n\n\n具体使用方法还需在实战中不断练习，具体做题流程可看我的vm题单真题\n参考文献：虚拟机逆向与实现-CSDN博客\n虚拟机保护逆向入门 - FreeBuf网络安全行业门户\n","categories":["vm逆向题单"],"tags":["vm逆向"]},{"title":"[GWCTF 2019] babyvm","url":"/2025/10/07/vm%E9%80%86%E5%90%91/%5BGWCTF%202019%5Dbabyvm/","content":"前言：这道题算非常经典的vm题了，用这道题来熟悉一下vm题基本流程\n正文：创建结构体：\n有三个函数我们点进去看一下具体逻辑\n\n第一个函数很明显就是vm_init的结构，我们改名为vm_init,并创建结构体帮助静态分析\n\n在空白部分右键，添加结构体\n\n结构体名就叫vm_cpu，下面按d键快捷键给它增加成员变量\n光标对准vm_cpu struc点一次d是在最前面增加成员变量\n对准field_0点一次d是更改一次field_0的类型,也可按y直接输入类型\n对准vm_cpu ends点一次d是在末尾增加成员变量\n\n接下来修改成员变量的名称按n快捷键，改为eax，ebx等\n由于vm_cpu中有个数组叫oplist[]\n我们先创建新结构体\nstruct opcode&#123;    QWORD _opcode;    QWORD handle;&#125;;\n这里稍微再提一下怎么确定每个成员变量占多少字节，不要看ida给你强转出来的类型，而要看上下成员之间的差值，比如(_BYTE )(a1 + 24) = -15;和(_QWORD )(a1 + 32) = sub_B5F;从a1+24到a1+32，占了8个字节。所以这里_opcode类型是qword。下面是全部改完之后的结构体\n\n再回到第一个函数，对准函数参数列表按y，把a1类型改为vm_cpu*，然后函数就变得美观了，下面的qword_2022A8是给vm设置的栈空间，我们也可以改名vm_stack\n\n第二个函数很容易看出来是vm_run,分发器控制程序执行，第三个函数是验证flag正确与否，就不展开讲了\n第二个函数把参数也改成vm_cpu*\nunsigned __int64 __fastcall vm_run(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_rip = (__int64)&amp;unk_202060;  while ( *(_BYTE *)a1-&gt;vm_rip != 0xF4 )    sub_E6E(a1);  return __readfsqword(0x28u) ^ v2;&#125;\n我们看到逻辑已经很明确了，就是rip指向的地址对应的值不等于0xf4时，一直调用sub_E6E\nunsigned __int64 __fastcall sub_E6E(vm_cpu *a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; *(_BYTE *)a1-&gt;vm_rip != LOBYTE(a1-&gt;oplist[i]._opcode); ++i )    ;  ((void (__fastcall *)(vm_cpu *))a1-&gt;oplist[i].handle)(a1);  return __readfsqword(0x28u) ^ v3;&#125;\nsub_E6E点进去就发现和我们的vm基础里的dispatcher结构一模一样，现在我们回头处理一下没命名的handle函数就可以正式逆向了\n识别函数：1.mov函数unsigned __int64 __fastcall sub_B5F(vm_cpu *a1)&#123;  int *v2; // [rsp+28h] [rbp-18h]  unsigned __int64 v3; // [rsp+38h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = (int *)(a1-&gt;vm_rip + 2);  switch ( *(_BYTE *)(a1-&gt;vm_rip + 1) )  &#123;    case 0xE1:      a1-&gt;vm_eax = *((char *)vm_stack + *v2);      break;    case 0xE2:      a1-&gt;vm_ebx = *((char *)vm_stack + *v2);      break;    case 0xE3:      a1-&gt;vm_ecx = *((char *)vm_stack + *v2);      break;    case 0xE4:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_eax;      break;    case 0xE5:      a1-&gt;vm_edx = *((char *)vm_stack + *v2);      break;    case 0xE7:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_ebx;      break;    default:      break;  &#125;  a1-&gt;vm_rip += 6LL;  return __readfsqword(0x28u) ^ v3;&#125;\n这个函数的意思是，v2是栈中偏移，相当于ss:[ebp+v2]=vm_stack[v2],当操作码=-15也就是0xF1的时候，调用这个函数，下一个地址的数(_BYTE )(a1-&gt;vm_rip+1))就是选择码，(_BYTE )(a1-&gt;vm_rip+2))就是操作数\n\n选择码=0xE1 执行mov eax ss:[ebp+v2]\n\n选择码=0xE2 执行mov ebx ss:[ebp+v2]\n\n选择码=0xE3 执行mov ecx ss:[ebp+v2]\n\n选择码=0xE4 执行mov ss:[ebp+v2] eax \n\n选择码=0xE5 执行mov edx ss:[ebp+v2]\n\n选择码=0xE7 执行mov ss:[ebp+v2] ebx \n\n\n2.xorunsigned __int64 __fastcall sub_A64(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax ^= a1-&gt;vm_ebx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n相当于xor eax ebx\n3.readunsigned __int64 __fastcall sub_AC5(vm_cpu *a1)&#123;  const char *buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  buf = (const char *)vm_stack;  read(0, vm_stack, 0x20uLL);  dword_2022A4 = strlen(buf);  if ( dword_2022A4 != 21 )  &#123;    puts(&quot;WRONG!&quot;);    exit(0);  &#125;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\n把flag读入栈上\n相当于call read,并判断flag长度\n4.nopunsigned __int64 __fastcall sub_956(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n什么都没干，rip只是加1，这是所有指令都要有的\n5.mulunsigned __int64 __fastcall sub_A08(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax *= a1-&gt;vm_edx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\nmul eax edx\n6.xchgunsigned __int64 __fastcall sub_8F0(vm_cpu *a1)&#123;  int vm_eax; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  vm_eax = a1-&gt;vm_eax;  a1-&gt;vm_eax = a1-&gt;vm_ebx;  a1-&gt;vm_ebx = vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\nxchg eax ebx\n7.自定义函数unsigned __int64 __fastcall sub_99C(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax = a1-&gt;vm_ecx + 2 * a1-&gt;vm_ebx + 3 * a1-&gt;vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n实现了eax=ecx+2ebx+3eax应该是自定义指令\n自己实现dispatcher，汇编层面逆向#include&lt;iostream&gt;using namespace std;int opcode[]=&#123;0xF5, 0xF1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x20, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x01, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x21, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x22, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x03, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x23,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x24, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x25, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x26, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x27, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x28, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x09, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x29, 0x00, 0x00,   0x00, 0xF1, 0xE1, 0x0A, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x2A, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0B, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x2B, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0C,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2C, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2D,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x2E, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0F, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2F, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x10, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x30, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x11, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x31, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x12, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x32, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x13, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x33, 0x00, 0x00,   0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0xF1,   0xE1, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x01, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x01, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x02, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x01, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x03, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x02, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x03, 0x00,   0x00, 0x00, 0xF1, 0xE2, 0x04, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x03, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x05, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x04, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x05,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x06, 0x00, 0x00, 0x00, 0xF1,   0xE2, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x08, 0x00, 0x00,   0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6, 0xF7, 0xF1,   0xE4, 0x06, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x08, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x09,   0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6,   0xF7, 0xF1, 0xE4, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x09, 0x00, 0x00, 0x00, 0xF1,   0xE3, 0x0A, 0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00,   0x00, 0xF6, 0xF7, 0xF1, 0xE4, 0x08, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x13, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x13, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x12, 0x00, 0x00, 0x00, 0xF8, 0xF1, 0xE4, 0x0E,   0x00, 0x00, 0x00, 0xF1, 0xE7, 0x12, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x11, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x11, 0x00, 0x00, 0x00, 0xF4&#125;;int main()&#123;    int rip=0;    int vm_eax=0;    int vm_ebx=18;    int vm_ecx=0;    int vm_edx=0;    int vm_stack[521];    for(int i=0;i&lt;521;i++)    &#123;        vm_stack[i]=0;    &#125;    int len = sizeof(opcode) / sizeof(opcode[0]);    while (rip&lt;len)    &#123;        if(opcode[rip]==0xF1)        &#123;            int v2=opcode[rip+2];            switch(opcode[rip+1])            &#123;                case 0xE1:                    vm_eax = vm_stack[v2];                    cout&lt;&lt;&quot;mov eax,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE2:                    vm_ebx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ebx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE3:                    vm_ecx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ecx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE4:                    vm_stack[v2] = vm_eax;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],eax&quot;&lt;&lt;endl;                    break;                case 0xE5:                    vm_edx = vm_stack[v2];                    cout&lt;&lt;&quot;mov edx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE7:                    vm_stack[v2] = vm_ebx;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],ebx&quot;&lt;&lt;endl;                    break;                default:                    break;            &#125;            rip+=6;            continue;        &#125;        else if(opcode[rip]==0xF2)        &#123;            vm_eax^=vm_ebx;            cout&lt;&lt;&quot;xor eax ebx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF5)        &#123;            // for(int i=0;i&lt;21;i++)            // &#123;            //     char c;            //     cin&gt;&gt;c;            //     vm_stack[i]=c;            // &#125;            cout&lt;&lt;&quot;read flag&amp;&amp;judge len&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xf4)        &#123;            cout&lt;&lt;&quot;nop&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF6)        &#123;            vm_eax=vm_ecx+2*vm_ebx+3*vm_eax;            cout&lt;&lt;&quot;eax=ecx+2*ebx+3*eax&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF7)        &#123;            vm_eax*=vm_edx;            cout&lt;&lt;&quot;mul eax edx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF8)        &#123;            int t = vm_eax;            vm_eax = vm_ebx;            vm_ebx = t;            cout&lt;&lt;&quot;xchg eax ebx&quot;&lt;&lt;endl;        &#125;        rip++;    &#125;&#125;\n这里其实可以把栈信息一起打印出来的，但是这道题非常简单没有涉及到栈的其他操作，只是简单把flag放在栈上，所以这里不打印了\n结果：\nread flag&amp;&amp;judge lenmov eax,stack[0]xor eax ebxmov stack[32],eaxmov eax,stack[1]xor eax ebxmov stack[33],eaxmov eax,stack[2]xor eax ebxmov stack[34],eaxmov eax,stack[3]xor eax ebxmov stack[35],eaxmov eax,stack[4]xor eax ebxmov stack[36],eaxmov eax,stack[5]xor eax ebxmov stack[37],eaxmov eax,stack[6]xor eax ebxmov stack[38],eaxmov eax,stack[7]xor eax ebxmov stack[39],eaxmov eax,stack[8]xor eax ebxmov stack[40],eaxmov eax,stack[9]xor eax ebxmov stack[41],eaxmov eax,stack[10]xor eax ebxmov stack[42],eaxmov eax,stack[11]xor eax ebxmov stack[43],eaxmov eax,stack[12]xor eax ebxmov stack[44],eaxmov eax,stack[13]xor eax ebxmov stack[45],eaxmov eax,stack[14]xor eax ebxmov stack[46],eaxmov eax,stack[15]xor eax ebxmov stack[47],eaxmov eax,stack[16]xor eax ebxmov stack[48],eaxmov eax,stack[17]xor eax ebxmov stack[49],eaxmov eax,stack[18]xor eax ebxmov stack[50],eaxmov eax,stack[19]xor eax ebxmov stack[51],eaxnopread flag&amp;&amp;judge lenmov eax,stack[0]mov ebx,stack[1]xor eax ebxmov stack[0],eaxmov eax,stack[1]mov ebx,stack[2]xor eax ebxmov stack[1],eaxmov eax,stack[2]mov ebx,stack[3]xor eax ebxmov stack[2],eaxmov eax,stack[3]mov ebx,stack[4]xor eax ebxmov stack[3],eaxmov eax,stack[4]mov ebx,stack[5]xor eax ebxmov stack[4],eaxmov eax,stack[5]mov ebx,stack[6]xor eax ebxmov stack[5],eaxmov eax,stack[6]mov ebx,stack[7]mov ecx,stack[8]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[6],eaxmov eax,stack[7]mov ebx,stack[8]mov ecx,stack[9]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[7],eaxmov eax,stack[8]mov ebx,stack[9]mov ecx,stack[10]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[8],eaxmov eax,stack[13]mov ebx,stack[19]xchg eax ebxmov stack[13],eaxmov stack[19],ebxmov eax,stack[14]mov ebx,stack[18]xchg eax ebxmov stack[14],eaxmov stack[18],ebxmov eax,stack[15]mov ebx,stack[17]xchg eax ebxmov stack[15],eaxmov stack[17],ebxnop\n正常一道普通的vm逆向题到这里看汇编逆向写exp就结束了，但这道题还有坑\n题外话：解题：这道题汇编前半部分很明显不对，因为flag总长度才21，栈上怎么索引到50多了，所以交叉引用找到真正的check函数,而且汇报中有两次输入，第二次输入才是真的\nunsigned __int64 sub_F00()&#123;  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; len_flag - 1 &gt; i; ++i )  &#123;    if ( *((_BYTE *)vm_stack + i) != byte_202020[i] )      exit(0);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\nexp：\nfrom z3 import *import re# 密文（十六进制字符串）flag = &#x27;69 45 2A 37 09 17 C5 0B 5C 72 33 76 33 21 74 31 5F 33 73 72&#x27;.split(&#x27; &#x27;)flag = [int(x, 16) for x in flag]# 1) 还原前面的三次交换（你在 forward 阶段做了 13&lt;-&gt;19, 14&lt;-&gt;18, 15&lt;-&gt;17）flag[15], flag[17] = flag[17], flag[15]flag[14], flag[18] = flag[18], flag[14]flag[19], flag[13] = flag[13], flag[19]# 2) 用 Z3 求解 a6,a7,a8（原始 stack[6..8]）# 方程（forward）是： f6 = (s8 + 2*s7 + 3*s6) * s12  （全部为字节运算）a6, a7, a8 = BitVecs(&#x27;a6 a7 a8&#x27;, 8)s = Solver()# 注意：这里 flag[...] 是 Python 整数（0..255），Z3 会自动把它转为相应的常量。# 若你想更严格地把所有算术限定为 8-bit，可把常量也包装成 BitVecVal(...,8)。s.add( BitVecVal(flag[6],8) == (a8 + (a7 &lt;&lt; 1) + a6 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[7],8) == (BitVecVal(flag[9],8)  + (a8 &lt;&lt; 1) + a7 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[8],8) == (BitVecVal(flag[10],8) + (BitVecVal(flag[9],8) &lt;&lt; 1) + a8 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )if s.check() == sat:    m = s.model()    # 把求得的 a6,a7,a8 写回 flag 对应位置    for v in [a6, a7, a8]:        idx = int(re.search(r&#x27;\\d+&#x27;, str(v)).group())        flag[idx] = m[v].as_long()# 3) 逆向 XOR 链（forward 做了 f0 = s0^s1; f1 = s1^s2; ...; f5 = s5^s6）for i in range(5, -1, -1):    flag[i] ^= flag[i + 1]print(&#x27;[+] flag: &#x27;, &#x27;&#x27;.join(chr(x) for x in flag))# [+] flag:  Y0u_hav3_r3v3rs3_1t!\n ","categories":["vm逆向题单"],"tags":["vm逆向","ctf"]},{"title":"逆向中的AES(一)","url":"/2025/10/09/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/aes1/","content":"前言：aes在逆向有很多应用，尤其是现在越来越多软件加密逻辑都选择aes，所以总结一下aes的算法和在ctf逆向中的考点\naes算法基础\naes最重要的一个特征就是输入是128位分组，输出也是128位分组，但其中key分128位，192位，256位三种版本\n\n\n\n\nAES 类型\n密钥长度\n轮数 (Nr)\n密钥字数 (Nk)\n\n\n\n\nAES-128\n128 位\n10\n4\n\n\nAES-192\n192 位\n12\n6\n\n\nAES-256\n256 位\n14\n8\n\n\n\n\naes分组后16个字节是按矩阵方式排列\n\n加密总流程：\n最终轮和前面9轮的区别是没有第三个步骤列混合\n初始变换(Initial round)初始变换就是输入的16个字节和密钥(不确定几位)进行密钥扩展后生成的(16位)异或的结果\n\n\\text{State}' = \\text{State} \\oplus \\text{RoundKey}_0展开为矩阵形式：\n\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\\\\ns_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\\\\ns_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}\n\\end{bmatrix}\n\\;\\oplus\\;\n\\begin{bmatrix}\nk_{0,0} & k_{0,1} & k_{0,2} & k_{0,3} \\\\\nk_{1,0} & k_{1,1} & k_{1,2} & k_{1,3} \\\\\nk_{2,0} & k_{2,1} & k_{2,2} & k_{2,3} \\\\\nk_{3,0} & k_{3,1} & k_{3,2} & k_{3,3}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\ns'_{0,0} & s'_{0,1} & s'_{0,2} & s'_{0,3} \\\\\ns'_{1,0} & s'_{1,1} & s'_{1,2} & s'_{1,3} \\\\\ns'_{2,0} & s'_{2,1} & s'_{2,2} & s'_{2,3} \\\\\ns'_{3,0} & s'_{3,1} & s'_{3,2} & s'_{3,3}\n\\end{bmatrix}其中：\n\n 为明文状态矩阵中第  个字节  \n 为轮密钥矩阵中第  个字节  \n 表示按字节异或（XOR）运算\n\n循环运算：字节代换：\n字节代换就是把第一步初始变换后的16字节矩阵块用s表代换，例如矩阵左上角的数是十六进制19，那就要代换成s盒中第1行第9列，查表可知是d4，以此类推\n结果：\n\n行移位：ShiftRows 操作在状态矩阵上进行，规则如下：\n\n第 0 行不变\n第 1 行循环左移 1 字节\n第 2 行循环左移 2 字节\n第 3 行循环左移 3 字节\n\n原始状态矩阵：\n\n\\text{State} =\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\\\\ns_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\\\\ns_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}\n\\end{bmatrix}经过行移位后：\n\n\\text{State}' =\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,1} & s_{1,2} & s_{1,3} & s_{1,0} \\\\\ns_{2,2} & s_{2,3} & s_{2,0} & s_{2,1} \\\\\ns_{3,3} & s_{3,0} & s_{3,1} & s_{3,2}\n\\end{bmatrix}每一行的移位规律如下：\n\n\n\n\n行号\n移位字节数\n移位方向\n\n\n\n\n0\n0\n不变\n\n\n1\n1\n左移\n\n\n2\n2\n左移\n\n\n3\n3\n左移\n\n\n\n\n列混淆：\n左乘一个确定的矩阵，但是这里的乘法不是普通乘法\n列混淆中的乘法\n\\begin{aligned}\ns'_{0,c} &= (02 \\cdot s_{0,c}) \\oplus (03 \\cdot s_{1,c}) \\oplus s_{2,c} \\oplus s_{3,c} \\\\\ns'_{1,c} &= s_{0,c} \\oplus (02 \\cdot s_{1,c}) \\oplus (03 \\cdot s_{2,c}) \\oplus s_{3,c} \\\\\ns'_{2,c} &= s_{0,c} \\oplus s_{1,c} \\oplus (02 \\cdot s_{2,c}) \\oplus (03 \\cdot s_{3,c}) \\\\\ns'_{3,c} &= (03 \\cdot s_{0,c}) \\oplus s_{1,c} \\oplus s_{2,c} \\oplus (02 \\cdot s_{3,c})\n\\end{aligned}其中乘法在有限域  上进行：\n\n 表示按字节左移一位（若最高位为 1，则再与 0x1B 异或）  \n\n\n注：与0x1B异或是因为要构造有限域构造出来的多项式把模之后的结果，学逆向不用学那么深，只需要知道aes的加密解密和漏洞攻击就可以了\n轮密钥加：AddRoundKey 是 AES 每一轮中最简单但最关键的操作之一。它将 状态矩阵 (State) 与 轮密钥矩阵 (RoundKey) 按字节异或（XOR）：\n\n\\text{State}' = \\text{State} \\oplus \\text{RoundKey}_i设状态矩阵为：\n\n\\text{State} =\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\\\\ns_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\\\\ns_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}\n\\end{bmatrix}轮密钥矩阵为：\n\n\\text{RoundKey}_i =\n\\begin{bmatrix}\nk_{0,0} & k_{0,1} & k_{0,2} & k_{0,3} \\\\\nk_{1,0} & k_{1,1} & k_{1,2} & k_{1,3} \\\\\nk_{2,0} & k_{2,1} & k_{2,2} & k_{2,3} \\\\\nk_{3,0} & k_{3,1} & k_{3,2} & k_{3,3}\n\\end{bmatrix}异或后得到：\n\n\\text{State}' =\n\\begin{bmatrix}\ns_{0,0} \\oplus k_{0,0} & s_{0,1} \\oplus k_{0,1} & s_{0,2} \\oplus k_{0,2} & s_{0,3} \\oplus k_{0,3} \\\\\ns_{1,0} \\oplus k_{1,0} & s_{1,1} \\oplus k_{1,1} & s_{1,2} \\oplus k_{1,2} & s_{1,3} \\oplus k_{1,3} \\\\\ns_{2,0} \\oplus k_{2,0} & s_{2,1} \\oplus k_{2,1} & s_{2,2} \\oplus k_{2,2} & s_{2,3} \\oplus k_{2,3} \\\\\ns_{3,0} \\oplus k_{3,0} & s_{3,1} \\oplus k_{3,1} & s_{3,2} \\oplus k_{3,2} & s_{3,3} \\oplus k_{3,3}\n\\end{bmatrix}按字节运算公式每个字节的计算方式为：\n\ns'_{i,j} = s_{i,j} \\oplus k_{i,j}, \\quad 0 \\le i,j \\le 3密钥扩展：初始只有128/192/256位的密钥是怎么更新的呢，这就涉及到密钥扩展\n这是初始状态，这里以128位密钥为例，先全部填入前4列，设第5列为Wi\n\n\n初始部分：\n\n\nW[i] = \\text{原始密钥的第 } i \\text{ 个 32 位字}, \\quad 0 \\le i < N_k\n递推部分：（适用于所有aes算法）\n\n对于 ：\n\nW[i] =\n\\begin{cases}\nW[i - N_k] \\oplus \\text{SubWord}(\\text{RotWord}(W[i - 1])) \\oplus \\text{Rcon}[i/N_k], & \\text{if } i \\bmod N_k = 0 \\\\\nW[i - N_k] \\oplus \\text{SubWord}(W[i - 1]), & \\text{if } N_k > 6 \\text{ and } i \\bmod N_k = 4  (只有aes256有这条)\\\\\nW[i - N_k] \\oplus W[i - 1], & \\text{otherwise}\n\\end{cases}函数定义RotWord：循环左移 1 字节  \n\n[a_0, a_1, a_2, a_3] \\Rightarrow [a_1, a_2, a_3, a_0]\nSubWord：对 4 个字节分别进行 S-box 替代  \n\n[a_0, a_1, a_2, a_3] \\Rightarrow [S(a_0), S(a_1), S(a_2), S(a_3)]Rcon：轮常数，仅作用于字的第一个字节：\n\n\\text{Rcon}[i] =\n\\begin{bmatrix}\n\\text{RC}[i] & 00 & 00 & 00\n\\end{bmatrix}其中，，，，，，，，，\n最终结果\n解密方式就是把上述过程反过来一遍（解密的第一轮没有列混合逆向）\n\n其中的轮密钥加只需要每轮相同状态的W[i,i+3]就可以\n逆列混淆\n逆行移位：就是逆向移位就可以，很简单\n逆s表\n查表即可\n逆向题型：普通AES找到密钥，找到密文，逆向脚本，进行解密。\n加解密脚本:\ns_box = (    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)# inv_s_box = tuple([s_box.index(i) for i in range(256)])inv_s_box = (    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,)def sub_bytes(s):    for i in range(4):        for j in range(4):            s[i][j] = s_box[s[i][j]]def inv_sub_bytes(s):    for i in range(4):        for j in range(4):            s[i][j] = inv_s_box[s[i][j]]def shift_rows(s):    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]def inv_shift_rows(s):    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]def add_round_key(s, k):    for i in range(4):        for j in range(4):            s[i][j] ^= k[i][j]# learned from https://web.archive.org/web/20100626212235/http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.cxtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def mix_single_column(a):    # see Sec 4.1.2 in The Design of Rijndael    t = a[0] ^ a[1] ^ a[2] ^ a[3]    u = a[0]    a[0] ^= t ^ xtime(a[0] ^ a[1])    a[1] ^= t ^ xtime(a[1] ^ a[2])    a[2] ^= t ^ xtime(a[2] ^ a[3])    a[3] ^= t ^ xtime(a[3] ^ u)def mix_columns(s):    for i in range(4):        mix_single_column(s[i])def inv_mix_columns(s):    # see Sec 4.1.3 in The Design of Rijndael    for i in range(4):        u = xtime(xtime(s[i][0] ^ s[i][2]))        v = xtime(xtime(s[i][1] ^ s[i][3]))        s[i][0] ^= u        s[i][1] ^= v        s[i][2] ^= u        s[i][3] ^= v    mix_columns(s)r_con = (    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,)def bytes2matrix(text):    \"\"\" Converts a 16-byte array into a 4x4 matrix.  \"\"\"    return [list(text[i:i+4]) for i in range(0, len(text), 4)]def matrix2bytes(matrix):    \"\"\" Converts a 4x4 matrix into a 16-byte array.  \"\"\"    return bytes(sum(matrix, []))def xor_bytes(a, b):    \"\"\" Returns a new byte array with the elements xor'ed. \"\"\"    return bytes(i^j for i, j in zip(a, b))def inc_bytes(a):    \"\"\" Returns a new byte array with the value increment by 1 \"\"\"    out = list(a)    for i in reversed(range(len(out))):        if out[i] == 0xFF:            out[i] = 0        else:            out[i] += 1            break    return bytes(out)def pad(plaintext):    \"\"\"    Pads the given plaintext with PKCS#7 padding to a multiple of 16 bytes.    Note that if the plaintext size is a multiple of 16,    a whole block will be added.    \"\"\"    padding_len = 16 - (len(plaintext) % 16)    padding = bytes([padding_len] * padding_len)    return plaintext + paddingdef unpad(plaintext):    \"\"\"    Removes a PKCS#7 padding, returning the unpadded text and ensuring the    padding was correct.    \"\"\"    padding_len = plaintext[-1]    assert padding_len &gt; 0    message, padding = plaintext[:-padding_len], plaintext[-padding_len:]    assert all(p == padding_len for p in padding)    return messagedef split_blocks(message, block_size=16, require_padding=True):        assert len(message) % block_size == 0 or not require_padding        return [message[i:i+16] for i in range(0, len(message), block_size)]class AES:    \"\"\"    Class for AES-128 encryption with CBC mode and PKCS#7.    This is a raw implementation of AES, without key stretching or IV    management. Unless you need that, please use `encrypt` and `decrypt`.    \"\"\"    rounds_by_key_size = {16: 10, 24: 12, 32: 14}    def __init__(self, master_key):        \"\"\"        Initializes the object with a given key.        \"\"\"        assert len(master_key) in AES.rounds_by_key_size        self.n_rounds = AES.rounds_by_key_size[len(master_key)]        self._key_matrices = self._expand_key(master_key)    def _expand_key(self, master_key):        \"\"\"        Expands and returns a list of key matrices for the given master_key.        \"\"\"        # Initialize round keys with raw key material.        key_columns = bytes2matrix(master_key)        iteration_size = len(master_key) // 4        i = 1        # expand round: (rounds+1)*4        while len(key_columns) &lt; (self.n_rounds + 1) * 4:            # Copy previous word.            word = list(key_columns[-1])            # Perform schedule_core once every \"row\".            if len(key_columns) % iteration_size == 0:                # Circular shift.                word.append(word.pop(0))                # Map to S-BOX.                word = [s_box[b] for b in word]                # XOR with first byte of R-CON, since the others bytes of R-CON are 0.                word[0] ^= r_con[i]                i += 1            elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:                # Run word through S-box in the fourth iteration when using a                # 256-bit key.                word = [s_box[b] for b in word]            # XOR with equivalent word from previous iteration.            word = xor_bytes(word, key_columns[-iteration_size])            key_columns.append(list(word))        # Group key words in 4x4 byte matrices.        return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)]    def encrypt_ecb(self, ciphertext):        assert len(ciphertext) &gt;= 16        assert len(ciphertext) % 16 == 0        result = b''        for i in range(0, len(ciphertext), 16):            result += self.encrypt_ecb_block(ciphertext[i:i+16])        return result    def encrypt_ecb_block(self, plaintext):        \"\"\"        Encrypts a single block of 16 byte long plaintext.        \"\"\"        assert len(plaintext) == 16        plain_state = bytes2matrix(plaintext)        add_round_key(plain_state, self._key_matrices[0])        for i in range(1, self.n_rounds):            sub_bytes(plain_state)            shift_rows(plain_state)            mix_columns(plain_state)            add_round_key(plain_state, self._key_matrices[i])        sub_bytes(plain_state)        shift_rows(plain_state)        add_round_key(plain_state, self._key_matrices[-1])        return matrix2bytes(plain_state)    def decrypt_ecb(self, ciphertext):        assert len(ciphertext) &gt;= 16        assert len(ciphertext) % 16 == 0        result = b''        for i in range(0, len(ciphertext), 16):            result += self.decrypt_ecb_block(ciphertext[i:i+16])        return result    def decrypt_ecb_block(self, ciphertext):        \"\"\"        Decrypts a single block of 16 byte long ciphertext.        \"\"\"        assert len(ciphertext) == 16        cipher_state = bytes2matrix(ciphertext)        add_round_key(cipher_state, self._key_matrices[-1])        inv_shift_rows(cipher_state)        inv_sub_bytes(cipher_state)        for i in range(self.n_rounds - 1, 0, -1):            add_round_key(cipher_state, self._key_matrices[i])            inv_mix_columns(cipher_state)            inv_shift_rows(cipher_state)            inv_sub_bytes(cipher_state)        add_round_key(cipher_state, self._key_matrices[0])        return matrix2bytes(cipher_state)    def encrypt_cbc(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using CBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        plaintext = pad(plaintext)        blocks = []        previous = iv        for plaintext_block in split_blocks(plaintext):            # CBC mode encrypt: encrypt(plaintext_block XOR previous)            block = self.encrypt_ecb_block(xor_bytes(plaintext_block, previous))            blocks.append(block)            previous = block        return b''.join(blocks)    def decrypt_cbc(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using CBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        previous = iv        for ciphertext_block in split_blocks(ciphertext):            # CBC mode decrypt: previous XOR decrypt(ciphertext)            blocks.append(xor_bytes(previous, self.decrypt_ecb_block(ciphertext_block)))            previous = ciphertext_block        return unpad(b''.join(blocks))    def encrypt_pcbc(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using PCBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        plaintext = pad(plaintext)        blocks = []        prev_ciphertext = iv        prev_plaintext = bytes(16)        for plaintext_block in split_blocks(plaintext):            # PCBC mode encrypt: encrypt(plaintext_block XOR (prev_ciphertext XOR prev_plaintext))            ciphertext_block = self.encrypt_ecb_block(xor_bytes(plaintext_block, xor_bytes(prev_ciphertext, prev_plaintext)))            blocks.append(ciphertext_block)            prev_ciphertext = ciphertext_block            prev_plaintext = plaintext_block        return b''.join(blocks)    def decrypt_pcbc(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using PCBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        prev_ciphertext = iv        prev_plaintext = bytes(16)        for ciphertext_block in split_blocks(ciphertext):            # PCBC mode decrypt: (prev_plaintext XOR prev_ciphertext) XOR decrypt(ciphertext_block)            plaintext_block = xor_bytes(xor_bytes(prev_ciphertext, prev_plaintext), self.decrypt_ecb_block(ciphertext_block))            blocks.append(plaintext_block)            prev_ciphertext = ciphertext_block            prev_plaintext = plaintext_block        return unpad(b''.join(blocks))    def encrypt_cfb(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` with the given initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        prev_ciphertext = iv        for plaintext_block in split_blocks(plaintext, require_padding=False):            # CFB mode encrypt: plaintext_block XOR encrypt(prev_ciphertext)            ciphertext_block = xor_bytes(plaintext_block, self.encrypt_ecb_block(prev_ciphertext))            blocks.append(ciphertext_block)            prev_ciphertext = ciphertext_block        return b''.join(blocks)    def decrypt_cfb(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` with the given initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        prev_ciphertext = iv        for ciphertext_block in split_blocks(ciphertext, require_padding=False):            # CFB mode decrypt: ciphertext XOR decrypt(prev_ciphertext)            plaintext_block = xor_bytes(ciphertext_block, self.encrypt_ecb_block(prev_ciphertext))            blocks.append(plaintext_block)            prev_ciphertext = ciphertext_block        return b''.join(blocks)    def encrypt_ofb(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using OFB mode initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        previous = iv        for plaintext_block in split_blocks(plaintext, require_padding=False):            # OFB mode encrypt: plaintext_block XOR encrypt(previous)            block = self.encrypt_ecb_block(previous)            ciphertext_block = xor_bytes(plaintext_block, block)            blocks.append(ciphertext_block)            previous = block        return b''.join(blocks)    def decrypt_ofb(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using OFB mode initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        previous = iv        for ciphertext_block in split_blocks(ciphertext, require_padding=False):            # OFB mode decrypt: ciphertext XOR encrypt(previous)            block = self.encrypt_ecb_block(previous)            plaintext_block = xor_bytes(ciphertext_block, block)            blocks.append(plaintext_block)            previous = block        return b''.join(blocks)    def encrypt_ctr(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using CTR mode with the given nounce/IV.        \"\"\"        assert len(iv) == 16        blocks = []        nonce = iv        for plaintext_block in split_blocks(plaintext, require_padding=False):            # CTR mode encrypt: plaintext_block XOR encrypt(nonce)            block = xor_bytes(plaintext_block, self.encrypt_ecb_block(nonce))            blocks.append(block)            nonce = inc_bytes(nonce)        return b''.join(blocks)    def decrypt_ctr(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using CTR mode with the given nounce/IV.        \"\"\"        assert len(iv) == 16        blocks = []        nonce = iv        for ciphertext_block in split_blocks(ciphertext, require_padding=False):            # CTR mode decrypt: ciphertext XOR encrypt(nonce)            block = xor_bytes(ciphertext_block, self.encrypt_ecb_block(nonce))            blocks.append(block)            nonce = inc_bytes(nonce)        return b''.join(blocks)def AES_ecb_encrypt(data: bytes, key: bytes):    a = AES(key)    return a.encrypt_ecb(data)def AES_ecb_decrypt(data: bytes, key: bytes):    a = AES(key)    return a.decrypt_ecb(data)def AES_cbc_encrypt(data: bytes, key: bytes, iv: bytes):    a = AES(key)    return a.encrypt_cbc(data, iv)def AES_cbc_decrypt(data: bytes, key: bytes, iv: bytes):    a = AES(key)    return a.decrypt_cbc(data, iv)\n白盒AES\n\n\n\n项目\n普通 AES（黑盒）\n白盒 AES\n\n\n\n\n密钥\n独立变量、明确定义\n被混入查表中，不可直接访问\n\n\n算法结构\n明确的五步（SubBytes 等）\n各步骤混淆成查表和线性映射\n\n\n可移植性\n高（用同样的密钥随处运行）\n低（查表与密钥绑定）\n\n\n安全假设\n攻击者看不到内部\n攻击者能看到全部\n\n\n\n\n 目前市面上大多数app都是基于白盒aes开发的，还有查表法实现的aes真的严格按照上面讲的aes流程走的很少，白盒aes东西太多了，而且还有很多攻击手法，就放在”逆向中的AES(二)“里讲好了\n参考资料：【AES加密算法】| AES加密过程详解| 对称加密| Rijndael-128| 密码学| 信息安全_哔哩哔哩_bilibili\n密码学——AES/DES加密算法原理介绍 - 枫のBlog\n","categories":["逆向中的密码学","对称加密基础"],"tags":["aes"]},{"title":"逆向中的AES(二)","url":"/2025/10/09/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/aes2/","content":"前言：逆向工程中往往使用aes加密的程序不是用的查表法aes，就是用的白盒aes，让你难以分析，傻乎乎的使用aes基础算法很容易被破解\n查表法实现的aes：在前一篇文章中我们详细讲解了AES的每一轮中具体的四层结构，以加密过程为例分别是：字节代换层、行移位层、列混淆层和轮密钥加层\n对于查表法实现，就是要将每一轮中的前三层操作(字节代换层、行移位层和列混淆层)合并为查找表。\n查表法的核心思想是将字节代换层、ShiftRows层和MixColumn层融合为查找表：每个表的大小是32 bits(4字节)乘以256项，一般称为T盒(T-Box)或T表。加密过程4个表(Te)，解密过程4个表(Td)，共8个。每一轮操作都通过16次查表产生。\n算法中定义T表实现为：\nT0[x] = (2·S[x])&lt;&lt;24 | (S[x])&lt;&lt;16 | (S[x])&lt;&lt;8 | (3·S[x])T1[x] = (3·S[x])&lt;&lt;24 | (2·S[x])&lt;&lt;16 | (S[x])&lt;&lt;8 | (S[x])T2[x] = (S[x])&lt;&lt;24 | (3·S[x])&lt;&lt;16 | (2·S[x])&lt;&lt;8 | (S[x])T3[x] = (S[x])&lt;&lt;24 | (S[x])&lt;&lt;16 | (3·S[x])&lt;&lt;8 | (2·S[x])\n其中：\n\nS[x] 是 S-box 输出；\n\n2·S[x] 表示有限域 GF(2^8) 下的乘法（即 xtime 运算）。\n\n\n原理：由于aes加密流程中的字节代换和行移位可随意更改顺序而不影响加密结果，所以，我们把行移位放在最前面\n\n先不管行移位，把行移位之后的矩阵状态设为\n\n\\begin{bmatrix}\na_0 & a_4 & a_8 & a_{12} \\\\\na_1 & a_5 & a_9 & a_{13} \\\\\na_2 & a_6 & a_{10} & a_{14} \\\\\na_3 & a_7 & a_{11} & a_{15}\n\\end{bmatrix}只看第一列的变化，设\na0' = S[a0]a1' = S[a1]a2' = S[a2]a3' = S[a3]\n\n\\begin{bmatrix}\nc_0 \\\\ c_1 \\\\ c_2 \\\\ c_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n2 & 3 & 1 & 1 \\\\\n1 & 2 & 3 & 1 \\\\\n1 & 1 & 2 & 3 \\\\\n3 & 1 & 1 & 2\n\\end{bmatrix}\n\\begin{bmatrix}\na_0' \\\\ a_1' \\\\ a_2' \\\\ a_3'\n\\end{bmatrix}c0 = 2·a0' ⊕ 3·a1' ⊕ 1·a2' ⊕ 1·a3'c1 = 1·a0' ⊕ 2·a1' ⊕ 3·a2' ⊕ 1·a3'c2 = 1·a0' ⊕ 1·a1' ⊕ 2·a2' ⊕ 3·a3'c3 = 3·a0' ⊕ 1·a1' ⊕ 1·a2' ⊕ 2·a3'\nT0[x] = (2·S[x], S[x], S[x], 3·S[x])   // 合并为一个 32 位值T1[x] = (3·S[x], 2·S[x], S[x], S[x])T2[x] = (S[x], 3·S[x], 2·S[x], S[x])T3[x] = (S[x], S[x], 3·S[x], 2·S[x])\n所以\nT0[a0] = [2·S[a0], S[a0], S[a0], 3·S[a0]]T1[a1] = [3·S[a1], 2·S[a1], S[a1], S[a1]]T2[a2] = [S[a2], 3·S[a2], 2·S[a2], S[a2]]T3[a3] = [S[a3], S[a3], 3·S[a3], 2·S[a3]]\n于是\nc0c1c2c3 = T0[a0] ⊕ T1[a1] ⊕ T2[a2] ⊕ T3[a3]\n现在再来考虑行移位的影响，只要把a1-a15的对应标号改掉就行\nt0 = T0[a0] ^ T1[a5] ^ T2[a10] ^ T3[a15] ^ roundKey[0];t1 = T0[a4] ^ T1[a9] ^ T2[a14] ^ T3[a3]  ^ roundKey[1];t2 = T0[a8] ^ T1[a13]^ T2[a2]  ^ T3[a7]  ^ roundKey[2];t3 = T0[a12]^ T1[a1] ^ T2[a6]  ^ T3[a11] ^ roundKey[3];\n是最后加密的结果\n代码实现：#include &lt;stdlib.h&gt;#ifndef AES_H#define AES_H#include &lt;stdint.h&gt;typedef struct AES_Key {    uint32_t* ek;  // AES加密轮密钥    uint32_t* dk;  // AES 解密轮密钥    uint32_t nr;   //加密轮数} AES_Key;int AES_KeyInit(uint8_t* key, AES_Key* aes_key, size_t bits);void AES_Encrypt(uint8_t* plaintext, uint8_t* ciphertext, AES_Key aes_key);void AES_Decrypt(uint8_t* ciphertext, uint8_t* plaintext, AES_Key aes_key);void AES_KeyDelete(AES_Key aes_key);#endifstatic const uint8_t Sbox[256] = {    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B,    0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26,    0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,    0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED,    0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F,    0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC,    0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14,    0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,    0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F,    0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11,    0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F,    0xB0, 0x54, 0xBB, 0x16 };static const unsigned char SboxIV[256] = {  0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,  0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,  0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,  0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,  0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,  0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,  0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,  0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,  0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,  0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,  0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,  0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,  0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,  0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,  0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,  0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D};static const uint32_t TE[256] = {    0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd,    0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d,    0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d,    0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,    0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7,    0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,    0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4,    0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,    0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1,    0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,    0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e,    0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,    0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e,    0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c,    0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46,    0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,    0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7,    0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81,    0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe,    0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,    0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a,    0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,    0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2,    0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,    0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e,    0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,    0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256,    0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,    0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4,    0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,    0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa,    0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,    0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1,    0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,    0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42,    0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,    0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158,    0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,    0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22,    0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,    0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631,    0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,    0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a };static const uint32_t TD[256] = {    0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1,    0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25,    0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67,    0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,    0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3,    0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd,    0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182,    0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,    0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2,    0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5,    0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492,    0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a,    0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa,    0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46,    0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997,    0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb,    0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48,    0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927,    0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f,    0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,    0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad,    0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd,    0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc,    0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,    0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3,    0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422,    0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1,    0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,    0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8,    0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3,    0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4,    0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,    0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331,    0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815,    0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d,    0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,    0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252,    0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89,    0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f,    0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,    0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c,    0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190,    0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742 };#define rotr32(value, shift) ((value &gt;&gt; shift) ^ (value &lt;&lt; (32 - shift)))int AES_KeyInit(uint8_t* key, AES_Key* aes_key, size_t bits) {    uint32_t Rcon[10] = { 0x01, 0x02, 0x04, 0x08, 0x10,                         0x20, 0x40, 0x80, 0x1B, 0x36 };  //轮常数    uint32_t nr = 10 + (bits - 128) / 32;                //加密轮数 Nr    uint32_t nk = bits / 32;                             //密钥字数 Nk    uint32_t tmp, tmp1;    aes_key-&gt;nr = nr;    //-----------malloc-------------    uint32_t* w = (uint32_t*)malloc(sizeof(uint32_t) * 4 * (nr + 1));    if (w == (void*)0) {        return 0;    }    uint32_t* d = (uint32_t*)malloc(sizeof(uint32_t) * 4 * (nr + 1));    if (d == (void*)0) {        free(d);        return 0;    }    //--------------Load as BigEndian---------------    for (int i = 0; i &lt; nk; i++) {//将总的bits，每32个（四个字节）分一组，每一组用大端序来进行表示        w[i] = (key[4 * i + 0] &lt;&lt; 24) | (key[4 * i + 1] &lt;&lt; 16) |            (key[4 * i + 2] &lt;&lt; 8) | (key[4 * i + 3]);    }    //------------KeyExpand-----------------    for (int i = nk; i &lt; 4 * (nr + 1); i++) {        tmp = w[i - 1];        if (i % nk == 0) {            /* tmp = SubWord(RotWord(w[i-1])) */            tmp1 = tmp;            tmp = Sbox[(tmp1 &gt;&gt; 24) &amp; 0xFF];            tmp |= Sbox[(tmp1 &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 8;            tmp |= Sbox[(tmp1 &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 16;            tmp |= (Sbox[(tmp1 &gt;&gt; 16) &amp; 0xFF] ^ Rcon[i / nk - 1]) &lt;&lt; 24;        }        else if (nk &gt; 6 &amp;&amp; i % nk == 4) {            /* temp = SubWord(w[i-1]) */            tmp1 = tmp;            tmp = Sbox[(tmp1 &gt;&gt; 0) &amp; 0xFF];            tmp |= Sbox[(tmp1 &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;            tmp |= Sbox[(tmp1 &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;            tmp |= Sbox[(tmp1 &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;        }        w[i] = w[i - nk] ^ tmp;    }    aes_key-&gt;ek = w;    //------------TransKey-----------    for (int i = 0; i &lt; 4; i++) {        d[i] = w[i];    }    for (int i = 4; i &lt; 4 * nr; i++) {        //-----------MixCol IV-----------        d[i] = TD[Sbox[(w[i] &gt;&gt; 24) &amp; 0xFF]];        tmp = TD[Sbox[(w[i] &gt;&gt; 16) &amp; 0xFF]];        d[i] ^= rotr32(tmp, 8);        tmp = TD[Sbox[(w[i] &gt;&gt; 8) &amp; 0xFF]];        d[i] ^= rotr32(tmp, 16);        tmp = TD[Sbox[(w[i] &gt;&gt; 0) &amp; 0xFF]];        d[i] ^= rotr32(tmp, 24);    }    for (int i = 0; i &lt; 4; i++) {        d[4 * nr + i] = w[4 * nr + i];    }    aes_key-&gt;dk = d;    return 1;}void AES_KeyDelete(AES_Key aes_key) {    free(aes_key.ek);    free(aes_key.dk);}void AES_Encrypt(uint8_t* plaintext, uint8_t* ciphertext, AES_Key aes_key) {    uint32_t s[4];    uint32_t t[4];    uint32_t tmp;    //------------Load as BigEndian------------------    for (int i = 0; i &lt; 4; i++) {        s[i] = (plaintext[4 * i + 0] &lt;&lt; 24) | (plaintext[4 * i + 1] &lt;&lt; 16) |            (plaintext[4 * i + 2] &lt;&lt; 8) | (plaintext[4 * i + 3]);    }    //----------------AddRoundKey----------------    s[0] ^= aes_key.ek[0];    s[1] ^= aes_key.ek[1];    s[2] ^= aes_key.ek[2];    s[3] ^= aes_key.ek[3];    for (int i = 1; i &lt; aes_key.nr; i++) {        //-------ShiftRow + SubByte + MixCol-------------        // t0        t[0] = TE[(s[0] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[1] &gt;&gt; 16) &amp; 0xFF];        t[0] ^= rotr32(tmp, 8);        tmp = TE[(s[2] &gt;&gt; 8) &amp; 0xFF];        t[0] ^= rotr32(tmp, 16);        tmp = TE[(s[3] &gt;&gt; 0) &amp; 0xFF];        t[0] ^= rotr32(tmp, 24);        // t1        t[1] = TE[(s[1] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[2] &gt;&gt; 16) &amp; 0xFF];        t[1] ^= rotr32(tmp, 8);        tmp = TE[(s[3] &gt;&gt; 8) &amp; 0xFF];        t[1] ^= rotr32(tmp, 16);        tmp = TE[(s[0] &gt;&gt; 0) &amp; 0xFF];        t[1] ^= rotr32(tmp, 24);        // t2        t[2] = TE[(s[2] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[3] &gt;&gt; 16) &amp; 0xFF];        t[2] ^= rotr32(tmp, 8);        tmp = TE[(s[0] &gt;&gt; 8) &amp; 0xFF];        t[2] ^= rotr32(tmp, 16);        tmp = TE[(s[1] &gt;&gt; 0) &amp; 0xFF];        t[2] ^= rotr32(tmp, 24);        // t3        t[3] = TE[(s[3] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[0] &gt;&gt; 16) &amp; 0xFF];        t[3] ^= rotr32(tmp, 8);        tmp = TE[(s[1] &gt;&gt; 8) &amp; 0xFF];        t[3] ^= rotr32(tmp, 16);        tmp = TE[(s[2] &gt;&gt; 0) &amp; 0xFF];        t[3] ^= rotr32(tmp, 24);        //-------------AddRoundKey---------------        s[0] = t[0] ^ aes_key.ek[4 * i + 0];        s[1] = t[1] ^ aes_key.ek[4 * i + 1];        s[2] = t[2] ^ aes_key.ek[4 * i + 2];        s[3] = t[3] ^ aes_key.ek[4 * i + 3];    }    //------------ShiftRow + SubByte-----------    // t0    t[0] = Sbox[(s[0] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[0] |= Sbox[(s[1] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[0] |= Sbox[(s[2] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[0] |= Sbox[(s[3] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t1    t[1] = Sbox[(s[1] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[1] |= Sbox[(s[2] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[1] |= Sbox[(s[3] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[1] |= Sbox[(s[0] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t2    t[2] = Sbox[(s[2] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[2] |= Sbox[(s[3] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[2] |= Sbox[(s[0] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[2] |= Sbox[(s[1] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t3    t[3] = Sbox[(s[3] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[3] |= Sbox[(s[0] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[3] |= Sbox[(s[1] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[3] |= Sbox[(s[2] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    //------------AddRoundKey-------------    s[0] = t[0] ^ aes_key.ek[4 * aes_key.nr + 0];    s[1] = t[1] ^ aes_key.ek[4 * aes_key.nr + 1];    s[2] = t[2] ^ aes_key.ek[4 * aes_key.nr + 2];    s[3] = t[3] ^ aes_key.ek[4 * aes_key.nr + 3];    //-----------Store as BigEndian--------------    for (int i = 0; i &lt; 4; i++) {        ciphertext[4 * i + 0] = (s[i] &gt;&gt; 24) &amp; 0xFF;        ciphertext[4 * i + 1] = (s[i] &gt;&gt; 16) &amp; 0xFF;        ciphertext[4 * i + 2] = (s[i] &gt;&gt; 8) &amp; 0xFF;        ciphertext[4 * i + 3] = (s[i] &gt;&gt; 0) &amp; 0xFF;    }}void AES_Decrypt(uint8_t* ciphertext, uint8_t* plaintext, AES_Key aes_key) {    uint32_t s[4];    uint32_t t[4];    uint32_t tmp;    //------------Load as BigEndian------------------    for (int i = 0; i &lt; 4; i++) {        s[i] = (ciphertext[4 * i + 0] &lt;&lt; 24) | (ciphertext[4 * i + 1] &lt;&lt; 16) |            (ciphertext[4 * i + 2] &lt;&lt; 8) | (ciphertext[4 * i + 3]);    }    //----------------AddRoundKey----------------    s[0] ^= aes_key.dk[4 * aes_key.nr + 0];    s[1] ^= aes_key.dk[4 * aes_key.nr + 1];    s[2] ^= aes_key.dk[4 * aes_key.nr + 2];    s[3] ^= aes_key.dk[4 * aes_key.nr + 3];    for (int i = aes_key.nr - 1; i &gt; 0; i--) {        //-------ShiftRow IV + SubByte IV + MixCol IV-------------        // t0        t[0] = TD[(s[0] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[3] &gt;&gt; 16) &amp; 0xFF];        t[0] ^= rotr32(tmp, 8);        tmp = TD[(s[2] &gt;&gt; 8) &amp; 0xFF];        t[0] ^= rotr32(tmp, 16);        tmp = TD[(s[1] &gt;&gt; 0) &amp; 0xFF];        t[0] ^= rotr32(tmp, 24);        // t1        t[1] = TD[(s[1] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[0] &gt;&gt; 16) &amp; 0xFF];        t[1] ^= rotr32(tmp, 8);        tmp = TD[(s[3] &gt;&gt; 8) &amp; 0xFF];        t[1] ^= rotr32(tmp, 16);        tmp = TD[(s[2] &gt;&gt; 0) &amp; 0xFF];        t[1] ^= rotr32(tmp, 24);        // t2        t[2] = TD[(s[2] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[1] &gt;&gt; 16) &amp; 0xFF];        t[2] ^= rotr32(tmp, 8);        tmp = TD[(s[0] &gt;&gt; 8) &amp; 0xFF];        t[2] ^= rotr32(tmp, 16);        tmp = TD[(s[3] &gt;&gt; 0) &amp; 0xFF];        t[2] ^= rotr32(tmp, 24);        // t3        t[3] = TD[(s[3] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[2] &gt;&gt; 16) &amp; 0xFF];        t[3] ^= rotr32(tmp, 8);        tmp = TD[(s[1] &gt;&gt; 8) &amp; 0xFF];        t[3] ^= rotr32(tmp, 16);        tmp = TD[(s[0] &gt;&gt; 0) &amp; 0xFF];        t[3] ^= rotr32(tmp, 24);        //-------------AddRoundKey---------------        s[0] = t[0] ^ aes_key.dk[4 * i + 0];        s[1] = t[1] ^ aes_key.dk[4 * i + 1];        s[2] = t[2] ^ aes_key.dk[4 * i + 2];        s[3] = t[3] ^ aes_key.dk[4 * i + 3];    }    //------------ShiftRow + SubByte-----------    // t0    t[0] = SboxIV[(s[0] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[0] |= SboxIV[(s[3] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[0] |= SboxIV[(s[2] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[0] |= SboxIV[(s[1] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t1    t[1] = SboxIV[(s[1] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[1] |= SboxIV[(s[0] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[1] |= SboxIV[(s[3] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[1] |= SboxIV[(s[2] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t2    t[2] = SboxIV[(s[2] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[2] |= SboxIV[(s[1] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[2] |= SboxIV[(s[0] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[2] |= SboxIV[(s[3] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t3    t[3] = SboxIV[(s[3] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[3] |= SboxIV[(s[2] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[3] |= SboxIV[(s[1] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[3] |= SboxIV[(s[0] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    //------------AddRoundKey-------------    s[0] = t[0] ^ aes_key.dk[0];    s[1] = t[1] ^ aes_key.dk[1];    s[2] = t[2] ^ aes_key.dk[2];    s[3] = t[3] ^ aes_key.dk[3];    //-----------Store as BigEndian--------------    for (int i = 0; i &lt; 4; i++) {        plaintext[4 * i + 0] = (s[i] &gt;&gt; 24) &amp; 0xFF;        plaintext[4 * i + 1] = (s[i] &gt;&gt; 16) &amp; 0xFF;        plaintext[4 * i + 2] = (s[i] &gt;&gt; 8) &amp; 0xFF;        plaintext[4 * i + 3] = (s[i] &gt;&gt; 0) &amp; 0xFF;    }}int main() {    AES_Key aes_key;    // 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17    // 18 19 1a 1b 1c 1d 1e 1f    uint8_t key[256 / 8] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,                            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,                            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,                            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f };    // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff    uint8_t plaintext[16] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff };    uint8_t ciphertext[16];    //-----------AES 128-------------------    int success = AES_KeyInit(key, &amp;aes_key, 128);    if (success) {        printf(\"-----------AES 128-------------\\n\");        // 69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a        AES_Encrypt(plaintext, ciphertext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", ciphertext[i]);        }        printf(\"\\n\");        // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff        AES_Decrypt(ciphertext, plaintext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", plaintext[i]);        }        printf(\"\\n\");        AES_KeyDelete(aes_key);    }    //-----------AES 196-------------------    success = AES_KeyInit(key, &amp;aes_key, 196);    if (success) {        printf(\"-----------AES 196-------------\\n\");        // dd a9 7c a4 86 4c df e0 6e af 70 a0 ec 0d 71 91        AES_Encrypt(plaintext, ciphertext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", ciphertext[i]);        }        printf(\"\\n\");        // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff        AES_Decrypt(ciphertext, plaintext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", plaintext[i]);        }        printf(\"\\n\");        AES_KeyDelete(aes_key);    }    //------------AES 256-----------------    success = AES_KeyInit(key, &amp;aes_key, 256);    if (success) {        printf(\"-----------AES 256-------------\\n\");        // 8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89        AES_Encrypt(plaintext, ciphertext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", ciphertext[i]);        }        printf(\"\\n\");        // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff        AES_Decrypt(ciphertext, plaintext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", plaintext[i]);        }        printf(\"\\n\");        AES_KeyDelete(aes_key);    }    return 0;}\n注意点：加解密密钥在查表法aes中不同\n逆向时拿到其中一个可以推导另一个\ndk[0]  = ek[10];                     // 最后一轮密钥直接用dk[10] = ek[0];                      // 第一轮密钥直接用dk[i]  = InvMixColumns(ek[10 - i]);  // 中间轮要过一次逆MixColumns\n不需要研究透算法逻辑，只需要知道大致原理和遇到时能识别出这是aes变种就可以了\n白盒aes白盒aes算是在逆向中最常见到的了，特点是隐藏密钥。\n查表法 AES 提供了“把轮操作变成查表”的思路，白盒 AES 则利用这个查表方法隐藏密钥，\n白盒 AES 和 “查表法 AES” 算法是同一回事，可以把白盒AES看成查表AES的加强版(把密钥也混淆进表里了)，一些密码学库会在 AES_init 的时候预处理并展开 key；如果 key 是字面量，还可能在编译时进行常量计算。这样编译后的可执行文件中就没有明文 key 了。\nDFA攻击白盒aes最主要的破解方式就是dfa攻击\n我们需要的攻击条件：\n\n我们可以反汇编出源代码并调试它\n\npip install phoenixAES\n\n编译这里面的GitHub - SideChannelMarvels/Stark: Repository of small utilities related to key recovery的aes_keyschedule.c\n\n\n原理：在白盒攻击模型中，我们可以通过DBI工具（比如Frida），Debuggger（比如IDA），修改二进制文件本身 （SO patch）来实现对 中一个字节的更改，这可以称为引导、诱发一个错误。 因此差分故障攻击或差分错误攻击都是DFA合适的名字，下面修改明文中中第一个字节的值\n首先是初始轮密钥加，错误限于这一个字节\n\n然后是第一轮的字节替换，错误限于这一个字节\n\n然后是第一轮的循环左移，因为是第一行，所以没动。\n\n然后是第一轮的列混淆步骤，结果的第m行第n列的值等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和，因此结果中第一列的每一个元素都受到矩阵B（即下图左边）第一列中每个元素的影响。因而，一个字节的错误被扩散到了一整列。或者说，正常情况和故障情况在第一轮列混淆结束后，有四个字节的值不同。\n\n然后是第一轮的轮密钥加，它只作用用当前字节，不会将差异扩散出去。\n\n可以看到，在一轮循环后，一个字节的故障，被扩散到了四个字节上。继续第二轮。第二轮的字节替换\n\n第二轮的循环左移，需要注意到，虽然差异还是四个字节，但被扩散到不同的四列去了。\n\n第二轮的列混淆，每列存在的差异扩散到整列，这导致state的全部字节都与原先有差异。\n\n所以DFA攻击就是从第9轮攻击的行移位和列混淆中间更改1个数据，创造差错点，然后从最后拿到密文来分析故障结果(有四个差错点)，由于aes一次可加密16个字节，所以可以得出16种不同的故障情况，那我们就可以通过数学间的关系，把密钥反解出来\n攻击实现在调试时更改第九轮对应字节即可，明文要求输入的话直接全输入\\x00，在第9轮进行故障注入，假设正常明文(无故障)加密结果为0x8df4e9aac5c7573a27d8d055d6e4d64b\n注入时把第一个字节改为0x10,第十轮结束后结果：\n8d f4 e9 aa c5 c7 57 3a 27 d8 d0 55 d6 e4 d6 4bda f4 e9 aa c5 c7 57 c9 27 d8 53 55 d6 37 d6 4b确实有4个字节不一样。以此类推，得到16个不一样的带差错的密文\ndaf4e9aac5c757c927d85355d637d64b47f4e9aac5c7577d27d8a655d61ed64b79f4e9aac5c7572a27d89855d62ad64b30f4e9aac5c7570b27d86555d6a5d64b8d7de9aac8c7573a27d8d09ed6e4be4b8d5ce9aa43c7573a27d8d04cd6e4054b8d0de9aaddc7573a27d8d060d6e4234b8dabe9aacac7573a27d8d009d6e4484b8df48caac598573a62d8d055d6e4d6368df4bbaac5f4573acdd8d055d6e4d6938df47aaac576573ac1d8d055d6e4d61c8df444aac5c8573a23d8d055d6e4d6fb8df4e9e0c5c7b73a2768d055ade4d64b8df4e9f2c5c7063a27a4d055dfe4d64b8df4e942c5c7793a275ed05535e4d64b8df4e98fc5c7fa3a2778d055b3e4d64b\n有了这个以后我们就可以还原得到第十轮的密钥了，这里使用phoenixAES工具，先安装：\npip install phoenixAES\n#!/usr/bin/env python3import phoenixAESwith open('tracefile', 'wb') as t:    t.write(\"\"\"8df4e9aac5c7573a27d8d055d6e4d64bdaf4e9aac5c757c927d85355d637d64b47f4e9aac5c7577d27d8a655d61ed64b79f4e9aac5c7572a27d89855d62ad64b30f4e9aac5c7570b27d86555d6a5d64b8d7de9aac8c7573a27d8d09ed6e4be4b8d5ce9aa43c7573a27d8d04cd6e4054b8d0de9aaddc7573a27d8d060d6e4234b8dabe9aacac7573a27d8d009d6e4484b8df48caac598573a62d8d055d6e4d6368df4bbaac5f4573acdd8d055d6e4d6938df47aaac576573ac1d8d055d6e4d61c8df444aac5c8573a23d8d055d6e4d6fb8df4e9e0c5c7b73a2768d055ade4d64b8df4e9f2c5c7063a27a4d055dfe4d64b8df4e942c5c7793a275ed05535e4d64b8df4e98fc5c7fa3a2778d055b3e4d64b\"\"\".encode('utf8'))phoenixAES.crack_file('tracefile', [], True, False, 3)\n一共写入了17行数据到文件，其中第一行为正确的密文，剩余16行都是故障密文，最终通过crack_file即可得到第10轮密钥：\nLast round key #N found:D014F9A8C9EE2589E13F0CC8B6630CA6\n还原最初密钥：接下来用开头DFA攻击第三个工具里的aes_keyschedule.c，在本地编译后运行\n./aes_keyschedule 5D432583B2AA833FC22D53130FDA904C 10\n执行结果：\n./aes_keyschedule D014F9A8C9EE2589E13F0CC8B6630CA6 10K00: 2B7E151628AED2A6ABF7158809CF4F3CK01: A0FAFE1788542CB123A339392A6C7605K02: F2C295F27A96B9435935807A7359F67FK03: 3D80477D4716FE3E1E237E446D7A883BK04: EF44A541A8525B7FB671253BDB0BAD00K05: D4D1C6F87C839D87CAF2B8BC11F915BCK06: 6D88A37A110B3EFDDBF98641CA0093FDK07: 4E54F70E5F5FC9F384A64FB24EA6DC4FK08: EAD27321B58DBAD2312BF5607F8D292FK09: AC7766F319FADC2128D12941575C006EK10: D014F9A8C9EE2589E13F0CC8B6630CA6\n即可得到密钥为2B7E151628AED2A6ABF7158809CF4F3C\n最后附上白盒aes的实现代码，有兴趣的可以自己看一看GitHub - Nexus-TYF/Xiao-Lai-White-box-AES: A Xiao-Lai's white-box AES implementation.\nReferencehttps://zhuanlan.zhihu.com/p/42264499\n找回消失的密钥 —- DFA分析白盒AES算法 - 奋飞安全\nhttps://www.zskkk.cn/posts/15785/#%E8%BF%98%E5%8E%9F%E5%AF%86%E6%96%87\n","categories":["逆向中的密码学","对称加密基础"],"tags":["aes"]},{"title":"逆向中的DES","url":"/2025/11/13/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/des/","content":"概述：DES数据加密标准（Data Encryption Standard）是发明最早的最广泛使用的分组对称加密算法。DES 加密算法中，明文和密文为 64bit分组，也就是8字节。密钥的长度为 64 位，但是密钥的每个第八位设置为奇偶校验位，因此密钥的实际长度为56位。\n算法流程：总流程：\n\nIP置换：\n这里的置换顺序是\n原始数据的第一位变成原始数据的第58位\n原始数据的第二位变成原始数据的第50位\n….以此类推\n16轮迭代：先把上面生成的64位新数据分成左右各32位L0,R0，按下面的公式去更新数据\n\n\\begin{aligned}\n& L_i = R_{i-1} \\\\\n& R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\n\\end{aligned}\n最后生成的最后还要再交换一次\n密钥更新 ：DES算法采用了每轮子密钥生成的方式来增加密钥的复杂性和安全性。每轮子密钥都是由主密钥（64位）通过密钥调度算法（Key Schedule Algorithm）生成的。DES算法的密钥调度算法可以将64位的主密钥分成16个子密钥，每个子密钥48位，用于每轮加密中与输入数据进行异或运算。\n\n下面是上图各个函数的具体实现\n置换选择-1：\n实现了64位-&gt;56位\n从PC-1的置换表中可以看到，舍弃掉的8位数据是原始数据中每8位数据的最后一位，也就是我们所熟知的奇偶检验位。这8位被丢弃是因为它们对于密钥的安全性没有贡献，而且能够使DES算法的计算速度更快。\n然后将置换后的56bit分为各为28bit的左右两半，分别记为C0和D0\n置换选择-2：\n实现了56位-&gt;48位，满足了f函数的运算条件\n移位：在第i轮分别对Ci-1和Di-1进行左循环位移，所位移数由下表给出。\n使用这种编排，子密钥寄存器的内容经16次迭代之后又回到原来的位置\n\nf函数：轮函数由四个处理过程组成\n\nE扩展置换\n异或运算\nS替代\nP置换\n\n\nE扩展置换 :R首先被扩展成48比特，扩展过程由下表选择扩展运算E 定义，其中将R的16个比特各重复一次\n\n异或：普通异或操作\nS替代：经过S表替换输入六位bit输出4位bit\n\n使用方法\n\n对每个盒Si，其6比特输入中，第1个和第6个比 特形成一个2位二进制数，用来选择Si的四个代 换中的一个\n6比特输入中，中间4位用来选择列\n行和列选定后，得到其交叉位置的十进制数， 表示为4位二进制数即得这一S盒的输出\n\nP置换：\nP盒替换将S盒替换的32位输出作为输入，经过上述固定的替换表进行替换后即为最后F轮函数的结果。\n该结果F(R0,K0)与L0进行异或运算得到下一轮的右半部分R1\nIP-1置换：\n经过16轮迭代之后，将两边的32bit密文合并成64bit置换输入，然后使用初始逆置换表进行逆置换得到64bit密文。\nDES解密：和Feistel密码一样，DES的解密和加密使用同一算法， 但子密钥使用的顺序相反。\n\n\\begin{aligned}\nR_{i-1} &= L_i, \\\\\nL_{i-1} &= R_i \\oplus f(L_i, K_i), \\qquad i = 16,15,\\ldots,1\n\\end{aligned}解密结构与加密结构完全相同，只不过是所使用的子密钥的顺序正好相反！\n\n\\begin{aligned}\n\\text{加密子密钥：} &\\quad k_1, \\; k_2, \\; \\ldots, \\; k_{15}, \\; k_{16} \\\\[6pt]\n\\text{解密子密钥：} &\\quad k_{16}, \\; k_{15}, \\; \\ldots, \\; k_2, \\; k_1\n\\end{aligned}应用&amp;3DES：一般现在都是用改编的3DES算法来加密数据，因为之前的DES位数太少，不太安全，因此也诞生了3DES这样的算法来对DES进行加强。3DES顾名思义，就i是使用DES加密3次，使用3个密钥进行加解密。\n\n其中一次解密，两次加密的原因是，如果三个密钥相同的情况下，那相当于一次DES加密，可以兼容一些没有实现3DES的老设备\n代码实现：python版本：import binasciiclass ArrangeSimpleDES():    def __init__(self):        # 出初始化DES加密的参数        self.ip = [            58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,            62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,            57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,            61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7,        ]  # ip置换        self.ip1 = [            40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,            38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,            36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,            34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25,        ]  # 逆ip置换        self.E = [            32, 1, 2, 3, 4, 5,            4, 5, 6, 7, 8, 9,            8, 9, 10, 11, 12, 13,            12, 13, 14, 15, 16, 17,            16, 17, 18, 19, 20, 21,            20, 21, 22, 23, 24, 25,            24, 25, 26, 27, 28, 29,            28, 29, 30, 31, 32, 1,        ]  # E置换，将32位明文置换位48位        self.P = [            16, 7, 20, 21, 29, 12, 28, 17,            1, 15, 23, 26, 5, 18, 31, 10,            2, 8, 24, 14, 32, 27, 3, 9,            19, 13, 30, 6, 22, 11, 4, 25,        ]  # P置换，对经过S盒之后的数据再次进行置换        # 设置默认密钥        self.K = '0111010001101000011010010111001101101001011100110110100101110110'        self.k1 = [            57, 49, 41, 33, 25, 17, 9,            1, 58, 50, 42, 34, 26, 18,            10, 2, 59, 51, 43, 35, 27,            19, 11, 3, 60, 52, 44, 36,            63, 55, 47, 39, 31, 23, 15,            7, 62, 54, 46, 38, 30, 22,            14, 6, 61, 53, 45, 37, 29,            21, 13, 5, 28, 20, 12, 4,        ]  # 密钥的K1初始置换        self.k2 = [            14, 17, 11, 24, 1, 5, 3, 28,            15, 6, 21, 10, 23, 19, 12, 4,            26, 8, 16, 7, 27, 20, 13, 2,            41, 52, 31, 37, 47, 55, 30, 40,            51, 45, 33, 48, 44, 49, 39, 56,            34, 53, 46, 42, 50, 36, 29, 32,        ]        self.k0 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, ]  # 秘钥循环移位的位数        self.S = [            [                0xe, 0x4, 0xd, 0x1, 0x2, 0xf, 0xb, 0x8, 0x3, 0xa, 0x6, 0xc, 0x5, 0x9, 0x0, 0x7,                0x0, 0xf, 0x7, 0x4, 0xe, 0x2, 0xd, 0x1, 0xa, 0x6, 0xc, 0xb, 0x9, 0x5, 0x3, 0x8,                0x4, 0x1, 0xe, 0x8, 0xd, 0x6, 0x2, 0xb, 0xf, 0xc, 0x9, 0x7, 0x3, 0xa, 0x5, 0x0,                0xf, 0xc, 0x8, 0x2, 0x4, 0x9, 0x1, 0x7, 0x5, 0xb, 0x3, 0xe, 0xa, 0x0, 0x6, 0xd,            ],            [                0xf, 0x1, 0x8, 0xe, 0x6, 0xb, 0x3, 0x4, 0x9, 0x7, 0x2, 0xd, 0xc, 0x0, 0x5, 0xa,                0x3, 0xd, 0x4, 0x7, 0xf, 0x2, 0x8, 0xe, 0xc, 0x0, 0x1, 0xa, 0x6, 0x9, 0xb, 0x5,                0x0, 0xe, 0x7, 0xb, 0xa, 0x4, 0xd, 0x1, 0x5, 0x8, 0xc, 0x6, 0x9, 0x3, 0x2, 0xf,                0xd, 0x8, 0xa, 0x1, 0x3, 0xf, 0x4, 0x2, 0xb, 0x6, 0x7, 0xc, 0x0, 0x5, 0xe, 0x9,            ],            [                0xa, 0x0, 0x9, 0xe, 0x6, 0x3, 0xf, 0x5, 0x1, 0xd, 0xc, 0x7, 0xb, 0x4, 0x2, 0x8,                0xd, 0x7, 0x0, 0x9, 0x3, 0x4, 0x6, 0xa, 0x2, 0x8, 0x5, 0xe, 0xc, 0xb, 0xf, 0x1,                0xd, 0x6, 0x4, 0x9, 0x8, 0xf, 0x3, 0x0, 0xb, 0x1, 0x2, 0xc, 0x5, 0xa, 0xe, 0x7,                0x1, 0xa, 0xd, 0x0, 0x6, 0x9, 0x8, 0x7, 0x4, 0xf, 0xe, 0x3, 0xb, 0x5, 0x2, 0xc,            ],            [                0x7, 0xd, 0xe, 0x3, 0x0, 0x6, 0x9, 0xa, 0x1, 0x2, 0x8, 0x5, 0xb, 0xc, 0x4, 0xf,                0xd, 0x8, 0xb, 0x5, 0x6, 0xf, 0x0, 0x3, 0x4, 0x7, 0x2, 0xc, 0x1, 0xa, 0xe, 0x9,                0xa, 0x6, 0x9, 0x0, 0xc, 0xb, 0x7, 0xd, 0xf, 0x1, 0x3, 0xe, 0x5, 0x2, 0x8, 0x4,                0x3, 0xf, 0x0, 0x6, 0xa, 0x1, 0xd, 0x8, 0x9, 0x4, 0x5, 0xb, 0xc, 0x7, 0x2, 0xe,            ],            [                0x2, 0xc, 0x4, 0x1, 0x7, 0xa, 0xb, 0x6, 0x8, 0x5, 0x3, 0xf, 0xd, 0x0, 0xe, 0x9,                0xe, 0xb, 0x2, 0xc, 0x4, 0x7, 0xd, 0x1, 0x5, 0x0, 0xf, 0xa, 0x3, 0x9, 0x8, 0x6,                0x4, 0x2, 0x1, 0xb, 0xa, 0xd, 0x7, 0x8, 0xf, 0x9, 0xc, 0x5, 0x6, 0x3, 0x0, 0xe,                0xb, 0x8, 0xc, 0x7, 0x1, 0xe, 0x2, 0xd, 0x6, 0xf, 0x0, 0x9, 0xa, 0x4, 0x5, 0x3,            ],            [                0xc, 0x1, 0xa, 0xf, 0x9, 0x2, 0x6, 0x8, 0x0, 0xd, 0x3, 0x4, 0xe, 0x7, 0x5, 0xb,                0xa, 0xf, 0x4, 0x2, 0x7, 0xc, 0x9, 0x5, 0x6, 0x1, 0xd, 0xe, 0x0, 0xb, 0x3, 0x8,                0x9, 0xe, 0xf, 0x5, 0x2, 0x8, 0xc, 0x3, 0x7, 0x0, 0x4, 0xa, 0x1, 0xd, 0xb, 0x6,                0x4, 0x3, 0x2, 0xc, 0x9, 0x5, 0xf, 0xa, 0xb, 0xe, 0x1, 0x7, 0x6, 0x0, 0x8, 0xd,            ],            [                0x4, 0xb, 0x2, 0xe, 0xf, 0x0, 0x8, 0xd, 0x3, 0xc, 0x9, 0x7, 0x5, 0xa, 0x6, 0x1,                0xd, 0x0, 0xb, 0x7, 0x4, 0x9, 0x1, 0xa, 0xe, 0x3, 0x5, 0xc, 0x2, 0xf, 0x8, 0x6,                0x1, 0x4, 0xb, 0xd, 0xc, 0x3, 0x7, 0xe, 0xa, 0xf, 0x6, 0x8, 0x0, 0x5, 0x9, 0x2,                0x6, 0xb, 0xd, 0x8, 0x1, 0x4, 0xa, 0x7, 0x9, 0x5, 0x0, 0xf, 0xe, 0x2, 0x3, 0xc,            ],            [                0xd, 0x2, 0x8, 0x4, 0x6, 0xf, 0xb, 0x1, 0xa, 0x9, 0x3, 0xe, 0x5, 0x0, 0xc, 0x7,                0x1, 0xf, 0xd, 0x8, 0xa, 0x3, 0x7, 0x4, 0xc, 0x5, 0x6, 0xb, 0x0, 0xe, 0x9, 0x2,                0x7, 0xb, 0x4, 0x1, 0x9, 0xc, 0xe, 0x2, 0x0, 0x6, 0xa, 0xd, 0xf, 0x3, 0x5, 0x8,                0x2, 0x1, 0xe, 0x7, 0x4, 0xa, 0x8, 0xd, 0xf, 0xc, 0x9, 0x0, 0x3, 0x5, 0x6, 0xb,            ],        ]  # 16进制表示S盒的数据，S盒是为了将48位转换为32位，有8个盒子    def __substitution(self, table: str, self_table: list) -&gt; str:        \"\"\"        :param table: 需要进行置换的列表,是一个01字符串        :param self_table: 置换表，在__init__中初始化了        :return: 返回置换后的01字符串        \"\"\"        sub_result = \"\"        for i in self_table:            sub_result += table[i - 1]        return sub_result    def str2bin(self, string: str) -&gt; str:        \"\"\"        将明文转为二进制字符串:        :param string: 任意字符串        :return:二进制字符串        \"\"\"        plaintext_list = list(bytes(string, 'utf8'))  # 将字符串转成bytes类型，再转成list        result = []  # 定义返回结果        for num in plaintext_list:            result.append(bin(num)[2:].zfill(8))  # 将列表的每个元素转成二进制字符串，8位宽度        return \"\".join(result)    def bin2str(self, binary: str) -&gt; str:        \"\"\"        二进制字符串转成字符串        :param binary:        :return:        \"\"\"        list_bin = [binary[i:i + 8] for i in range(0, len(binary), 8)]  # 对二进制字符串进行切分，每8位为一组        list_int = []        for b in list_bin:            list_int.append(int(b, 2))  # 对二进制转成int        result = bytes(list_int).decode()  # 将列表转成bytes，在进行解码，得到字符串        return result    def __bin2int(self, binary: str) -&gt; list:        \"\"\"        由于加密之后的二进制无法直接转成字符，有不可见字符在，utf8可能无法解码，所以需要将二进制字符串每8位转成int型号列表，用于转成bytes再转hex        :param binary: 二进制字符串        :return: int型列表        \"\"\"        list_bin = [binary[i:i + 8] for i in range(0, len(binary), 8)]  # 对二进制字符串进行切分，每8位为一组        list_int = []        for b in list_bin:            list_int.append(int(b, 2))        return list_int    def __int2bin(self, list_int: list) -&gt; str:        result = []        for num in list_int:            result.append(bin(num)[2:].zfill(8))        return ''.join(result)    def __get_block_list(self, binary: str) -&gt; list:        \"\"\"        对明文二进制串进行切分，每64位为一块，DES加密以64位为一组进行加密的        :type binary: 二进制串        \"\"\"        len_binary = len(binary)        if len_binary % 64 != 0:            binary_block = binary + (\"0\" * (64 - (len_binary % 64)))            return [binary_block[i:i + 64] for i in range(0, len(binary_block), 64)]        else:            return [binary[j:j + 64] for j in range(0, len(binary), 64)]    def modify_secretkey(self):        \"\"\"        修改默认密钥函数        :return: None        \"\"\"        print('当前二进制形式密钥为:{}'.format(self.K))        print(\"当前字符串形式密钥为：{}\".format(self.bin2str(self.K)))        newkey = input(\"输入新的密钥（长度为8）：\")        if len(newkey) != 8:            print(\"密钥长度不符合，请重新输入：\")            self.modify_secretkey()        else:            bin_key = self.str2bin(newkey)            self.K = bin_key            print(\"当前二进制形式密钥为:{}\".format(self.K))    def __f_funtion(self, right: str, key: str):        \"\"\"        :param right: 明文二进制的字符串加密过程的右半段        :param key: 当前轮数的密钥        :return: 进行E扩展，与key异或操作，S盒操作后返回32位01字符串        \"\"\"        # 对right进行E扩展        e_result = self.__substitution(right, self.E)        # 与key 进行异或操作        xor_result = self.__xor_function(e_result, key)        # 进入S盒子        s_result = self.__s_box(xor_result)        # 进行P置换        p_result = self.__substitution(s_result, self.P)        return p_result    def __get_key_list(self):        \"\"\"        :return: 返回加密过程中16轮的子密钥        \"\"\"        key = self.__substitution(self.K, self.k1)        left_key = key[0:28]        right_key = key[28:56]        keys = []        for i in range(1, 17):            move = self.k0[i - 1]            move_left = left_key[move:28] + left_key[0:move]            move_right = right_key[move:28] + right_key[0:move]            left_key = move_left            right_key = move_right            move_key = left_key + right_key            ki = self.__substitution(move_key, self.k2)            keys.append(ki)        return keys    def __xor_function(self, xor1: str, xor2: str):        \"\"\"        :param xor1: 01字符串        :param xor2: 01字符串        :return: 异或操作返回的结果        \"\"\"        size = len(xor1)        result = \"\"        for i in range(0, size):            result += '0' if xor1[i] == xor2[i] else '1'        return result    def __s_box(self, xor_result: str):        \"\"\"        :param xor_result: 48位01字符串        :return: 返回32位01字符串        \"\"\"        result = \"\"        for i in range(0, 8):            # 将48位数据分为6组，循环进行            block = xor_result[i * 6:(i + 1) * 6]            line = int(block[0] + block[5], 2)            colmn = int(block[1:5], 2)            res = bin(self.S[i][line*16 + colmn])[2:]            if len(res) &lt; 4:                res = '0' * (4 - len(res)) + res            result += res        return result    def __iteration(self, bin_plaintext: str, key_list: list):        \"\"\"        :param bin_plaintext: 01字符串，64位        :param key_list: 密钥列表，共16个        :return: 进行F函数以及和left异或操作之后的字符串        \"\"\"        left = bin_plaintext[0:32]        right = bin_plaintext[32:64]        for i in range(0, 16):            next_lift = right            f_result = self.__f_funtion(right, key_list[i])            next_right = self.__xor_function(left, f_result)            left = next_lift            right = next_right        bin_plaintext_result = left + right        return bin_plaintext_result[32:] + bin_plaintext_result[:32]    def encode(self, plaintext):        \"\"\"        :param plaintext: 明文字符串        :return: 密文字符串        \"\"\"        bin_plaintext = self.str2bin(plaintext)        bin_plaintext_block = self.__get_block_list(bin_plaintext)        ciphertext_bin_list = []        key_list = self.__get_key_list()        for block in bin_plaintext_block:            # 初代ip置换            sub_ip = self.__substitution(block, self.ip)            ite_result = self.__iteration(sub_ip, key_list)            # 逆ip置换            sub_ip1 = self.__substitution(ite_result, self.ip1)            ciphertext_bin_list.append(sub_ip1)        ciphertext_bin = ''.join(ciphertext_bin_list)        result = self.__bin2int(ciphertext_bin)        return bytes(result).hex().upper()    def decode(self, ciphertext):        '''        :param ciphertext: 密文字符串        :return: 明文字符串        '''        b_ciphertext = binascii.a2b_hex(ciphertext)        bin_ciphertext = self.__int2bin(list(b_ciphertext))        bin_plaintext_list = []        key_list = self.__get_key_list()        key_list = key_list[::-1]        bin_ciphertext_block = [bin_ciphertext[i:i + 64] for i in range(0, len(bin_ciphertext), 64)]        for block in bin_ciphertext_block:            sub_ip = self.__substitution(block, self.ip)            ite = self.__iteration(sub_ip, key_list)            sub_ip1 = self.__substitution(ite, self.ip1)            bin_plaintext_list.append(sub_ip1)        bin_plaintext = ''.join(bin_plaintext_list).replace('00000000', '')        return self.bin2str(bin_plaintext)    def main(self):        select = input(\"Please selecting:\\n1、Encryption\\t 2、Decrpytion\\nYour selecting:\")        if select == '1':            plaintext = input(\"Input plaintext：\")            # print(\"Your plaintext is:{}\".format(plaintext))            ciphertext = self.encode(plaintext)            print(\"The ciphertext is:{}\".format(ciphertext))        elif select == '2':            plaintext = input(\"Input ciphertext：\")            # print(\"Your ciphertext is:{}\".format(plaintext))            plaintext = self.decode(plaintext)            print(\"The plaintext is:{}\".format(plaintext))            # print(len(plaintext))        else:            input(\"Please selecting again！\")            self.main()if __name__ == '__main__':    mydes = ArrangeSimpleDES()    mydes.modify_secretkey()    while True:        mydes.main()        print(\"\")\nc++版本：#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;windows.h&gt;using namespace std;string desKeys[20];/** *数据初始置换表 */int T1[8][8] = { 58,50,42,34,26,18,10,2,              60,52,44,36,28,20,12,4,              62,54,46,38,30,22,14,6,              64,56,48,40,32,24,16,8,              57,49,41,33,25,17,9,1,              59,51,43,35,27,19,11,3,              61,53,45,37,29,21,13,5,              63,55,47,39,31,23,15,7 };/** *密钥初始置换表 */int T2[8][7] = { 57,49,41,33,25,17,9,              1,58,50,42,34,26,18,              10,2,59,51,43,35,27,              19,11,3,60,52,44,36,              3,55,47,39,31,23,15,              7,62,54,46,38,30,22,              14,6,61,53,45,37,29,              21,13,5,28,20,12,4 };/** *密钥循环左移位数表 */int T3[16] = { 1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 };/** *密钥压缩置换表 */int T4[8][6] = { 14,17,11,24,1,5,              3,28,15,6,21,10,              23,19,12,4,26,8,              16,7,27,20,13,2,              41,52,31,37,47,55,              30,40,51,45,33,48,              44,49,39,56,34,53,              46,42,50,36,29,32 };/** *数据扩展表 */int T5[8][6] = { 32,1,2,3,4,5,              4,5,6,7,8,9,              8,9,10,11,12,13,              12,13,14,15,16,17,              16,17,18,19,20,21,              20,21,22,23,24,25,              24,25,26,27,28,29,              28,29,30,31,32,1 };/** *S盒置换表 */int S[8][4][16] = { {{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},{0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},{4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},{15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}},                {{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},{3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},{ 0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},{ 13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}},                {{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},{13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},{13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},{1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}},                {{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},{13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},{10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},{3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}},                {{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},{14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},{4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},{11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}},                {{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},{10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},{9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},{4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}},                {{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},{13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},{1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},{6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}},                {{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},{1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},{7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},{2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}} };/** *P盒置换表 */int P[4][8] = { 16,7,20,21,             29,12,28,17,             1,15,23,26,             5,18,31,10,             2,8,24,14,             32,27,3,9,             19,13,30,6,             22,11,4,25 };/** *最终置换表 */int T6[8][8] = { 40,8,48,16,56,24,64,32,                  39,7,47,15,55,23,63,31,                  38,6,46,14,54,22,62,30,                  37,5,45,13,53,21,61,29,                  36,4,44,12,52,20,60,28,                  35,3,43,11,51,19,59,27,                  34,2,42,10,50,18,58,26,                  33,1,41,9,49,17,57,25 };/** *最终置换函数 64位-&gt;64位 *函数说明：s为完成最后一轮循环得到的64为数据 *返回值为密文或明文 */string final_permutation(string s){    string rs = \"\";    for (int i = 0; i &lt; 8; i++)    {        for (int j = 0; j &lt; 8; j++)        {            rs += s[T6[i][j] - 1];        }    }    return rs;}/** *P盒置换函数 32位-&gt;32位 *函数说明：s为S盒的输出 */string P_box(string s){    string rs = \"\";    for (int i = 0; i &lt; 4; i++)    {        for (int j = 0; j &lt; 8; j++)        {            rs += (s[P[i][j] - 1]);        }    }    return rs;}/** *S盒置换函数 48位-&gt;32位 *函数说明：s为48位数据 *返回值为32位 */string S_box(string s){    string rs = \"\";    string s1;    int k1, k2;//S盒的行号和列号    int h = 1;//决定使用那个S盒    for (int i = 0; i &lt;= 42; i = i + 6, h++)    {        k1 = (s[i] - '0') * 2 + (s[i + 5] - '0') * 1;        k2 = (s[i + 1] - '0') * 8 + (s[i + 2] - '0') * 4 + (s[i + 3] - '0') * 2 + (s[i + 4] - '0') * 1;        int x = S[h - 1][k1][k2];        s1 = \"\";        int y = 8;        for (int j = 1; j &lt;= 4; j++)        {            if (x &lt; y)            {                s1 += \"0\";                y /= 2;            }            else            {                s1 += \"1\";                x = x % y;                y /= 2;            }        }        rs += s1;    }    return rs;}/** *异或运算函数 *要求位数相同 */string desXOR(string s1, string s2){    string rs = \"\";    for (int i = 0; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); i++)    {        rs += ((s1[i] - '0') ^ (s2[i] - '0')) + '0';    }    return rs;}/** *数据扩展函数 32-&gt;48 *函数说明：s为数据的右半部分 32位 *扩展成48位的输出 */string plaintext_righthalf_extended_permutation(string s){    string rs = \"\";    for (int i = 0; i &lt; 8; i++)    {        for (int j = 0; j &lt; 6; j++)        {            rs += s[T5[i][j] - 1];        }    }    return rs;}/** *密钥压缩置换函数 56位-&gt;48位 *函数说明：s为56为的密钥 *输出为48位的子密钥 */string secret_key_compression_replacement(string s){    string rs = \"\";    for (int i = 0; i &lt; 8; i++)    {        for (int j = 0; j &lt; 6; j++)        {            rs += s[T4[i][j] - 1];        }    }    return rs;}/** *密钥循环左移函数 56位-&gt;56位 *函数说明：k为左移位数 s为密钥 *返回值位数不变 */string secret_ket_left_move(int k, string s)//密钥循环左移k位{    string s1 = s.substr(0, 28);    string s2 = s.substr(28, 28);    string rs = s1.substr(k, 28 - k) + s1.substr(0, k) + s2.substr(k, 28 - k) + s2.substr(0, k);    return rs;}/** *密钥初始置换函数 64位-&gt;56位 *函数说明：s为64位的初始密钥 *返回值为56位 */string secret_key_initial_permutation(string s){    string rs = \"\";    for (int i = 0; i &lt; 8; i++)    {        for (int j = 0; j &lt; 7; j++)        {            rs += s[T2[i][j] - 1];        }    }    return rs;}/** *明文初始置换函数 64位-&gt;64位 *函数说明：s为初始明文 64位 *返回值为6位 */string plaintext_initial_permutation(string s)//明文初始置换{    string rs = \"\";    for (int i = 0; i &lt; 8; i++)    {        for (int j = 0; j &lt; 8; j++)        {            rs += s[T1[i][j] - 1];        }    }    return rs;}/** *16进制转2进制函数 *函数说明：s为16进制字符串 *返回为2进制字符串 */string des_H(string s){    string s1;    string rs = \"\";    for (int i = 0; i &lt; s.length(); i++)    {        int x;        if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')        {            x = s[i] - '0';        }        else        {            x = s[i] - 'A' + 10;        }        s1 = \"\";        int y = 8;        for (int j = 1; j &lt;= 4; j++)        {            if (x &lt; y)            {                y /= 2;                s1 += \"0\";            }            else            {                s1 += \"1\";                x = x % y;                y = y / 2;            }        }        rs += s1;    }    return rs;}/***2进制转16进制函数*str为2进制字符串*返回值为16进制字符串*/string des_G(string str){    string rs = \"\";    char temp;    for (int i = 0; i &lt;= str.length() - 4; i = i + 4)    {        int x = (str[i] - '0') * 8 + (str[i + 1] - '0') * 4 + (str[i + 2] - '0') * 2 + str[i + 3] - '0';        if (x &gt;= 10)        {            temp = (char)(x - 10 + 'A');        }        else        {            temp = (char)(x + '0');        }        rs += temp;    }    return rs;}/** *封装函数f *函数说明：接收32位数据和48位的子密钥 产生一个32位的输出 *str1:32位数据  str2:48位的子密钥 *返回值32位 */string des_f(string str1, string str2){    string expendR = plaintext_righthalf_extended_permutation(str1);    //cout&lt;&lt;\"32位数据扩展为48位结果:\"&lt;&lt;expendR&lt;&lt;endl;    string rs = desXOR(expendR, str2);    //cout&lt;&lt;\"密钥和扩展数据异或结果:\"&lt;&lt;rs&lt;&lt;endl;    rs = S_box(rs);    //cout&lt;&lt;\"S盒替代结果(48-&gt;32):\"&lt;&lt;rs&lt;&lt;endl;    rs = P_box(rs);    //cout&lt;&lt;\"P盒替代结果(32-&gt;32):\"&lt;&lt;rs&lt;&lt;endl;    return rs;}/** *子密钥生成函数 *函数说明：s为给定的密钥 *生成16个子密钥 */void des_generateKeys(string s){    s = secret_key_initial_permutation(s);    for (int i = 1; i &lt;= 16; i++)    {        s = secret_ket_left_move(T3[i - 1], s);        desKeys[i] = secret_key_compression_replacement(s);    }}/** 明文字符串转换成0/1字符串*/string des_StrToBitStr(string str){    bitset&lt;64&gt; bstr;    for (int i = 0; i &lt; 8; i++)    {        bitset&lt;8&gt; bits = bitset&lt;8&gt;(str[i]);        for (int j = 0; j &lt; 8; j++)        {            bstr[i * 8 + j] = bits[7 - j];        }    }    string s = bstr.to_string();    //添加一个翻转操作    reverse(begin(s), end(s));    return s;}/** 0/1字符串装换为字符形式的字符串*/string des_BitStrToStr(string bstr){    string str = \"\";    //每八位转化成十进制，然后将数字结果转化成字符    int sum;    for (int i = 0; i &lt; bstr.size(); i += 8)    {        sum = 0;        for (int j = 0; j &lt; 8; j++)            if (bstr[i + j] == '1')                sum = sum * 2 + 1;            else                sum = sum * 2;        str = str + char(sum);    }    return str;}string chardeel(string&amp; str1, string&amp; str2) {    string temp_str = \"\";    int divi_times = (str1.size() % 8 ? str1.size() / 8 + 1 : str1.size() / 8);        //计算分组个数     for (int i = 0; i &lt; divi_times; ++i) {                                        //每个分组单独转换成二进制串         string str1_temp = str1.substr(8 * i, 8);  //substr(start,len)         bool jude = false;        int addchar = 0;        if (str1_temp.size() % 8) {            jude = true;            addchar = 8 - str1_temp.size() % 8;        }        int sub = str1_temp.size() * 8;        if (jude) {            for (int i = 0; i &lt; addchar; ++i) {                str1_temp += 'a';            }        }        str1_temp = des_StrToBitStr(str1_temp);        if (jude) {            for (int i = 0; i &lt; addchar * 8; ++i) {                str1_temp[sub+i] = '0';            }        }        temp_str = temp_str + str1_temp;    }    str2 = des_H(str2);    return temp_str;}/** *DES加密函数 64位-&gt;64位 *函数说明：str1为64位的给定明文 *返回值为64位的密文 */string des_encrypt(string str1, string str2){    str1 = chardeel(str1, str2);  //明文分组和填充，返回01字符串     des_generateKeys(str2);  //生成16个子密钥    int divi_times = str1.size() / 64;  //分成多少组去进行des    string rs_temp = \"\";    for (int i = 0; i &lt; divi_times; ++i) {        string str1_temp = str1.substr(i * 64, 64);        //第一步:明文初始置换 64-&gt;64        str1_temp = plaintext_initial_permutation(str1_temp);        //第二步:数据分组        string left = str1_temp.substr(0, 32);        string right = str1_temp.substr(32, 32);        string newleft;        //第三步:16轮迭代        for (int i = 1; i &lt;= 16; i++)        {            newleft = right;            right = desXOR(left, des_f(right, desKeys[i]));            left = newleft;        }        //第四步:合并数据 注意位R16L16        string rs = right + left;        //结尾置换        rs = final_permutation(rs);        rs_temp = rs_temp + rs;    }    return rs_temp;}/***解密函数*str为密文*输出明文*/string des_decrypt(string str){    int divi_times = str.size() / 64;  //分成多少组去进行des    string rs_temp = \"\";    for (int i = 0; i &lt; divi_times; ++i) {        string str_temp = str.substr(i * 64, 64);        //把密文当作明文进行初始明文置换        str_temp = plaintext_initial_permutation(str_temp);        //左右分组        string left = str_temp.substr(0, 32);        string right = str_temp.substr(32, 32);        string newleft;        //逆序的子密钥使用 16轮迭代        for (int i = 16; i &gt;= 1; i--)        {            newleft = right;            right = desXOR(left, des_f(right, desKeys[i]));            left = newleft;        }        //合并        string rs = right + left;        //最后置换        rs = final_permutation(rs);        rs_temp = rs_temp + rs;    }    rs_temp = des_BitStrToStr(rs_temp);    return rs_temp;}int main(){    /*string str1 = \"abc\";    cout &lt;&lt; str1.max_size();*/    SetConsoleOutputCP(CP_UTF8);  // 设置控制台输出为 UTF-8 编码    SetConsoleCP(CP_UTF8);  // 设置控制台输入为 UTF-8 编码    string str1 = \"\";    cout &lt;&lt; \"请输入明文：\";    getline(cin, str1);    string str2 = \"\";    cout &lt;&lt; \"请输入密钥(16位):\";    getline(cin, str2);    //加密    string rs = des_encrypt(str1, str2);    cout &lt;&lt; \"密文（二进制）:\" &lt;&lt; rs &lt;&lt; endl;    //解密    rs = des_decrypt(rs);    cout &lt;&lt; \"明文（16进制）：\" &lt;&lt; rs &lt;&lt; endl;    return 0;}\nreference：密码学——AES/DES加密算法原理介绍 - 枫のBlog\n通俗易懂，十分钟读懂DES，详解DES加密算法原理，DES攻击手段以及3DES原理-CSDN博客\n","categories":["逆向中的密码学","对称加密基础"],"tags":["des"]},{"title":"分组密码的加密模式及攻击","url":"/2025/10/09/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","content":"分组密码工作模式工作模式对算法本身结构没有影响，影响的是明文密文\nECB：电子密码本模式(electronic codebook mode)\n从ECB的工作原理可以看出，如果明文数据在等分后，两块数据相同则会产生相同的加密数据块，这会辅助攻击者快速判断加密算法的工作模式，而将攻击资源聚集在破解某一块数据即可，一旦成功则意味着全文破解，大大提升了攻击效率。\n\n\\text{加密：}\\quad C_i = E_k(P_i)\n\\text{解密：}\\quad P_i = D_k(C_i)CBC：密码分组链接模式（cipher block chaining Triple）\ncbc的解密\n\nCBC模式相比ECB实现了更好的模式隐藏，但因为其将密文引入运算，加解密操作无法并行操作。同时引入的IV向量，并且还需要加、解密双方共同知晓方可。\n\nC_0 = \\text{IV}\n\\text{加密：}\\quad C_i = E_k(P_i \\oplus C_{i-1})\n\\text{解密：}\\quad P_i = D_k(C_i) \\oplus C_{i-1}CFB：密文反馈模式（Cipher FeedBack）\n与CBC模式类似，但不同的地方在于，CFB模式先生成密码流字典，然后用密码字典与明文进行异或操作并最终生成密文。后一分组的密码字典的生成需要前一分组的密文参与运算。\n\n其中s位可任意，不同s位加密结果不同，默认s是算法块规定长度，例des是64，aes是128\n\nC_0 = \\text{IV}\n\\text{加密：}\\quad O_i = E_k(C_{i-1}),\\quad C_i = P_i \\oplus O_i\n\\text{解密：}\\quad O_i = E_k(C_{i-1}),\\quad P_i = C_i \\oplus O_iOFB：输出反馈模式（Output Feedbaek）\nOFB和CFB一样，明文块可自定义长度\n\nO_0 = \\text{IV}\n\\text{生成 keystream：}\\quad O_i = E_k(O_{i-1}),\\quad S_i = O_i\n\\text{加密：}\\quad C_i = P_i \\oplus S_i\n\\text{解密：}\\quad P_i = C_i \\oplus S_iCTR：计数器模式（counter mode）\n\n\\text{令 }CTR_i = \\text{NONCE} \\,\\|\\, (\\text{counter}+i)\n\\text{加密：}\\quad S_i = E_k(CTR_i),\\quad C_i = P_i \\oplus S_i\n\\text{解密：}\\quad P_i = C_i \\oplus S_i \\quad(\\text{其中 }S_i = E_k(CTR_i))加密模式总结：\n\n\n\n模式\n全称\n优点\n缺点\n是否需 IV\n是否可并行加密\n是否可并行解密\n是否适合流加密\n\n\n\n\nECB\nElectronic Codebook\n实现简单；可并行加解密\n同块明文→同块密文，易被模式识别（最不安全）\n否\n是\n是\n否\n\n\nCBC\nCipher Block Chaining\n同块明文不同IV→不同密文；常用于文件加密\n无法并行加密；需填充；IV重用会泄密\n是\n否\n是\n否\n\n\nCFB\nCipher Feedback\n不需填充；可加密任意长度数据；适合流式\n错误传播严重；速度略慢\n是\n否\n否\n是\n\n\nOFB\nOutput Feedback\n不需填充；错误不会传播；适合流加密\n同IV下重用密钥极危险；同步要求高\n是\n是\n是\n是\n\n\nCTR\nCounter\n可随机访问块；可并行加解密；性能优\n计数器不能重用，否则致命泄密\n是（计数器）\n是\n是\n是\n\n\n\n\n加密模式攻击CBC反转字节攻击：已知密文，和明文。可以在不知道key的情况下，肆意更改明文的值，比如网站验证权限，可以把传进去的密文修改，从而使明文从’user’到’admin’，可能能绕过权限\n设A是第N-1块的密文一个字节，B是第N块密文解密后的中间值的对应部分字节，C是第N块明文对应字节，X是想要修改的字节值\n公式右边是明文变化，左边括号内是输入密文的变化\n\n\\begin{aligned}\nA \\oplus B &= C \\\\\n(A \\oplus C) \\oplus B &= 0 \\\\\n(A \\oplus C \\oplus X)\\oplus B &= X\n\\end{aligned}from Crypto.Cipher import AESimport uuidimport binasciiBS=AES.block_size  #分组长度key=b'test'  #密钥iv=uuid.uuid4().bytes  #随机初始向量pad=lambda s: s+((BS-len(s)%BS)*chr(BS-len(s)%BS)).encode()  #Pkcs5Paddingdata=b'1234567890abcdefabcdef1234567890'  #明文M#加密def enc(data):    aes=AES.new(pad(key),AES.MODE_CBC,iv)    ciphertext=aes.encrypt(pad(data))    ciphertext=binascii.b2a_hex(ciphertext)    return ciphertext#解密def dec(c):    c=binascii.a2b_hex(c)    aes=AES.new(pad(key),AES.MODE_CBC,iv)    data=aes.decrypt(c)    return data#测试CBC翻转def CBC_test(c):    c=bytearray(binascii.a2b_hex(c))    c[0]=c[0]^ord('a')^ord('A') #c[0]为第一组的密文字符，a为第二组相应位置的明文字符，A是我们想要的明文字符    c=binascii.b2a_hex(c)    return cprint(\"ciphertext:\",enc(data))print(\"data:\",dec(enc(data)))print(\"CBC Attack:\",dec(CBC_test(enc(data))))\nciphertext: b'ffa645d1b5e40afbbae47de053a66f978fa0a824e99864a7e8baf38ceccda613c304883f11fc0857c1bb7603f859798e'data: b'1234567890abcdefabcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10'CBC Attack:b':8O&lt;\\xe7\\x04\\xd8v\\xe8Q\\xfe\\xa5I\\xc9c]Abcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10'\nPadding Oracle Attack已知条件：如果明文的padding格式出错服务端会提示某个特定状态码，密文，iv(IV经常会随着密文一起发送。常见的做法是将IV作为一个前缀，附着在密文的前面)\n效果：在不清楚 key 的前提下解密任意给定的密文。\n\n原理：我们有密文，解密后的中间状态(Intermediary Value)我们不知道，爆破每个字节的iv值，当服务端不报错时，说明padding正确，如上图所示，我们知道爆破的第8个字节，就肯定直接padding为0x1,也知道我们此时爆破的iv是多少，就可以推出正确的中间状态(Intermediary Value)是多少，依次类推，把所有字节的中间状态都算出来后，就可以用初始iv异或中间状态得到明文。\n如果已知多组密文解密：从前往后进行解密\n如果已知多组明文加密：先从最后一组开始，爆破最后一组的intermediary并构造出iv，然后将本组的iv当作前一组的密文，以此类推。由此我们可以得到构造密文的步骤\n\n从最后一组开始，爆破出该组的intermediary并构造出iv，然后将本组的iv当作前一组的密文\n爆破前一组的intermediary并构造出iv，然后将本组的iv当作前一组的密文\n…\n最后会得到第一组的iv，至此我们已经构造出了所有合法密文以及iv\n\nreference:CBC字节翻转攻击&amp;Padding Oracle Attack原理解析 - 枫のBlog\n","categories":["逆向中的密码学","对称加密基础"],"tags":["aes"]},{"title":"[SCTF2019]Strange apk","url":"/2025/11/10/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%5BSCTF2019%5DStrange%20apk/","content":"前言：用一道经典安卓题练习一下脱壳\nBUUCTF在线评测\n拖进jadx发现\n\n启动类是sctf.demo.myapplication.t,但是反编译的类没有。（有android.intent.action.MAIN才是启动类）\n猜测是加壳或者别的什么需要动态抓dex的混淆方法\n动态提取/脱壳利用反射大师提取dex：在xposed模块勾选反射大师，再把我们要分析的app放在反射大师的作用域下。\n然后运行反射大师，点选中该软件。然后启动这个软件\n\n在flag报错后点六芒星，选择当前activity，然后写出dex就可以动态提取了\n分析dex先看入口函数调用了什么判断逻辑\n/* loaded from: C:\\Users\\Lenovo\\OneDrive\\Desktop\\cookie_2183120.dex */public class t extends AppCompatActivity &#123;    /* JADX INFO: Access modifiers changed from: protected */    @Override // android.support.v7.app.AppCompatActivity, android.support.v4.app.FragmentActivity, android.support.v4.app.SupportActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity);        Button bu = (Button) findViewById(R.id.button2);        bu.setOnClickListener(new View.OnClickListener() &#123; // from class: sctf.demo.myapplication.t.1            @Override // android.view.View.OnClickListener            public void onClick(View v) &#123;                Intent intent = new Intent(&quot;sctf.demo.myapplication.MAIN&quot;);                intent.addCategory(&quot;sctf.demo.myapplication.LAUNCHER&quot;);                t.this.startActivityForResult(intent, 1);            &#125;        &#125;);    &#125;\n调用流程：从 UI 点击到启动子 Activity\n用户在 t 的界面点击按钮（bu 的 onClick）。\n\nt 的 onClick 执行：\n\n\nIntent intent = new Intent(&quot;sctf.demo.myapplication.MAIN&quot;);intent.addCategory(&quot;sctf.demo.myapplication.LAUNCHER&quot;);t.this.startActivityForResult(intent, 1);\n这是隐式 Intent（action + category），由系统根据 AndroidManifest.xml 的 intent-filter 去匹配可响应的 Activity。\n在我们的 manifest 中，s（即 sctf.demo.myapplication.s）声明了相同的 action/category，所以系统会启动 s。\n关键：这里使用了 startActivityForResult(..., 1)，所以启动的是“带返回结果”的子 Activity，requestCode = 1。\n子 Activity  s 的流程这里切换到s类的oncreate()函数\npublic class s extends AppCompatActivity &#123;    /* JADX INFO: Access modifiers changed from: protected */    @Override // android.support.v7.app.AppCompatActivity, android.support.v4.app.FragmentActivity, android.support.v4.app.SupportActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button bu = (Button) findViewById(R.id.button);        findViewById(R.id.textView);        final EditText ed = (EditText) findViewById(R.id.editText);        bu.setOnClickListener(new View.OnClickListener() &#123; // from class: sctf.demo.myapplication.s.1            @Override // android.view.View.OnClickListener            public void onClick(View v) &#123;                String s1 = BuildConfig.FLAVOR;                String s2 = BuildConfig.FLAVOR;                int i = 0;                String s = ed.getText().toString();                if (s.length() == 30) &#123;                    while (i &lt; 12) &#123;                        s1 = s1 + s.charAt(i);                        i++;                    &#125;                    String s12 = f.sctf(s1);                    while (i &lt; 30) &#123;                        s2 = s2 + s.charAt(i);                        i++;                    &#125;                    if (s12.equals(&quot;c2N0ZntXM2xjMG1l&quot;)) &#123;                        Intent intent = new Intent();                        intent.putExtra(&quot;data_return&quot;, s2);                        s.this.setResult(-1, intent);                        s.this.finish();                        return;                    &#125;                    Toast.makeText(s.this.getApplicationContext(), &quot;something wrong&quot;, 1).show();                    return;                &#125;                Toast.makeText(s.this.getApplicationContext(), &quot;something wrong&quot;, 1).show();            &#125;        &#125;);    &#125;&#125;\n当 s 被启动后（用户界面），用户在 s 上输入并点击确认（s 的按钮 onClick）：\n\ns 读取输入字符串 s（ed.getText().toString()）。\n\n要求 s.length() == 30，否则 Toast(&quot;something wrong&quot;) 并返回。\n\n将输入拆成两部分：\n\ns1 = 前 12 个字符（索引 0..11）\n\ns2 = 后 18 个字符（索引 12..29）\n\n\n\n计算 s12 = f.sctf(s1)，并判断\n\n\n第一段加密比较简单，直接base64解密就可以了\nsctf&#123;W3lc0me\n回到父 Activity t：系统回调 onActivityResult补充：intent是Android程序中各组件之间进行交互的一种重要方式，一般被用来启动活动、启动服务以及发送广播等；intent在启动Activity的时候可以这时候就需要用到putExtra()方法。intent中提供一系列的putExtra()方法的重载，可以把想要传递的数据暂存在intent中，当另一个活动启动后putExtra(&quot;A&quot;, B)方法中，AB为键值对，第一个参数为键名，第二个参数为键对应的值，这个值才是真正要传递的数据。\n当 s setResult(RESULT_OK, intent) 并 finish() 后，系统会调用 t.onActivityResult(requestCode, resultCode, data)：\n这里 requestCode == 1（与启动时一致），resultCode == -1（RESULT_OK）\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;        TextView tv = (TextView) findViewById(R.id.textView2);        Button bu = (Button) findViewById(R.id.button2);        if (requestCode == 1 &amp;&amp; resultCode == -1) &#123;            String key = BuildConfig.FLAVOR;            try &#123;                MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);                md.update(&quot;syclover&quot;.getBytes());                key = new BigInteger(1, md.digest()).toString(16);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;            String str = f.encode(data.getStringExtra(&quot;data_return&quot;), key);            if (!str.equals(&quot;~8t808_8A8n848r808i8d8-8w808r8l8d8&#125;8&quot;)) &#123;                Toast.makeText(getApplicationContext(), &quot;one more step&quot;, 1).show();            &#125; else &#123;                tv.setVisibility(0);                bu.setVisibility(4);            &#125;        &#125;    &#125;&#125;\n这里有第二重比较\nkey=MD5(“syclover”) = 8bfc8af07bca146c937f283b8ec768d4\nf.encode:\npublic class f &#123;    public static String encode(String str, String key) &#123;        int s = str.length();        int c = key.length();        StringBuilder t = new StringBuilder();        for (int f = 0; f &lt; s; f++) &#123;            t.append(str.charAt(f));            t.append(key.charAt(f / c));        &#125;        return t.toString();    &#125;   &#125;\n只有当 f.encode(s2, key) 等于魔法串 ~8t808_8A8n848r808i8d8-8w808r8l8d8&#125;8 时，界面才显示成功（textView2 显示，按钮隐藏）；否则提示失败。\n由于key的长度=c=32，那encode函数里的f/c一定为0,所以魔法串里的偶数位8全部去掉就是flag\n~t0_An4r0id-w0rld&#125;\nflag:sctf{W3lc0me~t0_An4r0id-w0rld}\n","categories":["安卓逆向","安卓逆向题单"],"tags":["安卓逆向"]},{"title":"强网杯2023-dotdot复现","url":"/2025/10/12/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%BC%BA%E7%BD%91%E6%9D%AF2023-dotdot%E5%A4%8D%E7%8E%B0/","content":"AES解密：分析函数用die打开发现是.NET，用dnspy打开找到主函数\n\n其中：\nBBB是输入\nCCC是比较明文\nDDD是读取文件\nEEE是rc4加密\n这是容易看出来的，现在我们主要分析AAA是干嘛的\npublic static void AAA(byte[] aaa, byte[] bbb)        {            for (int i = 0; i &lt; 9; i++)            {                Program.GGG(aaa);                for (int j = 0; j &lt; 4; j++)                {                    uint num = Program.v11[i, 4 * j, (int)aaa[4 * j]];                    uint num2 = Program.v11[i, 4 * j + 1, (int)aaa[4 * j + 1]];                    uint num3 = Program.v11[i, 4 * j + 2, (int)aaa[4 * j + 2]];                    uint num4 = Program.v11[i, 4 * j + 3, (int)aaa[4 * j + 3]];                    uint num5 = (uint)Program.v12[i, 24 * j, (int)((num &gt;&gt; 28) &amp; 15U), (int)((num2 &gt;&gt; 28) &amp; 15U)];                    uint num6 = (uint)Program.v12[i, 24 * j + 1, (int)((num3 &gt;&gt; 28) &amp; 15U), (int)((num4 &gt;&gt; 28) &amp; 15U)];                    uint num7 = (uint)Program.v12[i, 24 * j + 2, (int)((num &gt;&gt; 24) &amp; 15U), (int)((num2 &gt;&gt; 24) &amp; 15U)];                    uint num8 = (uint)Program.v12[i, 24 * j + 3, (int)((num3 &gt;&gt; 24) &amp; 15U), (int)((num4 &gt;&gt; 24) &amp; 15U)];                    aaa[4 * j] = (byte)(((int)Program.v12[i, 24 * j + 4, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 5, (int)num7, (int)num8]);                    num5 = (uint)Program.v12[i, 24 * j + 6, (int)((num &gt;&gt; 20) &amp; 15U), (int)((num2 &gt;&gt; 20) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 7, (int)((num3 &gt;&gt; 20) &amp; 15U), (int)((num4 &gt;&gt; 20) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 8, (int)((num &gt;&gt; 16) &amp; 15U), (int)((num2 &gt;&gt; 16) &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 9, (int)((num3 &gt;&gt; 16) &amp; 15U), (int)((num4 &gt;&gt; 16) &amp; 15U)];                    aaa[4 * j + 1] = (byte)(((int)Program.v12[i, 24 * j + 10, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 11, (int)num7, (int)num8]);                    num5 = (uint)Program.v12[i, 24 * j + 12, (int)((num &gt;&gt; 12) &amp; 15U), (int)((num2 &gt;&gt; 12) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 13, (int)((num3 &gt;&gt; 12) &amp; 15U), (int)((num4 &gt;&gt; 12) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 14, (int)((num &gt;&gt; 8) &amp; 15U), (int)((num2 &gt;&gt; 8) &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 15, (int)((num3 &gt;&gt; 8) &amp; 15U), (int)((num4 &gt;&gt; 8) &amp; 15U)];                    aaa[4 * j + 2] = (byte)(((int)Program.v12[i, 24 * j + 16, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 17, (int)num7, (int)num8]);                    num5 = (uint)Program.v12[i, 24 * j + 18, (int)((num &gt;&gt; 4) &amp; 15U), (int)((num2 &gt;&gt; 4) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 19, (int)((num3 &gt;&gt; 4) &amp; 15U), (int)((num4 &gt;&gt; 4) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 20, (int)(num &amp; 15U), (int)(num2 &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 21, (int)(num3 &amp; 15U), (int)(num4 &amp; 15U)];                    aaa[4 * j + 3] = (byte)(((int)Program.v12[i, 24 * j + 22, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 23, (int)num7, (int)num8]);                    num = Program.v13[i, 4 * j, (int)aaa[4 * j]];                    num2 = Program.v13[i, 4 * j + 1, (int)aaa[4 * j + 1]];                    num3 = Program.v13[i, 4 * j + 2, (int)aaa[4 * j + 2]];                    num4 = Program.v13[i, 4 * j + 3, (int)aaa[4 * j + 3]];                    num5 = (uint)Program.v12[i, 24 * j, (int)((num &gt;&gt; 28) &amp; 15U), (int)((num2 &gt;&gt; 28) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 1, (int)((num3 &gt;&gt; 28) &amp; 15U), (int)((num4 &gt;&gt; 28) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 2, (int)((num &gt;&gt; 24) &amp; 15U), (int)((num2 &gt;&gt; 24) &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 3, (int)((num3 &gt;&gt; 24) &amp; 15U), (int)((num4 &gt;&gt; 24) &amp; 15U)];                    aaa[4 * j] = (byte)(((int)Program.v12[i, 24 * j + 4, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 5, (int)num7, (int)num8]);                    num5 = (uint)Program.v12[i, 24 * j + 6, (int)((num &gt;&gt; 20) &amp; 15U), (int)((num2 &gt;&gt; 20) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 7, (int)((num3 &gt;&gt; 20) &amp; 15U), (int)((num4 &gt;&gt; 20) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 8, (int)((num &gt;&gt; 16) &amp; 15U), (int)((num2 &gt;&gt; 16) &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 9, (int)((num3 &gt;&gt; 16) &amp; 15U), (int)((num4 &gt;&gt; 16) &amp; 15U)];                    aaa[4 * j + 1] = (byte)(((int)Program.v12[i, 24 * j + 10, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 11, (int)num7, (int)num8]);                    num5 = (uint)Program.v12[i, 24 * j + 12, (int)((num &gt;&gt; 12) &amp; 15U), (int)((num2 &gt;&gt; 12) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 13, (int)((num3 &gt;&gt; 12) &amp; 15U), (int)((num4 &gt;&gt; 12) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 14, (int)((num &gt;&gt; 8) &amp; 15U), (int)((num2 &gt;&gt; 8) &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 15, (int)((num3 &gt;&gt; 8) &amp; 15U), (int)((num4 &gt;&gt; 8) &amp; 15U)];                    aaa[4 * j + 2] = (byte)(((int)Program.v12[i, 24 * j + 16, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 17, (int)num7, (int)num8]);                    num5 = (uint)Program.v12[i, 24 * j + 18, (int)((num &gt;&gt; 4) &amp; 15U), (int)((num2 &gt;&gt; 4) &amp; 15U)];                    num6 = (uint)Program.v12[i, 24 * j + 19, (int)((num3 &gt;&gt; 4) &amp; 15U), (int)((num4 &gt;&gt; 4) &amp; 15U)];                    num7 = (uint)Program.v12[i, 24 * j + 20, (int)(num &amp; 15U), (int)(num2 &amp; 15U)];                    num8 = (uint)Program.v12[i, 24 * j + 21, (int)(num3 &amp; 15U), (int)(num4 &amp; 15U)];                    aaa[4 * j + 3] = (byte)(((int)Program.v12[i, 24 * j + 22, (int)num5, (int)num6] &lt;&lt; 4) | (int)Program.v12[i, 24 * j + 23, (int)num7, (int)num8]);                }            }            Program.GGG(aaa);            for (int k = 0; k &lt; 16; k++)            {                aaa[k] = Program.v14[9, k, (int)aaa[k]];            }            for (int l = 0; l &lt; 16; l++)            {                bbb[l] = aaa[l];            }        }\n其中的GGG：\npublic static void GGG(byte[] v16)        {            byte[] array = new byte[16];            uint[] array2 = new uint[]            {                0U, 5U, 10U, 15U, 4U, 9U, 14U, 3U, 8U, 13U,                2U, 7U, 12U, 1U, 6U, 11U            };            for (int i = 0; i &lt; 16; i++)            {                array[i] = v16[(int)array2[i]];            }            array.CopyTo(v16, 0);        }\nGGG很明显就是AES中的行移位操作\n现在对比一下aes查表法代码和这个aaa\nvoid AES_Encrypt(uint8_t* plaintext, uint8_t* ciphertext, AES_Key aes_key) {    uint32_t s[4];    uint32_t t[4];    uint32_t tmp;    //------------Load as BigEndian------------------    for (int i = 0; i &lt; 4; i++) {        s[i] = (plaintext[4 * i + 0] &lt;&lt; 24) | (plaintext[4 * i + 1] &lt;&lt; 16) |            (plaintext[4 * i + 2] &lt;&lt; 8) | (plaintext[4 * i + 3]);    }    //----------------AddRoundKey----------------    s[0] ^= aes_key.ek[0];    s[1] ^= aes_key.ek[1];    s[2] ^= aes_key.ek[2];    s[3] ^= aes_key.ek[3];    for (int i = 1; i &lt; aes_key.nr; i++) {        //-------ShiftRow + SubByte + MixCol-------------        // t0        t[0] = TE[(s[0] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[1] &gt;&gt; 16) &amp; 0xFF];        t[0] ^= rotr32(tmp, 8);        tmp = TE[(s[2] &gt;&gt; 8) &amp; 0xFF];        t[0] ^= rotr32(tmp, 16);        tmp = TE[(s[3] &gt;&gt; 0) &amp; 0xFF];        t[0] ^= rotr32(tmp, 24);        // t1        t[1] = TE[(s[1] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[2] &gt;&gt; 16) &amp; 0xFF];        t[1] ^= rotr32(tmp, 8);        tmp = TE[(s[3] &gt;&gt; 8) &amp; 0xFF];        t[1] ^= rotr32(tmp, 16);        tmp = TE[(s[0] &gt;&gt; 0) &amp; 0xFF];        t[1] ^= rotr32(tmp, 24);        // t2        t[2] = TE[(s[2] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[3] &gt;&gt; 16) &amp; 0xFF];        t[2] ^= rotr32(tmp, 8);        tmp = TE[(s[0] &gt;&gt; 8) &amp; 0xFF];        t[2] ^= rotr32(tmp, 16);        tmp = TE[(s[1] &gt;&gt; 0) &amp; 0xFF];        t[2] ^= rotr32(tmp, 24);        // t3        t[3] = TE[(s[3] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[0] &gt;&gt; 16) &amp; 0xFF];        t[3] ^= rotr32(tmp, 8);        tmp = TE[(s[1] &gt;&gt; 8) &amp; 0xFF];        t[3] ^= rotr32(tmp, 16);        tmp = TE[(s[2] &gt;&gt; 0) &amp; 0xFF];        t[3] ^= rotr32(tmp, 24);        //-------------AddRoundKey---------------        s[0] = t[0] ^ aes_key.ek[4 * i + 0];        s[1] = t[1] ^ aes_key.ek[4 * i + 1];        s[2] = t[2] ^ aes_key.ek[4 * i + 2];        s[3] = t[3] ^ aes_key.ek[4 * i + 3];    }    //------------ShiftRow + SubByte-----------    // t0    t[0] = Sbox[(s[0] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[0] |= Sbox[(s[1] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[0] |= Sbox[(s[2] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[0] |= Sbox[(s[3] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t1    t[1] = Sbox[(s[1] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[1] |= Sbox[(s[2] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[1] |= Sbox[(s[3] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[1] |= Sbox[(s[0] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t2    t[2] = Sbox[(s[2] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[2] |= Sbox[(s[3] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[2] |= Sbox[(s[0] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[2] |= Sbox[(s[1] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t3    t[3] = Sbox[(s[3] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[3] |= Sbox[(s[0] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[3] |= Sbox[(s[1] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[3] |= Sbox[(s[2] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    //------------AddRoundKey-------------    s[0] = t[0] ^ aes_key.ek[4 * aes_key.nr + 0];    s[1] = t[1] ^ aes_key.ek[4 * aes_key.nr + 1];    s[2] = t[2] ^ aes_key.ek[4 * aes_key.nr + 2];    s[3] = t[3] ^ aes_key.ek[4 * aes_key.nr + 3];    //-----------Store as BigEndian--------------    for (int i = 0; i &lt; 4; i++) {        ciphertext[4 * i + 0] = (s[i] &gt;&gt; 24) &amp; 0xFF;        ciphertext[4 * i + 1] = (s[i] &gt;&gt; 16) &amp; 0xFF;        ciphertext[4 * i + 2] = (s[i] &gt;&gt; 8) &amp; 0xFF;        ciphertext[4 * i + 3] = (s[i] &gt;&gt; 0) &amp; 0xFF;    }}\n轮数和加解密位数都能对的上，又因为这函数传入参数没有密钥，这时候我们可以猜这是白盒AES。\n先创建一个c#文件，运行调试一下这个代码拿到密钥：\n先创建c#项目\ndotnet new console -n testcd test\n写入c#代码：\nusing System;using System.Collections.Generic;using System.Text;using System.IO;public class Program{        //v11,v12,v13,v14太长省略    public static void GGG(byte[] v16)    {        byte[] array = new byte[16];        uint[] array2 = new uint[16]        {        0u, 5u, 10u, 15u, 4u, 9u, 14u, 3u, 8u, 13u,        2u, 7u, 12u, 1u, 6u, 11u        };        for (int i = 0; i &lt; 16; i++)        {            array[i] = v16[array2[i]];        }        array.CopyTo(v16, 0);    }    public static void AAA(byte[] aaa, byte[] bbb)    {        for (int index1 = 0; index1 &lt; 9; ++index1)        {            if (index1 == 8)            {                // 输出：第9轮开始前的 state（16 字节）——16 字节一行 hex                StringBuilder sb = new StringBuilder();                for (int i = 0; i &lt; 16; i++)                    sb.AppendFormat(\"{0:X2}\", aaa[i]);                Console.WriteLine($\"ROUND9_BEFORE:{sb.ToString()}\");                // 如果想同时看到 GGG(permute) 后的状态，也可在下面再打印一次（在 Program.GGG(aaa) 之后）            }            Program.GGG(aaa);            for (int index2 = 0; index2 &lt; 4; ++index2)            {                uint num1 = Program.v11[index1, 4 * index2, (int)aaa[4 * index2]];                uint num2 = Program.v11[index1, 4 * index2 + 1, (int)aaa[4 * index2 + 1]];                uint num3 = Program.v11[index1, 4 * index2 + 2, (int)aaa[4 * index2 + 2]];                uint num4 = Program.v11[index1, 4 * index2 + 3, (int)aaa[4 * index2 + 3]];                uint index3 = (uint)Program.v12[index1, 24 * index2, (int)(num1 &gt;&gt; 28) &amp; 15, (int)(num2 &gt;&gt; 28) &amp; 15];                uint index4 = (uint)Program.v12[index1, 24 * index2 + 1, (int)(num3 &gt;&gt; 28) &amp; 15, (int)(num4 &gt;&gt; 28) &amp; 15];                uint index5 = (uint)Program.v12[index1, 24 * index2 + 2, (int)(num1 &gt;&gt; 24) &amp; 15, (int)(num2 &gt;&gt; 24) &amp; 15];                uint index6 = (uint)Program.v12[index1, 24 * index2 + 3, (int)(num3 &gt;&gt; 24) &amp; 15, (int)(num4 &gt;&gt; 24) &amp; 15];                aaa[4 * index2] = (byte)((uint)Program.v12[index1, 24 * index2 + 4, (int)index3, (int)index4] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 5, (int)index5, (int)index6]);                uint index7 = (uint)Program.v12[index1, 24 * index2 + 6, (int)(num1 &gt;&gt; 20) &amp; 15, (int)(num2 &gt;&gt; 20) &amp; 15];                uint index8 = (uint)Program.v12[index1, 24 * index2 + 7, (int)(num3 &gt;&gt; 20) &amp; 15, (int)(num4 &gt;&gt; 20) &amp; 15];                uint index9 = (uint)Program.v12[index1, 24 * index2 + 8, (int)(num1 &gt;&gt; 16) &amp; 15, (int)(num2 &gt;&gt; 16) &amp; 15];                uint index10 = (uint)Program.v12[index1, 24 * index2 + 9, (int)(num3 &gt;&gt; 16) &amp; 15, (int)(num4 &gt;&gt; 16) &amp; 15];                aaa[4 * index2 + 1] = (byte)((uint)Program.v12[index1, 24 * index2 + 10, (int)index7, (int)index8] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 11, (int)index9, (int)index10]);                uint index11 = (uint)Program.v12[index1, 24 * index2 + 12, (int)(num1 &gt;&gt; 12) &amp; 15, (int)(num2 &gt;&gt; 12) &amp; 15];                uint index12 = (uint)Program.v12[index1, 24 * index2 + 13, (int)(num3 &gt;&gt; 12) &amp; 15, (int)(num4 &gt;&gt; 12) &amp; 15];                uint index13 = (uint)Program.v12[index1, 24 * index2 + 14, (int)(num1 &gt;&gt; 8) &amp; 15, (int)(num2 &gt;&gt; 8) &amp; 15];                uint index14 = (uint)Program.v12[index1, 24 * index2 + 15, (int)(num3 &gt;&gt; 8) &amp; 15, (int)(num4 &gt;&gt; 8) &amp; 15];                aaa[4 * index2 + 2] = (byte)((uint)Program.v12[index1, 24 * index2 + 16, (int)index11, (int)index12] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 17, (int)index13, (int)index14]);                uint index15 = (uint)Program.v12[index1, 24 * index2 + 18, (int)(num1 &gt;&gt; 4) &amp; 15, (int)(num2 &gt;&gt; 4) &amp; 15];                uint index16 = (uint)Program.v12[index1, 24 * index2 + 19, (int)(num3 &gt;&gt; 4) &amp; 15, (int)(num4 &gt;&gt; 4) &amp; 15];                uint index17 = (uint)Program.v12[index1, 24 * index2 + 20, (int)num1 &amp; 15, (int)num2 &amp; 15];                uint index18 = (uint)Program.v12[index1, 24 * index2 + 21, (int)num3 &amp; 15, (int)num4 &amp; 15];                aaa[4 * index2 + 3] = (byte)((uint)Program.v12[index1, 24 * index2 + 22, (int)index15, (int)index16] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 23, (int)index17, (int)index18]);                uint num5 = Program.v13[index1, 4 * index2, (int)aaa[4 * index2]];                uint num6 = Program.v13[index1, 4 * index2 + 1, (int)aaa[4 * index2 + 1]];                uint num7 = Program.v13[index1, 4 * index2 + 2, (int)aaa[4 * index2 + 2]];                uint num8 = Program.v13[index1, 4 * index2 + 3, (int)aaa[4 * index2 + 3]];                uint index19 = (uint)Program.v12[index1, 24 * index2, (int)(num5 &gt;&gt; 28) &amp; 15, (int)(num6 &gt;&gt; 28) &amp; 15];                uint index20 = (uint)Program.v12[index1, 24 * index2 + 1, (int)(num7 &gt;&gt; 28) &amp; 15, (int)(num8 &gt;&gt; 28) &amp; 15];                uint index21 = (uint)Program.v12[index1, 24 * index2 + 2, (int)(num5 &gt;&gt; 24) &amp; 15, (int)(num6 &gt;&gt; 24) &amp; 15];                uint index22 = (uint)Program.v12[index1, 24 * index2 + 3, (int)(num7 &gt;&gt; 24) &amp; 15, (int)(num8 &gt;&gt; 24) &amp; 15];                aaa[4 * index2] = (byte)((uint)Program.v12[index1, 24 * index2 + 4, (int)index19, (int)index20] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 5, (int)index21, (int)index22]);                uint index23 = (uint)Program.v12[index1, 24 * index2 + 6, (int)(num5 &gt;&gt; 20) &amp; 15, (int)(num6 &gt;&gt; 20) &amp; 15];                uint index24 = (uint)Program.v12[index1, 24 * index2 + 7, (int)(num7 &gt;&gt; 20) &amp; 15, (int)(num8 &gt;&gt; 20) &amp; 15];                uint index25 = (uint)Program.v12[index1, 24 * index2 + 8, (int)(num5 &gt;&gt; 16) &amp; 15, (int)(num6 &gt;&gt; 16) &amp; 15];                uint index26 = (uint)Program.v12[index1, 24 * index2 + 9, (int)(num7 &gt;&gt; 16) &amp; 15, (int)(num8 &gt;&gt; 16) &amp; 15];                aaa[4 * index2 + 1] = (byte)((uint)Program.v12[index1, 24 * index2 + 10, (int)index23, (int)index24] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 11, (int)index25, (int)index26]);                uint index27 = (uint)Program.v12[index1, 24 * index2 + 12, (int)(num5 &gt;&gt; 12) &amp; 15, (int)(num6 &gt;&gt; 12) &amp; 15];                uint index28 = (uint)Program.v12[index1, 24 * index2 + 13, (int)(num7 &gt;&gt; 12) &amp; 15, (int)(num8 &gt;&gt; 12) &amp; 15];                uint index29 = (uint)Program.v12[index1, 24 * index2 + 14, (int)(num5 &gt;&gt; 8) &amp; 15, (int)(num6 &gt;&gt; 8) &amp; 15];                uint index30 = (uint)Program.v12[index1, 24 * index2 + 15, (int)(num7 &gt;&gt; 8) &amp; 15, (int)(num8 &gt;&gt; 8) &amp; 15];                aaa[4 * index2 + 2] = (byte)((uint)Program.v12[index1, 24 * index2 + 16, (int)index27, (int)index28] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 17, (int)index29, (int)index30]);                uint index31 = (uint)Program.v12[index1, 24 * index2 + 18, (int)(num5 &gt;&gt; 4) &amp; 15, (int)(num6 &gt;&gt; 4) &amp; 15];                uint index32 = (uint)Program.v12[index1, 24 * index2 + 19, (int)(num7 &gt;&gt; 4) &amp; 15, (int)(num8 &gt;&gt; 4) &amp; 15];                uint index33 = (uint)Program.v12[index1, 24 * index2 + 20, (int)num5 &amp; 15, (int)num6 &amp; 15];                uint index34 = (uint)Program.v12[index1, 24 * index2 + 21, (int)num7 &amp; 15, (int)num8 &amp; 15];                aaa[4 * index2 + 3] = (byte)((uint)Program.v12[index1, 24 * index2 + 22, (int)index31, (int)index32] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 23, (int)index33, (int)index34]);            }        }        Program.GGG(aaa);        for (int index = 0; index &lt; 16; ++index)            aaa[index] = Program.v14[9, index, (int)aaa[index]];        for (int index = 0; index &lt; 16; ++index)            bbb[index] = aaa[index];    }    private static void Main(string[] args)        {            HashSet&lt;String&gt; hashset = new HashSet&lt;String&gt;();            Random rand = new Random();            byte[] aaa = new byte[16];            byte[] numArray2 = new byte[16];            Array.Clear((Array)aaa, 0, 16);        Program.AAA(aaa, numArray2);        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 16; i++)        {            sb.AppendFormat(\"{0:X2}\", aaa[i]);        }        Console.WriteLine($\"TRUEKEY:{sb.ToString()}\");        }}\n解密密钥运行：\ndotnet run Program.cs\n拿到第九轮加密之前的值和正确加密的结果：\nROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ans:EB95719A7C696EAABE11F4D47360E913\n然后第一轮输入0x00,在第9轮16个字节依次置为0x00(原第9次加密前无0x00)：\n得到16次输出：\nusing System;using System.Collections.Generic;using System.Text;using System.IO;public class Program{            public static void GGG(byte[] v16)    {        byte[] array = new byte[16];        uint[] array2 = new uint[16]        {        0u, 5u, 10u, 15u, 4u, 9u, 14u, 3u, 8u, 13u,        2u, 7u, 12u, 1u, 6u, 11u        };        for (int i = 0; i &lt; 16; i++)        {            array[i] = v16[array2[i]];        }        array.CopyTo(v16, 0);    }    public static void AAA(byte[] aaa, byte[] bbb, int randIndx, byte randByte)    {        for (int index1 = 0; index1 &lt; 9; ++index1)        {            if (index1 == 8)            {                // 输出：第9轮开始前的 state（16 字节）——32 个 hex 字符一行                StringBuilder sb = new StringBuilder();                for (int i = 0; i &lt; 16; i++)                    sb.AppendFormat(\"{0:X2}\", aaa[i]);                string round9Hex = sb.ToString();                Console.WriteLine($\"ROUND9_BEFORE:{round9Hex}\");                // 也把 round9 前的状态追加到文件（附带时间戳），便于离线分析                try                {                    File.AppendAllText(\"round9_states.txt\", $\"{DateTime.UtcNow:O},{round9Hex}\\n\");                }                catch { /* 忽略写文件错误 */ }                // 在打印后再做注入（如果需要注入）                if (randIndx != -1)                    aaa[randIndx] = randByte;            }            Program.GGG(aaa);            for (int index2 = 0; index2 &lt; 4; ++index2)            {                uint num1 = Program.v11[index1, 4 * index2, (int)aaa[4 * index2]];                uint num2 = Program.v11[index1, 4 * index2 + 1, (int)aaa[4 * index2 + 1]];                uint num3 = Program.v11[index1, 4 * index2 + 2, (int)aaa[4 * index2 + 2]];                uint num4 = Program.v11[index1, 4 * index2 + 3, (int)aaa[4 * index2 + 3]];                uint index3 = (uint)Program.v12[index1, 24 * index2, (int)(num1 &gt;&gt; 28) &amp; 15, (int)(num2 &gt;&gt; 28) &amp; 15];                uint index4 = (uint)Program.v12[index1, 24 * index2 + 1, (int)(num3 &gt;&gt; 28) &amp; 15, (int)(num4 &gt;&gt; 28) &amp; 15];                uint index5 = (uint)Program.v12[index1, 24 * index2 + 2, (int)(num1 &gt;&gt; 24) &amp; 15, (int)(num2 &gt;&gt; 24) &amp; 15];                uint index6 = (uint)Program.v12[index1, 24 * index2 + 3, (int)(num3 &gt;&gt; 24) &amp; 15, (int)(num4 &gt;&gt; 24) &amp; 15];                aaa[4 * index2] = (byte)((uint)Program.v12[index1, 24 * index2 + 4, (int)index3, (int)index4] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 5, (int)index5, (int)index6]);                uint index7 = (uint)Program.v12[index1, 24 * index2 + 6, (int)(num1 &gt;&gt; 20) &amp; 15, (int)(num2 &gt;&gt; 20) &amp; 15];                uint index8 = (uint)Program.v12[index1, 24 * index2 + 7, (int)(num3 &gt;&gt; 20) &amp; 15, (int)(num4 &gt;&gt; 20) &amp; 15];                uint index9 = (uint)Program.v12[index1, 24 * index2 + 8, (int)(num1 &gt;&gt; 16) &amp; 15, (int)(num2 &gt;&gt; 16) &amp; 15];                uint index10 = (uint)Program.v12[index1, 24 * index2 + 9, (int)(num3 &gt;&gt; 16) &amp; 15, (int)(num4 &gt;&gt; 16) &amp; 15];                aaa[4 * index2 + 1] = (byte)((uint)Program.v12[index1, 24 * index2 + 10, (int)index7, (int)index8] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 11, (int)index9, (int)index10]);                uint index11 = (uint)Program.v12[index1, 24 * index2 + 12, (int)(num1 &gt;&gt; 12) &amp; 15, (int)(num2 &gt;&gt; 12) &amp; 15];                uint index12 = (uint)Program.v12[index1, 24 * index2 + 13, (int)(num3 &gt;&gt; 12) &amp; 15, (int)(num4 &gt;&gt; 12) &amp; 15];                uint index13 = (uint)Program.v12[index1, 24 * index2 + 14, (int)(num1 &gt;&gt; 8) &amp; 15, (int)(num2 &gt;&gt; 8) &amp; 15];                uint index14 = (uint)Program.v12[index1, 24 * index2 + 15, (int)(num3 &gt;&gt; 8) &amp; 15, (int)(num4 &gt;&gt; 8) &amp; 15];                aaa[4 * index2 + 2] = (byte)((uint)Program.v12[index1, 24 * index2 + 16, (int)index11, (int)index12] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 17, (int)index13, (int)index14]);                uint index15 = (uint)Program.v12[index1, 24 * index2 + 18, (int)(num1 &gt;&gt; 4) &amp; 15, (int)(num2 &gt;&gt; 4) &amp; 15];                uint index16 = (uint)Program.v12[index1, 24 * index2 + 19, (int)(num3 &gt;&gt; 4) &amp; 15, (int)(num4 &gt;&gt; 4) &amp; 15];                uint index17 = (uint)Program.v12[index1, 24 * index2 + 20, (int)num1 &amp; 15, (int)num2 &amp; 15];                uint index18 = (uint)Program.v12[index1, 24 * index2 + 21, (int)num3 &amp; 15, (int)num4 &amp; 15];                aaa[4 * index2 + 3] = (byte)((uint)Program.v12[index1, 24 * index2 + 22, (int)index15, (int)index16] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 23, (int)index17, (int)index18]);                uint num5 = Program.v13[index1, 4 * index2, (int)aaa[4 * index2]];                uint num6 = Program.v13[index1, 4 * index2 + 1, (int)aaa[4 * index2 + 1]];                uint num7 = Program.v13[index1, 4 * index2 + 2, (int)aaa[4 * index2 + 2]];                uint num8 = Program.v13[index1, 4 * index2 + 3, (int)aaa[4 * index2 + 3]];                uint index19 = (uint)Program.v12[index1, 24 * index2, (int)(num5 &gt;&gt; 28) &amp; 15, (int)(num6 &gt;&gt; 28) &amp; 15];                uint index20 = (uint)Program.v12[index1, 24 * index2 + 1, (int)(num7 &gt;&gt; 28) &amp; 15, (int)(num8 &gt;&gt; 28) &amp; 15];                uint index21 = (uint)Program.v12[index1, 24 * index2 + 2, (int)(num5 &gt;&gt; 24) &amp; 15, (int)(num6 &gt;&gt; 24) &amp; 15];                uint index22 = (uint)Program.v12[index1, 24 * index2 + 3, (int)(num7 &gt;&gt; 24) &amp; 15, (int)(num8 &gt;&gt; 24) &amp; 15];                aaa[4 * index2] = (byte)((uint)Program.v12[index1, 24 * index2 + 4, (int)index19, (int)index20] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 5, (int)index21, (int)index22]);                uint index23 = (uint)Program.v12[index1, 24 * index2 + 6, (int)(num5 &gt;&gt; 20) &amp; 15, (int)(num6 &gt;&gt; 20) &amp; 15];                uint index24 = (uint)Program.v12[index1, 24 * index2 + 7, (int)(num7 &gt;&gt; 20) &amp; 15, (int)(num8 &gt;&gt; 20) &amp; 15];                uint index25 = (uint)Program.v12[index1, 24 * index2 + 8, (int)(num5 &gt;&gt; 16) &amp; 15, (int)(num6 &gt;&gt; 16) &amp; 15];                uint index26 = (uint)Program.v12[index1, 24 * index2 + 9, (int)(num7 &gt;&gt; 16) &amp; 15, (int)(num8 &gt;&gt; 16) &amp; 15];                aaa[4 * index2 + 1] = (byte)((uint)Program.v12[index1, 24 * index2 + 10, (int)index23, (int)index24] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 11, (int)index25, (int)index26]);                uint index27 = (uint)Program.v12[index1, 24 * index2 + 12, (int)(num5 &gt;&gt; 12) &amp; 15, (int)(num6 &gt;&gt; 12) &amp; 15];                uint index28 = (uint)Program.v12[index1, 24 * index2 + 13, (int)(num7 &gt;&gt; 12) &amp; 15, (int)(num8 &gt;&gt; 12) &amp; 15];                uint index29 = (uint)Program.v12[index1, 24 * index2 + 14, (int)(num5 &gt;&gt; 8) &amp; 15, (int)(num6 &gt;&gt; 8) &amp; 15];                uint index30 = (uint)Program.v12[index1, 24 * index2 + 15, (int)(num7 &gt;&gt; 8) &amp; 15, (int)(num8 &gt;&gt; 8) &amp; 15];                aaa[4 * index2 + 2] = (byte)((uint)Program.v12[index1, 24 * index2 + 16, (int)index27, (int)index28] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 17, (int)index29, (int)index30]);                uint index31 = (uint)Program.v12[index1, 24 * index2 + 18, (int)(num5 &gt;&gt; 4) &amp; 15, (int)(num6 &gt;&gt; 4) &amp; 15];                uint index32 = (uint)Program.v12[index1, 24 * index2 + 19, (int)(num7 &gt;&gt; 4) &amp; 15, (int)(num8 &gt;&gt; 4) &amp; 15];                uint index33 = (uint)Program.v12[index1, 24 * index2 + 20, (int)num5 &amp; 15, (int)num6 &amp; 15];                uint index34 = (uint)Program.v12[index1, 24 * index2 + 21, (int)num7 &amp; 15, (int)num8 &amp; 15];                aaa[4 * index2 + 3] = (byte)((uint)Program.v12[index1, 24 * index2 + 22, (int)index31, (int)index32] &lt;&lt; 4 | (uint)Program.v12[index1, 24 * index2 + 23, (int)index33, (int)index34]);            }        }        Program.GGG(aaa);        for (int index = 0; index &lt; 16; ++index)            aaa[index] = Program.v14[9, index, (int)aaa[index]];        for (int index = 0; index &lt; 16; ++index)            bbb[index] = aaa[index];    }    private static void Main(string[] args)    {        Random rand = new Random();        int targetIndex = 0; // 默认注入字节位置 0。你可以修改为 0..15 或用循环收集多位置样本。        int pairsToCollect = 16; // 你提到做 16 次攻击，保留为16；需要更多样本可增大        using (StreamWriter sw = new StreamWriter(\"pairs.txt\"))        {            for (int i = 0; i &lt; pairsToCollect; i++)            {                // 这里我们使用全零明文（你可以改为随机或指定的明文）                byte[] plain = new byte[16];                Array.Clear(plain, 0, 16);                // 生成无故障密文                byte[] state1 = new byte[16];                byte[] ct1 = new byte[16];                Array.Clear(state1, 0, 16);                Program.AAA(state1, ct1, -1, 0); // 无故障                string sct1 = BitConverter.ToString(ct1).Replace(\"-\", \"\");                // 生成有故障密文（在第9轮注入）                byte faultByte = 0x00; // 按你要求每次改为 0x00                byte[] state2 = new byte[16];                byte[] ct2 = new byte[16];                Array.Clear(state2, 0, 16);                Program.AAA(state2, ct2, targetIndex, faultByte); // 注入故障到 targetIndex                string sct2 = BitConverter.ToString(ct2).Replace(\"-\", \"\");                string plainHex = BitConverter.ToString(plain).Replace(\"-\", \"\");                sw.WriteLine($\"{plainHex},{sct1},{sct2},{targetIndex:X2},{faultByte:X2}\");                Console.WriteLine($\"PAIR {i}: CT={sct1} FCT={sct2} idx={targetIndex} fb={faultByte:X2}\");                // 可选：每次采集后移动 targetIndex 到下一个字节，便于收集全部16字节的单字节故障                targetIndex = (targetIndex + 1) % 16;            }        }        Console.WriteLine(\"Finished. pairs.txt written. Also check round9_states.txt for ROUND9_BEFORE logs.\");    }}\nROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 0: CT=EB95719A7C696EAABE11F4D47360E913 FCT=6B95719A7C696E74BE1147D473AFE913 idx=0 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 1: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95717F7C6924AABE4DF4D4B760E913 idx=1 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 2: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95B89A7C066EAA6611F4D47360E9FD idx=2 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 3: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EBE7719AA2696EAABE11F4B373603413 idx=3 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 4: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB69719ACB696EAABE11F4C573608113 idx=4 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 5: CT=EB95719A7C696EAABE11F4D47360E913 FCT=FF95719A7C696EB0BE1146D473C2E913 idx=5 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 6: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB9571CC7C69D8AABE76F4D47060E913 idx=6 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 7: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95199A7CF36EAA4811F4D47360E968 idx=7 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 8: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95999A7C576EAA0211F4D47360E9FB idx=8 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 9: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB01719A1C696EAABE11F43573608713 idx=9 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 10: CT=EB95719A7C696EAABE11F4D47360E913 FCT=6495719A7C696EF5BE116FD473F9E913 idx=10 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 11: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95718A7C69EFAABE52F4D49260E913 idx=11 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 12: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95714C7C6908AABE75F4D4D460E913 idx=12 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 13: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EB95E29A7CBC6EAABB11F4D47360E927 idx=13 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 14: CT=EB95719A7C696EAABE11F4D47360E913 FCT=EBF2719A1B696EAABE11F4DE7360B813 idx=14 fb=00ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95ROUND9_BEFORE:1013F6B12E5E5353D2D5370307D07E95PAIR 15: CT=EB95719A7C696EAABE11F4D47360E913 FCT=9D95719A7C696E87BE11B3D4730CE913 idx=15 fb=00Finished. pairs.txt written. Also check round9_states.txt for ROUND9_BEFORE logs.\n然后按照我们白盒aes公式：\n先求第10轮正确密钥：\nimport phoenixAESwith open('tracefile', 'wb') as t:    t.write(\"\"\"EB95719A7C696EAABE11F4D47360E9136B95719A7C696E74BE1147D473AFE913EB95717F7C6924AABE4DF4D4B760E913EB95B89A7C066EAA6611F4D47360E9FDEBE7719AA2696EAABE11F4B373603413EB69719ACB696EAABE11F4C573608113FF95719A7C696EB0BE1146D473C2E913EB9571CC7C69D8AABE76F4D47060E913EB95199A7CF36EAA4811F4D47360E968EB95999A7C576EAA0211F4D47360E9FBEB01719A1C696EAABE11F435736087136495719A7C696EF5BE116FD473F9E913EB95718A7C69EFAABE52F4D49260E913EB95714C7C6908AABE75F4D4D460E913EB95E29A7CBC6EAABB11F4D47360E927EBF2719A1B696EAABE11F4DE7360B8139D95719A7C696E87BE11B3D4730CE913\"\"\".encode('utf8'))phoenixAES.crack_file('tracefile', [], True, False, 3)\n解出第10轮正确密钥是EA9F6BE2DF5C358495648BEAB9FCFF81\n然后解密原始密钥：\nD:\\ctf\\reverse_tools\\白盒aes&gt;aes_keyschedule.exe EA9F6BE2DF5C358495648BEAB9FCFF81 10K00: 51574232303233486170707947616D65K01: BF6B0F928F593CDAEE294CA3A94821C6K02: EF96BB4160CF879B8EE6CB3827AEEAFEK03: 0F11008D6FDE8716E1384C2EC696A6D0K04: 97357039F8EBF72F19D3BB01DF451DD1K05: E9914EA7117AB98808A90289D7EC1F58K06: 075124A9162B9D211E829FA8C96E80F0K07: D89CA874CEB73555D035AAFD195B2A0DK08: 61797FA0AFCE4AF57FFBE00866A0CA05K09: 9A0D149335C35E664A38BE6E2C98746BK10: EA9F6BE2DF5C358495648BEAB9FCFF81D:\\ctf\\reverse_tools\\白盒aes&gt;\n现在我们拿到正确的密钥了\n51574232303233486170707947616D6\n解密AES加密数据在v4\n转成16进制直接解密：\nv4=[97, 147, 49, 123, 248, 150, 224, 0, 165, 39,    183, 55, 74, 227, 3, 168]for i in v4:    print(f\"{i:02x}\", end='')    #6193317bf896e000a527b7374ae303a833a8\n\n调试程序拿到正确输入后我们可以接着调试这项目，当走到图上的代码时，报错并进入exception代码块\n  \n报错：\n{System.Runtime.Serialization.SerializationException: 二进制流“0”不包含有效的 BinaryHeader。这可能是由于无效流，或由于在序列化和反序列化之间的对象版本更改。   在 System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run()   在 System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(HeaderHandler handler, __BinaryParser serParser, Boolean fCheck, Boolean isCrossAppDomain, IMethodCallMessage methodCallMessage)   在 System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, HeaderHandler handler, Boolean fCheck, Boolean isCrossAppDomain, IMethodCallMessage methodCallMessage)   在 System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, HeaderHandler handler, Boolean fCheck, IMethodCallMessage methodCallMessage)   在 System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, HeaderHandler handler, Boolean fCheck)   在 System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, HeaderHandler handler)   在 System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream)   在 SortedListTest.Program.Main(String[] args)}\n由于\nbinaryFormatter.Deserialize(memoryStream);\n这个函数的反序列化可以在反序列化的过程中可以顺便进行函数调用，所以我们的License.dat文件应该是解密后有shellcode一样的东西，但我们License解密后运行仍报错，那可能是License目前是有问题的，需要我们修复\n解密license.dat文件分析main函数可以看出 现在的license文件是被rc4加密过的，rc4密钥就是我们刚解出来的东西：\nfrom Crypto.Cipher import ARC4key = b\"WelcomeToQWB2023\"with open(r\"C:\\Users\\Lenovo\\OneDrive\\Desktop\\Reverse-dotdot\\License.dat\",\"rb\") as f:    a=f.read()rc4 = ARC4.new(key)data = rc4.decrypt(a)with open(r\"C:\\Users\\Lenovo\\OneDrive\\Desktop\\Reverse-dotdot\\1.dat\",\"wb\") as f:    f.write(data)\n得到的结果像是反序列化的结果，我们在里面搜索函数方法名，还真搜索到FFF函数，说明在加载license.dat文件的过程中，执行了FFF方法，然后进行flag逻辑比较\n\n当调试报错时Position断在文件的0x294，说明就是这个地方出了问题，打开winhex一看解密后文件，果然这里一片0，需要我们填数据\n\n现在问题是该填什么：\n恢复License.dat根据其他wp给的序列化后的文件内存格式来说\n0x28d处的06 06 00 00 00 后应该跟要填充的对象长度，第一个06代表是string类型，第二个是某种标识。00 00 00是填充，下一个填充长度不算的话，剩下的0到06 07之前一共有21个，那我们就可以猜测第一个填充的是FFF函数的第一个参数，第二个是FFF函数的第二个参数\n先逆xtea算第一个参数：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;void decodeTEA(unsigned int* v,  long long num ,unsigned int key[]){    unsigned int sum = 32 * num;    unsigned int v0 = v[0];    unsigned int v1 = v[1];    for (int i = 0; i &lt; 32; i++)    {        v1 -= ((v0 &lt;&lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + key[3]);        v0 -= ((v1 &lt;&lt; 4) + key[0] )^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[1]);        sum -= num;    }    v[0] = v0;    v[1] = v1;}int main(){    unsigned char enflag[25] = { 69,      182,      171,      33,      121,      107,      254,      150,      92,      29,      4,      178,      138,      166,      184,      106,      53,      241,      42,      191,      23,      211,      3,      107 };    unsigned char k[] = \"WelcomeToQWB2023\"; /*这里要实现字符类型16个数据转化为4个数据，    联想到char类型大小为1字节byte（8bit），int类型为4字节，只要进行一下数据类型转化就可以实现    （key个数为4）*/    unsigned int key[4] = { 0 };    unsigned int flag[6] = { 0 };    for (int j = 0; j &lt; 4; j++)    {        key[j] = *((unsigned int*)k + j);        /*这里进行的优先级顺序为，先把unsigned char* 的k转化为unsigned int *，这里表示的是指针，        所以加的j相当于一下向后4字节，进行完之后，再用*取地址符取值，赋值 */    }    for (int i = 0; i &lt; 6; i ++)    {        flag[i] = *((unsigned int*)enflag + i);    }    for (int i = 0; i &lt;6 ; i += 2)    {        decodeTEA(flag+i, 3735928559, key);    }    printf(\"解密结果为：\\n\");    printf(\"%s\", flag);    return 0;        //dotN3t_Is_1nt3r3sting}\n然后填入：\n\nexp然后根据FFF中的flag输出函数，我们直接求这个修改函数的md5值逆向就可以了\nfrom hashlib import md5md5_hex = md5(open(\"./1.dat\", \"rb\").read()).digest()data = bytearray.fromhex('3B416C6EDF5AF5E2067ADBAA93B016BE3C183A569661BCA67168E8C5EAE116B7284E6674')for i in range(len(data)):    data[i] ^= md5_hex[i % len(md5_hex)]print(data)     #bytearray(b'flag{d0tN3t_I5_Ea57_2_y09!G00d_Luck}')\nreference:白盒AES—从0到1_aes sbox-CSDN博客\n2023 强网杯逆向 Writeup - gaoyucan - 博客园\n","categories":["逆向中的密码学","对称加密题单"],"tags":["aes"]},{"title":"[网鼎杯 2020 青龙组]bang","url":"/2025/11/11/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5Dbang/","content":"前言：一道例题练习frida方式脱壳\n题目来源\nBUUCTF在线评测\n流程：查壳：\n查壳，工具连接在\nhttps://pan.baidu.com/s/1rDfsEvqQwhUmep1UBLUwSQ 密码: wefd\n脱壳：先列出目前内存中运行的进程：\n(jack) C:\\Users\\Lenovo\\OneDrive\\Desktop&gt;frida-ps -U -a  PID  Name       Identifier-----  ---------  ---------------------------------12357  MT管理器      bin.mt.plus 1123  Magisk     com.topjohnwu.magisk 8519  QQ         com.tencent.mobileqq12844  how_debug  com.example.how_debug13308  三星生活助手     com.samsung.android.app.sreminder11689  三星钱包       com.samsung.android.spay31737  日历         com.samsung.android.calendar31422  联系人        com.samsung.android.app.contacts\n这里命令中-ps指的是process status\n-U 指的是以USB方式连接\n-a 指列出all\n然后开启手机上的frida-server\nC:\\Users\\Lenovo&gt;adb shellb2q:/ $ sub2q:/ # cd /data/local/tmpb2q:/data/local/tmp # lsActivationDevice_V2  CustomCACert.log  as  fr64  sys-ca-copyb2q:/data/local/tmp # ./fr64\n然后开始frida-dexdump脱壳\n(jack) C:\\Users\\Lenovo\\OneDrive\\Desktop&gt;frida-dexdump -U -f com.example.how_debug---------------------------------------------------------------------------------------------------------------------                         __      _     _                 _              _                       / _|_ __(_) __| | __ _        __| | _____  ____| |_   _ _ __ ___  _ __                      | |_| &#x27;__| |/ _` |/ _` |_____ / _` |/ _ \\ \\/ / _` | | | | &#x27;_ ` _ \\| &#x27;_ \\                      |  _| |  | | (_| | (_| |_____| (_| |  __/&gt;  &lt; (_| | |_| | | | | | | |_) |                      |_| |_|  |_|\\__,_|\\__,_|      \\__,_|\\___/_/\\_\\__,_|\\__,_|_| |_| |_| .__/                                                                                        |_|                                        https://github.com/hluwa/frida-dexdump---------------------------------------------------------------------------------------------------------------------Spawning `com.example.how_debug`...INFO:Agent:DexDumpAgent&lt;Connection(pid=Session(pid=13600), connected:True), attached=True&gt;: Attach.INFO:frida-dexdump:Waiting 5s...INFO:frida-dexdump:[+] Searching...INFO:frida-dexdump:[*] Successful found 36 dex, used 1 time.INFO:frida-dexdump:[+] Starting dump to &#x27;C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug&#x27;...INFO:frida-dexdump:[+] DexMd5=ba1cf759fe177114c859d4901e3635a2, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes.dex, DexSize=0x1d60b8INFO:frida-dexdump:[+] DexMd5=28514d4f7ccf16c6bb7ba28602b5d72f, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes02.dex, DexSize=0x446cINFO:frida-dexdump:[+] DexMd5=9f6ed667bc041ca01d5781aafa9e949b, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes03.dex, DexSize=0x11caacINFO:frida-dexdump:[+] DexMd5=72cedc72c81da6f4a2ea80d41f0396db, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes04.dex, DexSize=0x1b1fe8INFO:frida-dexdump:[+] DexMd5=081b79d1a0e1f649f18ac2ce5e8c6687, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes05.dex, DexSize=0xbaf38INFO:frida-dexdump:[+] DexMd5=a65dcfdc791633d8b0921fd5f62557b8, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes06.dex, DexSize=0xadbfcINFO:frida-dexdump:[+] DexMd5=cac2716758fc7bec33298e16760b0d72, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes07.dex, DexSize=0x821ecINFO:frida-dexdump:[+] DexMd5=7e5c1910c90d67e4f4ec040163b1313f, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes08.dex, DexSize=0x158754INFO:frida-dexdump:[+] DexMd5=2aa501d10e8553fee07f31cb72d132c5, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes09.dex, DexSize=0x2cead4INFO:frida-dexdump:[+] DexMd5=704b06ca5fed180a97fe803fb9e1d289, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes10.dex, DexSize=0x123238INFO:frida-dexdump:[+] DexMd5=9b5ace8b5a362e5b6d3cd2eade413d32, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes11.dex, DexSize=0x1691e0INFO:frida-dexdump:[+] DexMd5=f7b58a3209dafc422e52ea0c327844e6, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes12.dex, DexSize=0x5504b4INFO:frida-dexdump:[+] DexMd5=2fa8055373d7fad871cc7eb1f4773100, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes13.dex, DexSize=0x8b92cINFO:frida-dexdump:[+] DexMd5=e12fbb91f1e50490d723d392cfb64462, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes14.dex, DexSize=0x727acINFO:frida-dexdump:[+] DexMd5=a0557abc4a75581fef74a615335e217c, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes15.dex, DexSize=0x5c968INFO:frida-dexdump:[+] DexMd5=ad8261bb66fc787adbf0f3ead519cbfa, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes16.dex, DexSize=0x68b08INFO:frida-dexdump:[+] DexMd5=8aba98d63fc9efc0b65a1787b04cbaaf, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes17.dex, DexSize=0x630b8INFO:frida-dexdump:[+] DexMd5=e4edc50af9e1235448162f3d897fe46d, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes18.dex, DexSize=0x260INFO:frida-dexdump:[+] DexMd5=a9c5171d09972adcbcb2533c1b2fce81, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes19.dex, DexSize=0x33facINFO:frida-dexdump:[+] DexMd5=9c0fa3700d8f1ac8a8b5d96548c524bc, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes20.dex, DexSize=0x21dccINFO:frida-dexdump:[+] DexMd5=222e9040d440df80485c27f1ccc67aac, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes21.dex, DexSize=0x2cbacINFO:frida-dexdump:[+] DexMd5=39ebc9a37d751ac3076c55e617d5e9c6, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes22.dex, DexSize=0x37408INFO:frida-dexdump:[+] DexMd5=a31ad083fd47c76a53adf884e2ae7e2a, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes23.dex, DexSize=0x225c4INFO:frida-dexdump:[+] DexMd5=5c9f56f29221493a2fd3a22e1f8f492c, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes24.dex, DexSize=0x1399cINFO:frida-dexdump:[+] DexMd5=c65aaa204d733781aeeee779f5f28ce1, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes25.dex, DexSize=0x18d38INFO:frida-dexdump:[+] DexMd5=c411e4e46e8fc5d2c14718d26a942215, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes26.dex, DexSize=0x10e9cINFO:frida-dexdump:[+] DexMd5=56f6ffc46797695382918d55b57b0513, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes27.dex, DexSize=0x14b80INFO:frida-dexdump:[+] DexMd5=efb9359d1a151dc65d2fc91030194b6a, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes28.dex, DexSize=0x135ccINFO:frida-dexdump:[+] DexMd5=171711041e67582660c0563841bfae0c, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes29.dex, DexSize=0x56a4INFO:frida-dexdump:[+] DexMd5=f5ae84a0c91c8732a1ee39d57523d6b2, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes30.dex, DexSize=0x131cINFO:frida-dexdump:[+] DexMd5=f08d322fa4870c3c15ad0013656987c0, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes31.dex, DexSize=0x31ecINFO:frida-dexdump:[+] DexMd5=7c151936d903263d1d3bff36799f424f, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes32.dex, DexSize=0x6ac8INFO:frida-dexdump:[+] DexMd5=82d3511ca8f86f286a6f668983fc3df7, SavePath=C:\\Users\\Lenovo\\OneDrive\\Desktop\\com.example.how_debug\\classes33.dex, DexSize=0x19e4INFO:frida-dexdump:[*] All done...\n这里frida-dexdump是一个基于frida开发的工具\n-f指force spawn，从程序最开始启动程序\n打包apk把生成的文件夹压缩为zip\n然后改名apk\n拉进jadx分析\n\n这里直接就拿到flag了\nflagflag{borring_things}\n","categories":["安卓逆向","安卓逆向题单"],"tags":["安卓逆向"]},{"title":"安卓逆向环境配置","url":"/2025/10/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"前言：某些安卓题强制要求arm环境才能跑，模拟器不管是脱壳还是动调都有很多问题，最近搞了个真机重新配一遍安卓逆向环境\nroot手机我这个是三星的galaxy z filp3，不得不说国外的手机root就是比国内的简单\n解bl锁：一边按住音量上下键，一边插数据线，出浅蓝界面放手，然后长按音量上\n出现unlock放手，短按音量下\n这样就把bl锁开了\n解oem：连点7次编译版本，然后进开发者模式，打开oem\n刷机下载系统包：手机关机不插线，同时按住音量上下键，一边插数据线，到蓝屏界面按一次音量上到download模式，然后选择factory data reset模式，电脑同时启动数据传输，等开机就好了\n开机后在github下载最新的magisk刷入面具root就完了\n配置逆向环境：导入面具模块：在github找xposed模块，下载zip包，放在手机里，在面具软件下边模块点从本地安装，等待就刷入xposed模块了，再从github下一个lsposed管理器，基础环境就完事了\n下载逆向工具：本文所有逆向工具都可以在吾爱破解的《安卓逆向这档事》一、模拟器环境搭建 - 吾爱破解 - 52pojie.cn及后续中找到\nMT管理器&amp;NT管理器：这两个工具是用于操作我们的系统文件的，可以修改签名，修改apk的smali代码，功能很多是安卓逆向的神器\n算法助手：有很多内置的功能，极大增大我们的逆向速度\nxdebugapp：过动调检测的小帮手，我们安卓apk的动态调试步骤：\n\nxdebugapp打开目的app获取debug权限\n\n终端启动调试\nadb shell am start -D -n com.zj.wuaipojie/.ui.MainActivityadb shell am start -D -n 包名/类名 （去掉-D 则表示不以debug模式启动app）\n\njeb下断点附上apk\n\n\nsimplehook：里面基本实现了一些hook的功能，如果有简单hook需求就不用写frida脚本了\nandroid_server:这个东西不用下载，直接在ida下载文件夹里找就可以  IDA_Pro\\dbgsrv\\android_server\n然后在cmd里输入\nadb push IDA_Pro\\dbgsrv\\android_server /data/local/tmp\n这样就把我们的调试服务器放在了/data/local/tmp里了\n在mt管理器找到它把文件属性改为777，改名为as(因为很多反调试会检测android_server这个名字)\n需要动调apk的.so文件的时候就\nadb shellsucd /data/local/tmp./as\nfrida server安卓逆向的神器，去github下载对应的frida版本，我这里win下载的16.1.3版本，就要去官网找对应16.1.3的server\n(jack) C:\\Users\\Lenovo&gt;frida --v16.1.3\n\n也放到/data/local/tmp\nLspatch免 Root 使用 Xposed 模块这是 LSPatch 最主要的功能。\n\n它允许在 不 Root 手机 的情况下，让应用程序加载和执行 Xposed 模块。\n\n传统方式：需要 Root → 安装 LSPosed → 启用模块\n\nLSPatch 方式：直接修补 APK 文件 → 安装修补后的 APK → 直接使用\n\n\n应用重打包与修改\n通过修补目标 APK，将模块代码嵌入到应用中，实现功能增强。\nreqable：https://reqable.com/zh-CN/download\n这个是必备抓包apk，用这个我们可以抓app的包\n","categories":["安卓逆向","安卓逆向基础"],"tags":["安卓逆向"]},{"title":"wasm逆向基础","url":"/2025/11/20/js%E9%80%86%E5%90%91/wasm/wasm/","content":"什么是wasm：WebAssembly 简称Wasm，是一个低级编程语言。WebAssembly是可移植性的[抽象语法树，被设计来提供比JavaScript更快速的编译及执行。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C +作为实现目标）编译，再藉虚拟机引擎在浏览器内执行。\n其中wasm文件的文件格式：总的来说，wasm文件类型设计两种:.wasm和.wat其中.wasm就是可以直接在浏览器上运行的程序（二进制文件），而.wat是人类可读的.wasm代码的转换（txt形式文件）\n静态分析wasm代码wabt：GitHub - WebAssembly/wabt: The WebAssembly Binary Toolkit\n全称 WebAssembly Binary Toolkit，是一组专门处理 WebAssembly 的命令行工具，\n有了它，你就能得到wasm的类c语言来阅读，或者得到相应的wat格式\n.wasm-&gt;.c\nwasm2c test.wasm -o test.c\n.wasm-&gt;.wat\nwasm2wat test.wasm -o test.wat\n在ida里分析wasm文件：我们上面不是拿到了一个test.c吗，我们可以在本地编译这个文件，就可以得到一个类似exe的东西，我们不能执行它，因为这个.c文件没有main函数，wasm的目的只是导出函数共js代码使用。但可以拖进ida pro分析它的导出表\n我这里用vitual studio 2022里自带的命令行\nx64_x86 Cross Tools Command Prompt for VS 2022来编译\ncl /I&quot;D:\\ctf\\reverse_tools\\js逆向\\wasm静态分析\\wabt-1.0.39\\include&quot; test.c /link &quot;D:\\ctf\\reverse_tools\\js逆向\\wasm静态分析\\wabt-1.0.39\\lib\\wasm-rt-impl.lib&quot; /out:test.exe\n效果：\nC:\\Users\\Lenovo\\OneDrive\\Desktop&gt;cl /I&quot;D:\\ctf\\reverse_tools\\js逆向\\wasm静态分析\\wabt-1.0.39\\include&quot; test.c /link &quot;D:\\ctf\\reverse_tools\\js逆向\\wasm静态分析\\wabt-1.0.39\\lib\\wasm-rt-impl.lib&quot; /out:test.exe用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.42.34433 版版权所有(C) Microsoft Corporation。保留所有权利。test.cMicrosoft (R) Incremental Linker Version 14.42.34433.0Copyright (C) Microsoft Corporation.  All rights reserved./out:test.exeD:\\ctf\\reverse_tools\\js逆向\\wasm静态分析\\wabt-1.0.39\\lib\\wasm-rt-impl.lib/out:test.exetest.objLINK : fatal error LNK1561: 必须定义入口点C:\\Users\\Lenovo\\OneDrive\\Desktop&gt;\n然后把生成的.obj文件拖进ida pro看导出表就可以分析了\ni32_load形式的函数为取值函数，第一个参数为取值对象，第二个参数为偏移i32_store形式的函数为操作存储函数，第一个参数为存储对象，第二个参数为存储位置，第三个参数为操作方式\n在js代码定位调用的wasm函数利用 WebAssembly API如果代码里直接出现：\nWebAssembly.instantiate(buffer, imports)WebAssembly.instantiateStreaming(fetch(&#x27;xxx.wasm&#x27;), imports)\n这是最直接的证据，说明加载了一个 .wasm 文件。返回值通常包含 instance.exports，可以直接访问 WASM 导出函数\nEmscripten 封装Emscripten 编译的 WASM 会生成一个 JS “模块对象”，常见特点：\nvar mod = Module(); // 或者 import * as mod from &#x27;./module.js&#x27;\n调用 WASM 导出函数通常通过 mod.cwrap 或 mod.ccall\nconst fn = mod.cwrap(&quot;check&quot;, &quot;number&quot;, [&quot;string&quot;, &quot;number&quot;]);fn(&quot;input&quot;, 5);\ncwrap / ccall 是 明显的标志，说明 JS 调用的是 WASM 函数，而不是普通 JS 函数\ncwrap里第一个是wasm函数名，第二个是返回值类型，第三个是参数列表类型\nWASM 模块实例方法有些代码直接引用 instance.exports：\nconst result = instance.exports.check(inputDataPtr, len);\ninstance.exports 的函数都是 WASM 里导出的函数\n参数通常是数字或指针（内存地址），因为 WASM 内部是线性内存\n内存操作的痕迹WASM 使用线性内存，JS 里可能会看到：\nmod.HEAP8[index] = value;mod.HEAPU32[offset] = someInt;\n对 HEAP8、HEAP16、HEAP32、HEAPU8 等数组的读写，通常是给 WASM 内存传值\n如果没有这些操作，仍然可以调用 WASM，但这种操作是典型特征\n","categories":["js逆向","wasm逆向基础"],"tags":["wasm"]}]