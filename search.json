[{"title":"[GWCTF 2019] babyvm","url":"/2025/10/07/%5BGWCTF%202019%5Dbabyvm/","content":"前言：这道题算非常经典的vm题了，用这道题来熟悉一下vm题基本流程\n正文：创建结构体：\n有三个函数我们点进去看一下具体逻辑\n\n第一个函数很明显就是vm_init的结构，我们改名为vm_init,并创建结构体帮助静态分析\n\n在空白部分右键，添加结构体\n\n结构体名就叫vm_cpu，下面按d键快捷键给它增加成员变量\n光标对准vm_cpu struc点一次d是在最前面增加成员变量\n对准field_0点一次d是更改一次field_0的类型,也可按y直接输入类型\n对准vm_cpu ends点一次d是在末尾增加成员变量\n\n接下来修改成员变量的名称按n快捷键，改为eax，ebx等\n由于vm_cpu中有个数组叫oplist[]\n我们先创建新结构体\nstruct opcode&#123;    QWORD _opcode;    QWORD handle;&#125;;\n\n这里稍微再提一下怎么确定每个成员变量占多少字节，不要看ida给你强转出来的类型，而要看上下成员之间的差值，比如*(_BYTE )(a1 + 24) &#x3D; -15;和(_QWORD *)(a1 + 32) &#x3D; sub_B5F;从a1+24到a1+32，占了8个字节。所以这里_opcode类型是qword。下面是全部改完之后的结构体\n\n再回到第一个函数，对准函数参数列表按y，把a1类型改为vm_cpu*，然后函数就变得美观了，下面的qword_2022A8是给vm设置的栈空间，我们也可以改名vm_stack\n\n第二个函数很容易看出来是vm_run,分发器控制程序执行，第三个函数是验证flag正确与否，就不展开讲了\n第二个函数把参数也改成vm_cpu*\nunsigned __int64 __fastcall vm_run(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_rip = (__int64)&amp;unk_202060;  while ( *(_BYTE *)a1-&gt;vm_rip != 0xF4 )    sub_E6E(a1);  return __readfsqword(0x28u) ^ v2;&#125;\n\n我们看到逻辑已经很明确了，就是rip指向的地址对应的值不等于0xf4时，一直调用sub_E6E\nunsigned __int64 __fastcall sub_E6E(vm_cpu *a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; *(_BYTE *)a1-&gt;vm_rip != LOBYTE(a1-&gt;oplist[i]._opcode); ++i )    ;  ((void (__fastcall *)(vm_cpu *))a1-&gt;oplist[i].handle)(a1);  return __readfsqword(0x28u) ^ v3;&#125;\n\nsub_E6E点进去就发现和我们的vm基础里的dispatcher结构一模一样，现在我们回头处理一下没命名的handle函数就可以正式逆向了\n识别函数：1.mov函数unsigned __int64 __fastcall sub_B5F(vm_cpu *a1)&#123;  int *v2; // [rsp+28h] [rbp-18h]  unsigned __int64 v3; // [rsp+38h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = (int *)(a1-&gt;vm_rip + 2);  switch ( *(_BYTE *)(a1-&gt;vm_rip + 1) )  &#123;    case 0xE1:      a1-&gt;vm_eax = *((char *)vm_stack + *v2);      break;    case 0xE2:      a1-&gt;vm_ebx = *((char *)vm_stack + *v2);      break;    case 0xE3:      a1-&gt;vm_ecx = *((char *)vm_stack + *v2);      break;    case 0xE4:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_eax;      break;    case 0xE5:      a1-&gt;vm_edx = *((char *)vm_stack + *v2);      break;    case 0xE7:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_ebx;      break;    default:      break;  &#125;  a1-&gt;vm_rip += 6LL;  return __readfsqword(0x28u) ^ v3;&#125;\n\n这个函数的意思是，v2是栈中偏移，相当于ss:[ebp+v2]&#x3D;vm_stack[v2],当操作码&#x3D;-15也就是0xF1的时候，调用这个函数，下一个地址的数*(_BYTE )(a1-&gt;vm_rip+1))就是选择码，(_BYTE *)(a1-&gt;vm_rip+2))就是操作数\n\n选择码&#x3D;0xE1 执行mov eax ss:[ebp+v2]\n\n选择码&#x3D;0xE2 执行mov ebx ss:[ebp+v2]\n\n选择码&#x3D;0xE3 执行mov ecx ss:[ebp+v2]\n\n选择码&#x3D;0xE4 执行mov ss:[ebp+v2] eax \n\n选择码&#x3D;0xE5 执行mov edx ss:[ebp+v2]\n\n选择码&#x3D;0xE7 执行mov ss:[ebp+v2] ebx\n\n\n2.xorunsigned __int64 __fastcall sub_A64(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax ^= a1-&gt;vm_ebx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\n相当于xor eax ebx\n3.readunsigned __int64 __fastcall sub_AC5(vm_cpu *a1)&#123;  const char *buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  buf = (const char *)vm_stack;  read(0, vm_stack, 0x20uLL);  dword_2022A4 = strlen(buf);  if ( dword_2022A4 != 21 )  &#123;    puts(&quot;WRONG!&quot;);    exit(0);  &#125;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\n\n把flag读入栈上\n相当于call read,并判断flag长度\n4.nopunsigned __int64 __fastcall sub_956(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\n什么都没干，rip只是加1，这是所有指令都要有的\n5.mulunsigned __int64 __fastcall sub_A08(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax *= a1-&gt;vm_edx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\nmul eax edx\n6.xchgunsigned __int64 __fastcall sub_8F0(vm_cpu *a1)&#123;  int vm_eax; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  vm_eax = a1-&gt;vm_eax;  a1-&gt;vm_eax = a1-&gt;vm_ebx;  a1-&gt;vm_ebx = vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\n\nxchg eax ebx\n7.自定义函数unsigned __int64 __fastcall sub_99C(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax = a1-&gt;vm_ecx + 2 * a1-&gt;vm_ebx + 3 * a1-&gt;vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\n实现了eax&#x3D;ecx+2ebx+3eax应该是自定义指令\n自己实现dispatcher，汇编层面逆向#include&lt;iostream&gt;using namespace std;int opcode[]=&#123;0xF5, 0xF1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x20, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x01, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x21, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x22, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x03, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x23,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x24, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x25, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x26, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x27, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x28, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x09, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x29, 0x00, 0x00,   0x00, 0xF1, 0xE1, 0x0A, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x2A, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0B, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x2B, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0C,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2C, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2D,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x2E, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0F, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2F, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x10, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x30, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x11, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x31, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x12, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x32, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x13, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x33, 0x00, 0x00,   0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0xF1,   0xE1, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x01, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x01, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x02, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x01, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x03, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x02, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x03, 0x00,   0x00, 0x00, 0xF1, 0xE2, 0x04, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x03, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x05, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x04, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x05,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x06, 0x00, 0x00, 0x00, 0xF1,   0xE2, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x08, 0x00, 0x00,   0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6, 0xF7, 0xF1,   0xE4, 0x06, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x08, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x09,   0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6,   0xF7, 0xF1, 0xE4, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x09, 0x00, 0x00, 0x00, 0xF1,   0xE3, 0x0A, 0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00,   0x00, 0xF6, 0xF7, 0xF1, 0xE4, 0x08, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x13, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x13, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x12, 0x00, 0x00, 0x00, 0xF8, 0xF1, 0xE4, 0x0E,   0x00, 0x00, 0x00, 0xF1, 0xE7, 0x12, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x11, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x11, 0x00, 0x00, 0x00, 0xF4&#125;;int main()&#123;    int rip=0;    int vm_eax=0;    int vm_ebx=18;    int vm_ecx=0;    int vm_edx=0;    int vm_stack[521];    for(int i=0;i&lt;521;i++)    &#123;        vm_stack[i]=0;    &#125;    int len = sizeof(opcode) / sizeof(opcode[0]);    while (rip&lt;len)    &#123;        if(opcode[rip]==0xF1)        &#123;            int v2=opcode[rip+2];            switch(opcode[rip+1])            &#123;                case 0xE1:                    vm_eax = vm_stack[v2];                    cout&lt;&lt;&quot;mov eax,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE2:                    vm_ebx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ebx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE3:                    vm_ecx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ecx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE4:                    vm_stack[v2] = vm_eax;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],eax&quot;&lt;&lt;endl;                    break;                case 0xE5:                    vm_edx = vm_stack[v2];                    cout&lt;&lt;&quot;mov edx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE7:                    vm_stack[v2] = vm_ebx;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],ebx&quot;&lt;&lt;endl;                    break;                default:                    break;            &#125;            rip+=6;            continue;        &#125;        else if(opcode[rip]==0xF2)        &#123;            vm_eax^=vm_ebx;            cout&lt;&lt;&quot;xor eax ebx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF5)        &#123;            // for(int i=0;i&lt;21;i++)            // &#123;            //     char c;            //     cin&gt;&gt;c;            //     vm_stack[i]=c;            // &#125;            cout&lt;&lt;&quot;read flag&amp;&amp;judge len&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xf4)        &#123;            cout&lt;&lt;&quot;nop&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF6)        &#123;            vm_eax=vm_ecx+2*vm_ebx+3*vm_eax;            cout&lt;&lt;&quot;eax=ecx+2*ebx+3*eax&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF7)        &#123;            vm_eax*=vm_edx;            cout&lt;&lt;&quot;mul eax edx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF8)        &#123;            int t = vm_eax;            vm_eax = vm_ebx;            vm_ebx = t;            cout&lt;&lt;&quot;xchg eax ebx&quot;&lt;&lt;endl;        &#125;        rip++;    &#125;&#125;\n\n这里其实可以把栈信息一起打印出来的，但是这道题非常简单没有涉及到栈的其他操作，只是简单把flag放在栈上，所以这里不打印了\n结果：\nread flag&amp;&amp;judge lenmov eax,stack[0]xor eax ebxmov stack[32],eaxmov eax,stack[1]xor eax ebxmov stack[33],eaxmov eax,stack[2]xor eax ebxmov stack[34],eaxmov eax,stack[3]xor eax ebxmov stack[35],eaxmov eax,stack[4]xor eax ebxmov stack[36],eaxmov eax,stack[5]xor eax ebxmov stack[37],eaxmov eax,stack[6]xor eax ebxmov stack[38],eaxmov eax,stack[7]xor eax ebxmov stack[39],eaxmov eax,stack[8]xor eax ebxmov stack[40],eaxmov eax,stack[9]xor eax ebxmov stack[41],eaxmov eax,stack[10]xor eax ebxmov stack[42],eaxmov eax,stack[11]xor eax ebxmov stack[43],eaxmov eax,stack[12]xor eax ebxmov stack[44],eaxmov eax,stack[13]xor eax ebxmov stack[45],eaxmov eax,stack[14]xor eax ebxmov stack[46],eaxmov eax,stack[15]xor eax ebxmov stack[47],eaxmov eax,stack[16]xor eax ebxmov stack[48],eaxmov eax,stack[17]xor eax ebxmov stack[49],eaxmov eax,stack[18]xor eax ebxmov stack[50],eaxmov eax,stack[19]xor eax ebxmov stack[51],eaxnopread flag&amp;&amp;judge lenmov eax,stack[0]mov ebx,stack[1]xor eax ebxmov stack[0],eaxmov eax,stack[1]mov ebx,stack[2]xor eax ebxmov stack[1],eaxmov eax,stack[2]mov ebx,stack[3]xor eax ebxmov stack[2],eaxmov eax,stack[3]mov ebx,stack[4]xor eax ebxmov stack[3],eaxmov eax,stack[4]mov ebx,stack[5]xor eax ebxmov stack[4],eaxmov eax,stack[5]mov ebx,stack[6]xor eax ebxmov stack[5],eaxmov eax,stack[6]mov ebx,stack[7]mov ecx,stack[8]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[6],eaxmov eax,stack[7]mov ebx,stack[8]mov ecx,stack[9]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[7],eaxmov eax,stack[8]mov ebx,stack[9]mov ecx,stack[10]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[8],eaxmov eax,stack[13]mov ebx,stack[19]xchg eax ebxmov stack[13],eaxmov stack[19],ebxmov eax,stack[14]mov ebx,stack[18]xchg eax ebxmov stack[14],eaxmov stack[18],ebxmov eax,stack[15]mov ebx,stack[17]xchg eax ebxmov stack[15],eaxmov stack[17],ebxnop\n\n正常一道普通的vm逆向题到这里看汇编逆向写exp就结束了，但这道题还有坑\n题外话：解题：这道题汇编前半部分很明显不对，因为flag总长度才21，栈上怎么索引到50多了，所以交叉引用找到真正的check函数,而且汇报中有两次输入，第二次输入才是真的\nunsigned __int64 sub_F00()&#123;  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; len_flag - 1 &gt; i; ++i )  &#123;    if ( *((_BYTE *)vm_stack + i) != byte_202020[i] )      exit(0);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\n\nexp：\nfrom z3 import *import re# 密文（十六进制字符串）flag = &#x27;69 45 2A 37 09 17 C5 0B 5C 72 33 76 33 21 74 31 5F 33 73 72&#x27;.split(&#x27; &#x27;)flag = [int(x, 16) for x in flag]# 1) 还原前面的三次交换（你在 forward 阶段做了 13&lt;-&gt;19, 14&lt;-&gt;18, 15&lt;-&gt;17）flag[15], flag[17] = flag[17], flag[15]flag[14], flag[18] = flag[18], flag[14]flag[19], flag[13] = flag[13], flag[19]# 2) 用 Z3 求解 a6,a7,a8（原始 stack[6..8]）# 方程（forward）是： f6 = (s8 + 2*s7 + 3*s6) * s12  （全部为字节运算）a6, a7, a8 = BitVecs(&#x27;a6 a7 a8&#x27;, 8)s = Solver()# 注意：这里 flag[...] 是 Python 整数（0..255），Z3 会自动把它转为相应的常量。# 若你想更严格地把所有算术限定为 8-bit，可把常量也包装成 BitVecVal(...,8)。s.add( BitVecVal(flag[6],8) == (a8 + (a7 &lt;&lt; 1) + a6 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[7],8) == (BitVecVal(flag[9],8)  + (a8 &lt;&lt; 1) + a7 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[8],8) == (BitVecVal(flag[10],8) + (BitVecVal(flag[9],8) &lt;&lt; 1) + a8 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )if s.check() == sat:    m = s.model()    # 把求得的 a6,a7,a8 写回 flag 对应位置    for v in [a6, a7, a8]:        idx = int(re.search(r&#x27;\\d+&#x27;, str(v)).group())        flag[idx] = m[v].as_long()# 3) 逆向 XOR 链（forward 做了 f0 = s0^s1; f1 = s1^s2; ...; f5 = s5^s6）for i in range(5, -1, -1):    flag[i] ^= flag[i + 1]print(&#x27;[+] flag: &#x27;, &#x27;&#x27;.join(chr(x) for x in flag))# [+] flag:  Y0u_hav3_r3v3rs3_1t!\n\n探究控制流的改变：","categories":["vm逆向题单"],"tags":["vm逆向","ctf"]},{"title":"Hello World","url":"/2025/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"rust逆向基础-rust基础语法","url":"/2025/10/01/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","content":"前言:拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下\nrust相比其他编程语言的优势:\nrust不通过 GC(garbage collection)机制管理内存,例如python,golang等基于GC机制的编程语言会在exe运行时不断寻找虚拟地址中无用的内存空间.这会大大降低运行速度\n\nrust使用所有权机制管理内存,这也使得它相比与手动开辟内存的c&#x2F;c++更安全\n\n\n我们rust在逆向中通常用于网络编程,游戏编程,wasm,嵌入式.所以写游戏外挂,实现检测外挂都必须要学习rust.\n语法:变量:rust中变量声明要用let.rust中每个变量类型可以自己指定,也可交给编译器推断,每个变量类型可以声明可变也可声明不可变.(注:如果要声明常量类型时,常量名一定要全大写,并且必须显示指定类型.例如 const MAX:u32=10;)\n整数类型\n有符号：i8, i16, i32, i64, i128, isize\n\n无符号：u8, u16, u32, u64, u128, usize\n\n\n浮点数\nf32（32 位单精度）\n\nf64（64 位双精度，默认）\n\n\n布尔型\ntrue\n\nfalse\n\n\nchar型字符串型\n&amp;str → 字符串切片（不可变）\n\nString → 堆分配的可变字符串\n\n\nfn main() &#123;    let n: i32= 5; // 变量后的：i32可以自己指定，也可让编译器推断    let mut i: u32 = 5; // u32 表示32位无符号整数,mut表示可变    println!(&quot;The value of n is &#123;&#125;&quot;,n); // println! 用来打印字符串到终端，n代表换行，!代表宏    println!(&quot;The value of i is &#123;&#125;&quot;,i);    i=7;    println!(&quot;The value of i is &#123;&#125;&quot;,i);    let x: f64 = 5.2;    println!(&quot;The value of x is &#123;&#125;&quot;,x);    let y: char =&#x27;d&#x27;;    println!(&quot;The value of y is &#123;&#125;&quot;,y);    let t=true;    println!(&quot;The value of t is &#123;&#125;&quot;,t);    let str: &amp;str=&quot;hello&quot;;    println!(&quot;The value of str is &#123;&#125;&quot;,str);    let mut s2: String = String::from(&quot;Hello&quot;);    s2.push_str(&quot;, Rust!&quot;);        // 可变字符串    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n\n输出结果:\nThe value of n is 5The value of i is 5The value of i is 7The value of x is 5.2The value of y is dThe value of t is trueThe value of str is helloHello, Rust!\n\n控制语句:if-else if-else// iflet n = 5;if n &lt; 0 &#123;    println!(&quot;负数&quot;);&#125; else &#123;    println!(&quot;非负数&quot;);&#125;\n\n\n\n循环\nloop 一直循环\n\nwhile 有条件的循环\n\nfor\n\n\n可以通过break跳出循环,也可以通过continue继续当前循环.这和c++是一样的\n// looplet mut counter = 0;let result = loop &#123;    counter += 1;    if counter == 10 &#123;        break counter * 2; // 返回值    &#125;&#125;;// whilelet mut i = 3;while i &gt; 0 &#123;    println!(&quot;&#123;&#125;&quot;, i);    i -= 1;&#125;// forlet arr = [10, 20, 30];for val in arr &#123;    println!(&quot;&#123;&#125;&quot;, val);&#125;\n\n\n\nMatchmatch的用法和if-else很像,但是要注意match要把所有情况包含在内,不然编译阶段就报错\nlet x = 5;match x &#123;    1 | 2 =&gt; println!(&quot;一或二&quot;),    3..=7 =&gt; println!(&quot;三到七之间&quot;), // 范围匹配    _ =&gt; println!(&quot;其他&quot;),&#125;\n\n\n\n函数函数使用基本的函数定义是fn fucnction(a:i32,b:i32) -&gt; i32其中箭头右面的是返回值类型.rust函数表达力非常强\nfn add(a:i32,b:i32)-&gt;i32&#123;    a+b //不加分号，rust会将最后一行作为返回值&#125;fn main() &#123;    let a=1;    let b=3;    let res=add(a,b);    println!(&quot;&#123;&#125;&quot;,res);//println!()是rust的输出函数，其中第一个参数必须是&quot;&quot;包裹的字符串(不能用&#x27;&#x27;替代)，第二个参数是占位符，占位符的值通过&#123;&#125;来传递&#125;\n\n闭包:闭包可以理解成python里的lambda差不多,相当于匿名函数\nfn main() &#123;    let sum=|a:i32,b:i32|-&gt;i32&#123;a+b&#125;;//这里定义时是用||包裹参数，调用时和正常函数一样    let res=sum(1,2);    println!(&quot;The sum is &#123;&#125;&quot;,res);&#125;\n\nrust复合类型枚举:简单来说，枚举（enum）就是用来表示“一个值可能属于几种互斥情况之一”，也就是“有限状态或选择”。\n换句话说，它适合表示有多种可能性，但每次只能选一个的场景。\nenum TrafficLight &#123;    Red,    Yellow,    Green,&#125;let light = TrafficLight::Red;match light &#123;    TrafficLight::Red =&gt; println!(&quot;停&quot;),    TrafficLight::Yellow =&gt; println!(&quot;准备&quot;),    TrafficLight::Green =&gt; println!(&quot;走&quot;),&#125;\n\n结构体基础:结构体和enum不一样的点在于声明结构体时,要把内部变量的类型写出来.而enum就不用\n其中对#[derive(Debug)]的解释:\n\n\n\n部分\n含义\n记忆小技巧\n\n\n\n#[]\nRust 的 属性（attribute）标记，用来告诉编译器对后面的结构体&#x2F;枚举做某些处理\n“井号括号 → 给编译器的指令”\n\n\nderive\n自动 派生&#x2F;生成实现 trait 的代码\n“derive &#x3D; 自动生成某种功能”\n\n\n(Debug)\n指定生成的 trait 是 Debug\n“Debug &#x3D; 调试打印能力”\n\n\n#[derive(Debug)]struct Node&#123;    x: i32,    y: i32&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    println!(&quot;&#123;&#125;&quot;, x);    println!(&quot;&#123;&#125;&quot;, y);    println!(&quot;&#123;:?&#125;&quot;, n); //打印结构体或enum类型，要用&#123;:?&#125;,配合结构体定义上方的#[derive(Debug)]打印结构体&#125;\n\n结构体进阶:Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 key: value 语法来实现定义：\n实例化时:\n结构体类名 {    字段名 : 字段值,    …}\n(1)在结构体内部用impl关键字实现内联函数:\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn area(x:i32,y:i32)-&gt;i32&#123;        x*y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    let s=Node::area(x, y);    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n (2)用结构体中self指针实现\nstruct Node&#123;    x: i32,    y: i32,&#125;// impl Node&#123;//     fn area(x:i32,y:i32)-&gt;i32&#123;//         x*y//     &#125;// &#125;impl Node&#123;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    //let s=Node::area(x, y);    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n(3)结构体实现构造函数\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn new(x:i32,y:i32)-&gt;Self&#123;//默认构造函数名都叫new，但这不是个关键字        Node&#123;            x:x,            y:y        &#125;    &#125;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node::new(1,2);    let x=n.x;    let y=n.y;    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n(4)self的用法:\n\nself 小写 &#x3D; 当前对象实例指针。\n\nSelf 大写 &#x3D; 当前类型名。\n\n\nself指针也分为可变和不可变的,可变的要在self前加关键字mut\n#[derive(Debug)]struct Person&#123;    name:String,    age:u32&#125;impl Person&#123;    fn new(name:String,age:u32)-&gt;Self&#123;        Person&#123;name,age&#125;    &#125;    //不可变的this指针    fn greet(&amp;self)-&gt;String&#123;        format!(&quot;Hello,my name is &#123;&#125; and I am &#123;&#125; years old.&quot;,self.name,self.age)    &#125;    //可变的this指针    fn up_age(&amp;mut self)-&gt;u32&#123;        self.age+=1;        self.age    &#125;&#125;fn main() &#123;    let a=Person::new(&quot;原子&quot;.to_string(), 18); //“原子”是静态str.&amp;str类型，要转成可变的String    println!(&quot;&#123;:#?&#125;&quot;,a); //&#123;:#?&#125;是调试格式，和&#123;:?&#125;的区别是，&#123;:#?&#125;会多出缩进，方便阅读    println!(&quot;&#123;&#125;&quot;,a.greet());    let mut b =a;    b.up_age();    println!(&quot;&#123;&#125;&quot;,b.greet());&#125;\n\n输出:\nPerson &#123;    name: &quot;原子&quot;,    age: 18,&#125;Hello,my name is 原子 and I am 18 years old.Hello,my name is 原子 and I am 19 years old.\n\nself还有一个不经常用的用法:就是如果传入参数是self(不带&amp;)的话:\nstruct Node &#123;    x: i32,    y: i32,&#125;impl Node &#123;    // 这里的 self 是按值传递，意味着把 Node 本身交给这个方法    fn into_tuple(self) -&gt; (i32, i32) &#123;        (self.x, self.y)    &#125;&#125;fn main() &#123;    let n = Node &#123; x: 1, y: 2 &#125;;    let t = n.into_tuple();  //  这里 n 被 move 走    println!(&quot;&#123;:?&#125;&quot;, t);    // println!(&quot;&#123;:?&#125;&quot;, n.x); //  报错：因为 n 的所有权已经交出，不能再用&#125;\n\n元组:1.基本定义:元组就是把多个不同类型的值组合在一起的复合类型。语法：\nlet tup: (i32, f64, char) = (500, 6.4, &#x27;a&#x27;);\n\n2.访问元素\n有两种方式：\n方式一：解构\nlet tup = (500, 6.4, &#x27;a&#x27;);let (x, y, z) = tup;println!(&quot;y 的值是: &#123;&#125;&quot;, y);\n\n方式二：点语法（下标访问）\n注意第一个元素下标是0\nlet tup = (500, 6.4, &#x27;a&#x27;);println!(&quot;第一个元素是: &#123;&#125;&quot;, tup.0);println!(&quot;第二个元素是: &#123;&#125;&quot;, tup.1);println!(&quot;第三个元素是: &#123;&#125;&quot;, tup.2);\n\n3.特点:可以包含不同类型的值\n长度固定，不能改变\n4.打印可利用{:?}来打印\n核心机制&amp;数据结构栈和堆存放\n栈 (Stack) 的特点\n\n\n后进先出 (LIFO) 的数据结构，内存分配和释放都非常快。\n\n大小在编译时必须确定。\n\n栈上的数据一般是 固定大小、生命周期明确的值。\n\n\nlet x = 42;       // i32，大小固定 4 字节let y = true;     // bool，1 字节let z = &#x27;a&#x27;;      // char，4 字节let s : &amp;str = &#x27;hello&#x27;  //静态字符串切片,长度固定,在栈上\n\n\n堆 (Heap) 的特点\n\n\n内存大小运行时才能确定。\n\n需要手动申请（在 Rust 中由所有权系统管理，避免泄漏）。\n\n分配和释放开销比栈大，但适合存放 动态大小或不确定大小的数据。\n\n\n所有权机制堆和栈上数据都有所有权的这个概念,但是栈上数据拷贝时不会move(转移所有权),而是使用copy(复制一个样本),堆会move\n栈上的数据：如果它的类型实现了 Copy trait（比如 i32、bool、char、浮点数、简单元组），那么赋值时不会发生“严格意义上的 move”，而是直接 复制一份值。\n\n所以原变量不会失效，看起来像“转移没事”。\n\n实际上这不是“move”，而是 copy。\nfn main() &#123;    let x = 10;    let y = x;  // Copy，不是 move    println!(&quot;x=&#123;&#125;, y=&#123;&#125;&quot;, x, y); //  x 还能用&#125;\n\n堆上的数据：比如 String、Vec，它们没实现 Copy，赋值时会发生 move。\n\n所有权转移后，原变量会失效，防止两个变量同时指向同一块堆内存。\n\nfn main() &#123;    let s1 = String::from(&quot;hi&quot;);    let s2 = s1;   // Move    // println!(&quot;&#123;&#125;&quot;, s1); // 报错：s1 已经失效    println!(&quot;&#123;&#125;&quot;, s2);   //  只有 s2 能用了&#125;\n\n引用和可变引用:引用 (Reference)\n\n引用本质上就是 借用 (borrow)。\n\n借用不会转移所有权，值的所有者依然是原来的变量。\n\n分为：\n不可变引用 (&amp;T)：可以有多个，但不能和可变引用同时存在。\n可变引用 (&amp;mut T)：只能有一个，且不能和不可变引用共存。(可变引用要求被引用的变量是可变的)\n\n\nfn main() &#123;    let a:String =&quot;hello world&quot;.to_string();    let r1=&amp;a; //这里就算拷贝给r1,也能成功输出    println!(&quot;&#123;&#125;&quot;,a);&#125;\n\nclone的使用:#[derive(Debug,Clone)] //必须结构体里的所有字段都是可拷贝的，才可像正常u32，i32那样使用struct man&#123;    name:String,    age:u32&#125;fn main() &#123;    let a = man&#123;        name:&quot;原子&quot;.to_string(),        age:18    &#125;;    let m=a.clone();    println!(&quot;&#123;:?&#125;&quot;,a);&#125;\n\nclone就相当于c++中的深拷贝,解决了两个指针指向同一块内存的问题,所以clone之后就可以正常赋值,并接着使用\n生命周期:生命周期用语法 &#39;a 表示：\nfn example&lt;&#x27;a&gt;(s: &amp;&#x27;a str) &#123;    println!(&quot;&#123;&#125;&quot;, s);&#125;\n\n当结构体里有引用时，必须标注生命周期：\nstruct Person&lt;&#x27;a&gt; &#123;    name: &amp;&#x27;a str,    age: u32,&#125;fn main() &#123;    let name = String::from(&quot;Alice&quot;);    let p = Person &#123; name: &amp;name, age: 20 &#125;; // name 生命周期必须 ≥ p 生命周期&#125;\n\n生命周期的核心思想:引用永远不能比它指向的数据活得长。\n编译器在编译期检查生命周期，保证安全。\n&#39;a 是标识符，用来关联多个引用的生命周期。\n常用数据结构:String:&amp;str:是String类型的一个切片.长度确定放在栈上.\nString一般长度不确定,放在堆上\n创建:let s1 = String::new();              // 空字符串let s2 = String::from(&quot;hello&quot;);      // 从字面量创建let s3 = &quot;world&quot;.to_string();        // &amp;str 转 String\n\n添加:let mut s = String::from(&quot;Hello&quot;);s.push(&#x27;!&#x27;);          // 添加单个字符s.push_str(&quot; World&quot;); // 添加字符串切片\n\n拼接:let s1 = String::from(&quot;Hello&quot;);let s2 = String::from(&quot;World&quot;);// 使用 + 或 format! 宏let s3 = s1 + &amp;s2;           // s1 被移动，s2 被借用let s4 = format!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, &quot;!!!&quot;);  // 不移动任何变量\n\n获取长度和容量let s = String::from(&quot;hello&quot;);println!(&quot;length: &#123;&#125;&quot;, s.len());    // 字节数println!(&quot;capacity: &#123;&#125;&quot;, s.capacity()); // 堆上分配的容量\n\n删除内容let mut s = String::from(&quot;Hello World&quot;);s.pop();              // 删除最后一个字符s.clear();            // 清空整个字符串\n\n索引与切片let s = String::from(&quot;hello&quot;);// let c = s[0]; //  String 不支持直接索引let slice = &amp;s[0..2]; //  切片，返回 &amp;str，必须按字节边界\n\n查找和替换let s = String::from(&quot;hello world&quot;);println!(&quot;&#123;&#125;&quot;, s.contains(&quot;world&quot;));  // trueprintln!(&quot;&#123;&#125;&quot;, s.find(&quot;world&quot;).unwrap()); // 6，找到索引let new_s = s.replace(&quot;world&quot;, &quot;Rust&quot;);println!(&quot;&#123;&#125;&quot;, new_s); // hello Rust\n\n分割字符串let s = String::from(&quot;a,b,c&quot;);let v: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();println!(&quot;&#123;:?&#125;&quot;, v); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n\n遍历let s = String::from(&quot;hello&quot;);// 遍历字符for c in s.chars() &#123;    println!(&quot;&#123;&#125;&quot;, c);&#125;// 遍历字节for b in s.bytes() &#123;    println!(&quot;&#123;&#125;&quot;, b);&#125;\n\nVector:创建:let mut v: Vec&lt;i32&gt; = Vec::new();   // 空 vectorlet mut v = vec![1, 2, 3];          // 使用宏 vec! 初始化\n\n添加元素let mut v = Vec::new();v.push(10);   // 尾部插入v.push(20);\n\n访问元素let v = vec![1, 2, 3, 4];println!(&quot;&#123;&#125;&quot;, v[0]);        // 下标访问 (可能 panic 越界)println!(&quot;&#123;:?&#125;&quot;, v.get(2));  // 安全访问 -&gt; Some(3)println!(&quot;&#123;:?&#125;&quot;, v.get(10)); // None，不会 panic\n\n修改元素let mut v = vec![10, 20, 30];v[1] = 200;\n\n删除元素let mut v = vec![1, 2, 3, 4];v.pop();          // 删除最后一个 -&gt; Some(4)v.remove(0);      // 删除指定下标 -&gt; 返回删除的元素 (这里删除 1)\n\n遍历let v = vec![10, 20, 30];for x in &amp;v &#123;              // 只读遍历    println!(&quot;&#123;&#125;&quot;, x);&#125;for x in &amp;mut v &#123;          // 可修改遍历    *x += 1;&#125;\n\nHashMap:相当于c++中stl里的map\nuse std::collections::HashMap;fn main() &#123;    // 1. 创建一个 HashMap    let mut scores = HashMap::new();    // 2. 增加（插入）元素    scores.insert(&quot;Alice&quot;, 10);    scores.insert(&quot;Bob&quot;, 20);    // 3. 修改（如果 key 已存在，会覆盖旧值）    scores.insert(&quot;Alice&quot;, 30);  // Alice 的值从 10 -&gt; 30    // 4. 访问（用 get，返回 Option&lt;&amp;V&gt;）    if let Some(score) = scores.get(&quot;Alice&quot;) &#123;        println!(&quot;Alice 的分数是 &#123;&#125;&quot;, score);    &#125;    // 5. 删除（移除某个 key）    scores.remove(&quot;Bob&quot;);    println!(&quot;&#123;:?&#125;&quot;, scores);&#125;\n\n\n","categories":["rust逆向基础"],"tags":["rust"]},{"title":"vm逆向基础及做题套路","url":"/2025/10/06/vm%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/","content":"前言：学过计算机组成原理的应该都知道，程序的运行是靠cpu解释可执行文件中操作码来实现的功能，vm逆向顾名思义就是自己定义了小型cpu并定义了指令集，将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。\nvm逆向基本原理：vm_init：虚拟机的入口函数，对虚拟机环境进行初始化，初始化一般包括\n\n寄存器初始化(eax,ebx,ecx,edx,eip)\n\n把handle函数和操作码连接在一起\n\n给虚拟机的栈空间vm_stack分配内存\n\n\nvm_run:虚拟机开始运行的地方\nvm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。\nvm_handle:处理器，当rip走到对应操作码时调用对应操作函数，并接受操作数。\nopcode :程序可执行代码转换成的操作码\n在这种情况下，如果要逆向程序，就需要对整个emulator结构进行逆向，理解程序功能，还需要结合opcode进行分析，整个程序逆向工程将会十分繁琐。这是一个一般虚拟机结构：\nvm_lables:有的虚拟机涉及lable的创造和调用，起到跳转目的\n分析方法在比赛中，虚拟机题目常常有两种考法：\n\n给可执行程序和opcode，逆向emulator，结合opcode文件，推出flag\n\n只给可执行程序，逆向emulator，构造opcode，读取flag\n\n\n拿到一个虚拟机之后，一般有以下几个逆向过程：\n\n分析虚拟机入口，搞清虚拟机的输入，或者opcode位置\n\n理清虚拟机结构，包括Dispatcher和各个Handler\n\n逆向各个Handler，分析opcode的意义\n\n根据opcode运行时打印出对应汇编代码，根据汇编代码逻辑进行逆向\n\n\n一个简单vm虚拟机实例：vm_cpu结构体typedef struct&#123;    unsigned long r1;    //虚拟寄存器r1    unsigned long r2;    //虚拟寄存器r2    unsigned long r3;    //虚拟寄存器r3    unsigned char *eip;    //指向正在解释的opcode地址    vm_opcode op_list[OPCODE_N];    //opcode列表，存放了所有的opcode及其对应的处理函数&#125;vm_cpu;\n\nvm_opcode结构体typedef struct&#123;    unsigned char opcode;    void (*handle)(void*);&#125;vm_opcode;\n\nvm_init()void *vm_init()&#123;    vm_vpu *cpu;    cpu-&gt;r1 = 0;    cpu-&gt;r2 = 0;    cpu-&gt;r3 = 0;    cpu-&gt;eip = (unsigned char *)vm_code;//将eip指向opcode的地址    cpu-&gt;op_list[0].opcode = 0x1;    cpu-&gt;op_list[0].handle = (void (*)(void *))mov;//将操作字节码与对应的handle函数关联在一起    cpu-&gt;op_list[1].opcode = 0xf2;    cpu-&gt;op_list[1].handle = (void (*)(void *))xor;    cpu-&gt;op_list[2].opcode = 0xf5;    cpu-&gt;op_list[2].handle = (void (*)(void *))read_;    vm_stack = malloc(0x512);    memset(vm_stack,0,0x512);&#125;\n\nhandles(示例)void mov(vm_cpu *cpu);void xor(vm_cpu *cpu);    //xor flagvoid read_(vm_cpu *cpu);    //call read, read the flagvoid xor(vm_cpu *cpu)&#123;    int temp;    temp = cpu-&gt;r1 ^ cpu-&gt;r2;    temp ^= 0x12;    cpu-&gt;r1 = temp;    cpu-&gt;eip += 1;    //xor指令占一个字节&#125;void read_(vm_cpu *cpu)&#123;    char *dest = vm_stack;    read(0,dest,12);    //用于往虚拟机的栈上读取数据    cpu-&gt;eip += 1;    //read_指令占一个字节&#125;void mov(vm_cpu *cpu)&#123;    //mov指令的参数都因曾在字节码也就是vm_code中，指令表示后的一个字节是寄存器表示，第二到//第五是要mov的数据在vm_stack上的偏移    //这里只是实现了从vm_stack上取数据和存数据到vm_stack上    unsigned char *res = cpu-&gt;eip + 1;    //寄存器标识    int *offset = (int *)(cpu-&gt;eip + 2);    //寄存器在vm_stack上的偏移    char *dest = 0;    dest = vm_stack;    switch (*res) &#123;        case 0xe1:            cpu-&gt;r1 = *(dest + *offset);            break;           case 0xe2:            cpu-&gt;r2 = *(dest + *offset);            break;           case 0xe3:            cpu-&gt;r3 = *(dest + *offset);            break;           case 0xe4:        &#123;            int x = cpu-&gt;r1;            *(dest + *offset) = x;            break;        &#125;    &#125;       cpu-&gt;eip += 6;    //mov指令占六个字节，所以eip要向后移6位&#125;\n\nvm_code​unsigned char vm_code[] = &#123;    0xf5,    0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00,    0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00,    0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00,    0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00,    0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00,    0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00,    0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00,    0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00,    0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00,    0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00,    0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00,    0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00,    0xf4&#125;;​\n\nvm_stack一般是一个全局数组，用于存放虚拟机的栈\nvm_stack = malloc(0x512);memset(vm_stack,0,0x512);\n\n\n\nvm_runvoid vm_run(vm_cpu *cpu)&#123;    /*    进入虚拟机    eip指向要被解释的opcode地址    */    cpu-&gt;eip = (unsigned char*)opcodes;    while((*cpu-&gt;eip) != 0xf4)//如果opcode不为RET，就调用vm_dispatcher来解释执行    &#123;        vm_dispatcher(*cpu-&gt;eip)    &#125;&#125;\n\nvm_dispatchervoid vm_dispatcher(vm_cpu *cpu)&#123;    int i;    for(i = 0; i &lt; OPCODE_N; i++)    &#123;            if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode)        &#123;            cpu-&gt;op_list[i].handle(cpu);            break;        &#125;    &#125;&#125;\n\n\n\n做题流程：\n先根据上面的特征静态分析判断函数是vm中的哪一部分，如果静态分析困难，那就动调一下\n\n找到对应部分后创建上述结构体来帮助分析\n\n自己把vm还原在vscode里，并在dispatcher部分加上打印这条指令的代码，有的时候也可以打印stack，和当前执行完指令的内存状态(各个变量的值)\n\n根据打印出的汇编指令，手动逆向\n\n\n具体使用方法还需在实战中不断练习，具体做题流程可看我的vm题单真题\n参考文献：虚拟机逆向与实现-CSDN博客\n虚拟机保护逆向入门 - FreeBuf网络安全行业门户\n","categories":["vm逆向题单"],"tags":["vm逆向"]}]