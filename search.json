[{"title":"异常处理机制-SEH","url":"/2025/10/09/pe%E9%80%86%E5%90%91/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8A-SEH/","content":"SEH结构化异常处理（SEH）是 C 的Microsoft扩展，C++用于处理某些异常代码情况（如硬件故障）正常。 尽管 Windows 和 Microsoft C++支持 SEH，但我们建议在 C++ 代码中使用 ISO 标准C++异常处理。 它使代码更具可移植性和灵活性。 但是，若要维护现有代码或特定类型的程序，仍可能需要使用 SEH。\n异常出现流程：首先异常被交给内核态 / 最底层**\n当 CPU 检测到一个错误（如无效内存访问），它会中断当前进程，并将控制权交给 Windows 内核。内核会为进程创建一个异常记录（EXCEPTION_RECORD），其中包含异常代码、地址等信息。然后内核会查看进程是否正在被调试。\n\n如果进程被调试：内核将异常事件发送给调试器（第一机会异常）。调试器可以决定处理这个异常（继续执行）或不处理。\n\n如果进程未被调试，或调试器不处理：内核开始在用户态中寻找能处理这个异常的函数。\n\n\n如果异常未能被处理，则在用户态等待被veh处理，若无veh，则交给seh\n如果链式seh，veh未能处理，\n\n当进程中发生异常时,此时会调用系统的kernel32!UnhandledExceptionFIlter()API。\n该API会运行系统的最后一个异常处理器——Top Level Exception Filter或Last Exception Filter（通常行为是弹出错误消息框、终止进程）。\nkernel32!UnhandledExceptionFilter()调用了ntdll!QueryInformationProcess(ProcessDebugPort)。来判断是否正在调试进程。如果正在进行调试，则将异常传递给调试器。否则系统异常处理器终止进程。\n\nSEH结构体typedef struct _EXCEPTION_REGISTRATION_RECORD&#123;    // 链表以Next成员为FFFFFFFF的结构体结束，表示链表的最后一个结点    PEXCEPTION_REGISTRATION_RECORD Next;    // Handler：异常处理函数    PEXCEPTION_DISPOSITION Handler;&#125; EX\nSEH语法try-except-statement ：  __try compound-statement __except ( filter-expression ) compound-statementtry-finally-statement ：  __try compound-statement __finally compound-statement\n正向实例：(a) __try / __except - 异常处理程序#include &lt;windows.h&gt;#include &lt;excpt.h&gt;#include &lt;stdio.h&gt;int main() &#123;    __try &#123;        // 可能会引发异常的代码        int* p = NULL;        *p = 42; // 这将引发一个访问违规异常 (EXCEPTION_ACCESS_VIOLATION)    &#125;    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) &#123;        // 异常过滤器返回 EXCEPTION_EXECUTE_HANDLER 时，执行这个块        printf(&quot;Caught an access violation exception!\\n&quot;);        // 这里可以进行错误恢复、清理、记录日志等操作    &#125;    printf(&quot;Program continues after handling the exception.\\n&quot;);    return 0;&#125;\n\n__try 块：包含可能出错的代码。\n\n__except 块：异常处理程序。它是否能执行取决于其括号内的“异常过滤器表达式”。\n\n异常过滤器表达式：这是一个必须返回以下三个值之一的表达式：\n\nEXCEPTION_EXECUTE_HANDLER (1)： 执行处理程序。系统会展开堆栈（清理 __try 块中已构造的局部 C++ 对象可能会成为问题），然后跳转到 __except 块。\n\nEXCEPTION_CONTINUE_SEARCH (0)： 不处理。系统继续向上一个（外层）的异常处理程序寻找能处理的 __except 块。\n\nEXCEPTION_CONTINUE_EXECUTION (-1)： 继续执行。从异常发生处重新开始执行。极其危险！ 除非你能在过滤器里修复导致异常的问题（如虚拟内存分配），否则通常会立刻再次触发同一个异常，导致死循环。\n\n\n\n\n其中的GetExceptionCode()函数值包含EXCEPTION_ACCESS_VIOLATION, EXCEPTION_INT_DIVIDE_BY_ZERO, EXCEPTION_STACK_OVERFLOW等等，对应不同出错类型\n(b) __try / __finally - 终止处理程序这种结构不处理异常，而是保证无论 __try 块是如何退出的（正常执行完毕、return、goto、break 或由于异常），__finally 块中的代码一定会被执行。用于实现资源清理（如关闭文件、释放锁）。\nHANDLE hFile = INVALID_HANDLE_VALUE;__try &#123;    hFile = CreateFileA(&quot;test.txt&quot;, ...);    if (hFile == INVALID_HANDLE_VALUE) &#123;        __leave; // 跳转到 __finally 块的另一种方式    &#125;    // 对文件进行一些操作，可能会引发异常    SomeRiskyOperation(hFile);&#125;__finally &#123;    // 无论上面如何退出，这里都会执行    if (hFile != INVALID_HANDLE_VALUE) &#123;        CloseHandle(hFile);        hFile = INVALID_HANDLE_VALUE;    &#125;&#125;// 执行完 __finally 后，异常（如果有）会继续向外传播\n逆向实战：注意：32位pe和64位peSEH使用方式不同，注意甄别\n1.32位例题：.text:00401140                 push    ebp.text:00401141                 mov     ebp, esp.text:00401143                 push    0FFFFFFFEh.text:00401145                 push    offset stru_403758.text:0040114A                 push    offset SEH_401140.text:0040114F                 mov     eax, large fs:0.text:00401155                 push    eax\n在使用SEH的函数汇编你会看到这样一段\n第一第二行是创建函数的基本操作，这里不多解释，第三行0xFFFFFFFE叫做Trylevel/enclosing``\n-1 (0xFFFFFFFF) 表示：函数中没有任何 try/except（即编译器没生成 ScopeTable）。\n-2 (0xFFFFFFFE) 表示：函数有 ScopeTable，但当前没有任何激活的 try 块。\n所以翻译过来就是目前这个seh只有一层(还没进入try)，具体进入try的部分见什么修改了Trylevel,如下最后是try结束\n.text:004011B3                 mov     [ebp+ms_exc.registration.TryLevel], 0 //try开始.text:004011BA                 mov     [ebp+var_38], 0.text:004011C1                 mov     eax, [ebp+var_1C].text:004011C4                 mov     edx, [ebp+var_24].text:004011C7                 mov     ecx, [ebp+var_20].text:004011CA                 mov     ebx, [ebp+arg_0].text:004011CD                 div     [ebp+var_38]    //明显除0异常.text:004011D0                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh //try结束\n第4行push offset stru_403758\n\n把指向 .rdata 中 scope table（你之前贴的 stru_403758） 的地址压栈。\n\n这个表包含了 filter/handler 的地址、cookie 偏移等，运行时的异常处理器用它来决定哪个 try/except（或 finally）块应该响应当前异常\n\n\n第5行push offset SEH_401140\n\n把一个“handler 地址”或“该函数专用的异常处理 stub”的地址压栈。IDA 给它取名为 SEH_401140（或许是个局部的 handler/veneer）。\n\n当异常发生并且运行时走到这个注册记录时，系统会调用这个 handler（这个 handler 通常是编译器生成的代码 / 运行时枢纽，它会读取 scope table，调用相应的 filter/handler 函数\n\n\n第6行mov eax, large fs:0\n\n从 fs:[0] 读取当前线程的 SEH 链表头（在 x86 Windows 中，FS 段基址指向 TIB，TIB 的第一个 dword 就是 SEH 链表头）。large 是汇编器的语法，表示读取完整的 32 位值。\n\n把当前链表头（即“之前的注册记录”的指针）读出来保存到 EAX。\n\n\n第7行push eax\n\n把旧的 fs:[0]（即之前的链表头）压栈 —— 这就是新注册记录的 Next 字段（保存链表的前驱，以便函数退出时能恢复）。\n\n在压栈/设置 fs:[0] 后，新的记录就会被插到链表最前面，变成当前活动的异常注册记录。\n\n\n退出函数时解除seh\nloc_401268:    mov     ecx, [ebp+ms_exc.registration.Next]    mov     large fs:0, ecx        ; 恢复 fs:[0] = 上一个 SEH 节点    pop     ecx    pop     edi    pop     esi    pop     ebx    mov     esp, ebp    pop     ebp    retn\n总结逆向流程：我们需要在stru_403758找到相应的过滤函数，和处理异常函数，该题中\n                stru_403758     dd 0FFFFFFFEh           ; GSCookieOffset.rdata:00403758                                         ; DATA XREF: sub_401140+5↑o.rdata:0040375C                 dd 0                    ; GSCookieXOROffset.rdata:00403760                 dd 0FFFFFFB0h           ; EHCookieOffset.rdata:00403764                 dd 0                    ; EHCookieXOROffset.rdata:00403768                 dd 0FFFFFFFEh           ; ScopeRecord.EnclosingLevel.rdata:0040376C                 dd offset loc_4011D9    ; ScopeRecord.FilterFunc.rdata:00403770                 dd offset loc_4011DF    ; ScopeRecord.HandlerFunc\n前3个没什么用，第四个是我们上面的Trylevel，第5个是过滤函数，第6个是我们的处理函数，也就是ctf中反调试替换掉的逻辑\n               loc_4011D9:                             ; DATA XREF: .rdata:stru_403758↓o.text:004011D9                 mov     eax, 1.text:004011DE                 retn.text:004011DF ; ---------------------------------------------------------------------------.text:004011DF.text:004011DF loc_4011DF:                             ; DATA XREF: .rdata:stru_403758↓o.text:004011DF                 mov     esp, [ebp+ms_exc.old_esp].text:004011E2                 mov     edi, [ebp+var_24].text:004011E5                 mov     ecx, edi.text:004011E7                 shr     ecx, 4.text:004011EA                 mov     eax, edi.text:004011EC                 shl     eax, 5.text:004011EF                 xor     ecx, eax.text:004011F1                 add     ecx, edi.text:004011F3                 mov     eax, [ebp+arg_0].text:004011F6                 mov     eax, [eax].text:004011F8                 add     eax, [ebp+var_20].text:004011FB                 xor     ecx, eax.text:004011FD                 xor     [ebp+var_1C], ecx.text:00401200                 push    offset Buffer   ; &quot;Something happend...&quot;.text:00401205                 call    ds:puts.text:0040120B                 add     esp, 4.text:0040120E                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh.text:00401215                 mov     esi, [ebp+var_28]\n这里过滤函数返回值保存在eax中，这里也就是返回了1，说明EXCEPTION_EXECUTE_HANDLER要处理这个异常，把原函数逻辑替换为下面的处理函数然后就可以接着进行逆向分析了，try中遇到error，那条出错指令汇编跳过，执行exception指令，然后执行try{}下面的语句。\n","categories":["pe逆向","反调试技术"],"tags":["反调试技术"]},{"title":"rust逆向基础-rust基础语法","url":"/2025/10/01/rust%E9%80%86%E5%90%91%E9%A2%98%E5%8D%95/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","content":"前言:拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下\nrust相比其他编程语言的优势:\nrust不通过GC(garbage collection)机制管理内存,例如python,golang等基于GC机制的编程语言会在exe运行时不断寻找虚拟地址中无用的内存空间.这会大大降低运行速度\n\nrust使用所有权机制管理内存,这也使得它相比与手动开辟内存的c/c++更安全\n\n\n我们rust在逆向中通常用于网络编程,游戏编程,wasm,嵌入式.所以写游戏外挂,实现检测外挂都必须要学习rust.\n语法:变量:rust中变量声明要用let.rust中每个变量类型可以自己指定,也可交给编译器推断,每个变量类型可以声明可变也可声明不可变.(注:如果要声明常量类型时,常量名一定要全大写,并且必须显示指定类型.例如const MAX:u32=10;)\n整数类型\n有符号：i8, i16, i32, i64, i128, isize\n\n无符号：u8, u16, u32, u64, u128, usize\n\n\n浮点数\nf32（32 位单精度）\n\nf64（64 位双精度，默认）\n\n\n布尔型\ntrue\n\nfalse\n\n\nchar型字符串型\n&amp;str → 字符串切片（不可变）\n\nString → 堆分配的可变字符串\n\n\nfn main() &#123;    let n: i32= 5; // 变量后的：i32可以自己指定，也可让编译器推断    let mut i: u32 = 5; // u32 表示32位无符号整数,mut表示可变    println!(&quot;The value of n is &#123;&#125;&quot;,n); // println! 用来打印字符串到终端，n代表换行，!代表宏    println!(&quot;The value of i is &#123;&#125;&quot;,i);    i=7;    println!(&quot;The value of i is &#123;&#125;&quot;,i);    let x: f64 = 5.2;    println!(&quot;The value of x is &#123;&#125;&quot;,x);    let y: char =&#x27;d&#x27;;    println!(&quot;The value of y is &#123;&#125;&quot;,y);    let t=true;    println!(&quot;The value of t is &#123;&#125;&quot;,t);    let str: &amp;str=&quot;hello&quot;;    println!(&quot;The value of str is &#123;&#125;&quot;,str);    let mut s2: String = String::from(&quot;Hello&quot;);    s2.push_str(&quot;, Rust!&quot;);        // 可变字符串    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n输出结果:\nThe value of n is 5The value of i is 5The value of i is 7The value of x is 5.2The value of y is dThe value of t is trueThe value of str is helloHello, Rust!\n控制语句:if-else if-else// iflet n = 5;if n &lt; 0 &#123;    println!(&quot;负数&quot;);&#125; else &#123;    println!(&quot;非负数&quot;);&#125;\n循环\nloop 一直循环\n\nwhile 有条件的循环\n\nfor\n\n\n可以通过break跳出循环,也可以通过continue继续当前循环.这和c++是一样的\n// looplet mut counter = 0;let result = loop &#123;    counter += 1;    if counter == 10 &#123;        break counter * 2; // 返回值    &#125;&#125;;// whilelet mut i = 3;while i &gt; 0 &#123;    println!(&quot;&#123;&#125;&quot;, i);    i -= 1;&#125;// forlet arr = [10, 20, 30];for val in arr &#123;    println!(&quot;&#123;&#125;&quot;, val);&#125;\nMatchmatch的用法和if-else很像,但是要注意match要把所有情况包含在内,不然编译阶段就报错\nlet x = 5;match x &#123;    1 | 2 =&gt; println!(&quot;一或二&quot;),    3..=7 =&gt; println!(&quot;三到七之间&quot;), // 范围匹配    _ =&gt; println!(&quot;其他&quot;),&#125;\n函数函数使用基本的函数定义是fn fucnction(a:i32,b:i32) -&gt; i32其中箭头右面的是返回值类型.rust函数表达力非常强\nfn add(a:i32,b:i32)-&gt;i32&#123;    a+b //不加分号，rust会将最后一行作为返回值&#125;fn main() &#123;    let a=1;    let b=3;    let res=add(a,b);    println!(&quot;&#123;&#125;&quot;,res);//println!()是rust的输出函数，其中第一个参数必须是&quot;&quot;包裹的字符串(不能用&#x27;&#x27;替代)，第二个参数是占位符，占位符的值通过&#123;&#125;来传递&#125;\n闭包:闭包可以理解成python里的lambda差不多,相当于匿名函数\nfn main() &#123;    let sum=|a:i32,b:i32|-&gt;i32&#123;a+b&#125;;//这里定义时是用||包裹参数，调用时和正常函数一样    let res=sum(1,2);    println!(&quot;The sum is &#123;&#125;&quot;,res);&#125;\nrust复合类型枚举:简单来说，枚举（enum）就是用来表示“一个值可能属于几种互斥情况之一”，也就是“有限状态或选择”。\n换句话说，它适合表示有多种可能性，但每次只能选一个的场景。\nenum TrafficLight &#123;    Red,    Yellow,    Green,&#125;let light = TrafficLight::Red;match light &#123;    TrafficLight::Red =&gt; println!(&quot;停&quot;),    TrafficLight::Yellow =&gt; println!(&quot;准备&quot;),    TrafficLight::Green =&gt; println!(&quot;走&quot;),&#125;\n结构体基础:结构体和enum不一样的点在于声明结构体时,要把内部变量的类型写出来.而enum就不用\n其中对#[derive(Debug)]的解释:\n\n\n\n\n部分\n含义\n记忆小技巧\n\n\n\n\n#[]\nRust 的 属性（attribute）标记，用来告诉编译器对后面的结构体/枚举做某些处理\n“井号括号 → 给编译器的指令”\n\n\nderive\n自动 派生/生成实现 trait 的代码\n“derive = 自动生成某种功能”\n\n\n(Debug)\n指定生成的 trait 是 Debug\n“Debug = 调试打印能力”\n\n\n\n\n#[derive(Debug)]struct Node&#123;    x: i32,    y: i32&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    println!(&quot;&#123;&#125;&quot;, x);    println!(&quot;&#123;&#125;&quot;, y);    println!(&quot;&#123;:?&#125;&quot;, n); //打印结构体或enum类型，要用&#123;:?&#125;,配合结构体定义上方的#[derive(Debug)]打印结构体&#125;\n结构体进阶:Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 key: value 语法来实现定义：\n实例化时:\n结构体类名 {    字段名 : 字段值,    …}\n(1)在结构体内部用impl关键字实现内联函数:\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn area(x:i32,y:i32)-&gt;i32&#123;        x*y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    let s=Node::area(x, y);    println!(&quot;&#123;&#125;&quot;,s);&#125;\n (2)用结构体中self指针实现\nstruct Node&#123;    x: i32,    y: i32,&#125;// impl Node&#123;//     fn area(x:i32,y:i32)-&gt;i32&#123;//         x*y//     &#125;// &#125;impl Node&#123;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    //let s=Node::area(x, y);    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n(3)结构体实现构造函数\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn new(x:i32,y:i32)-&gt;Self&#123;//默认构造函数名都叫new，但这不是个关键字        Node&#123;            x:x,            y:y        &#125;    &#125;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node::new(1,2);    let x=n.x;    let y=n.y;    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n(4)self的用法:\n\nself 小写 = 当前对象实例指针。\n\nSelf 大写 = 当前类型名。\n\n\nself指针也分为可变和不可变的,可变的要在self前加关键字mut\n#[derive(Debug)]struct Person&#123;    name:String,    age:u32&#125;impl Person&#123;    fn new(name:String,age:u32)-&gt;Self&#123;        Person&#123;name,age&#125;    &#125;    //不可变的this指针    fn greet(&amp;self)-&gt;String&#123;        format!(&quot;Hello,my name is &#123;&#125; and I am &#123;&#125; years old.&quot;,self.name,self.age)    &#125;    //可变的this指针    fn up_age(&amp;mut self)-&gt;u32&#123;        self.age+=1;        self.age    &#125;&#125;fn main() &#123;    let a=Person::new(&quot;原子&quot;.to_string(), 18); //“原子”是静态str.&amp;str类型，要转成可变的String    println!(&quot;&#123;:#?&#125;&quot;,a); //&#123;:#?&#125;是调试格式，和&#123;:?&#125;的区别是，&#123;:#?&#125;会多出缩进，方便阅读    println!(&quot;&#123;&#125;&quot;,a.greet());    let mut b =a;    b.up_age();    println!(&quot;&#123;&#125;&quot;,b.greet());&#125;\n输出:\nPerson &#123;    name: &quot;原子&quot;,    age: 18,&#125;Hello,my name is 原子 and I am 18 years old.Hello,my name is 原子 and I am 19 years old.\nself还有一个不经常用的用法:就是如果传入参数是self(不带&amp;)的话:\nstruct Node &#123;    x: i32,    y: i32,&#125;impl Node &#123;    // 这里的 self 是按值传递，意味着把 Node 本身交给这个方法    fn into_tuple(self) -&gt; (i32, i32) &#123;        (self.x, self.y)    &#125;&#125;fn main() &#123;    let n = Node &#123; x: 1, y: 2 &#125;;    let t = n.into_tuple();  //  这里 n 被 move 走    println!(&quot;&#123;:?&#125;&quot;, t);    // println!(&quot;&#123;:?&#125;&quot;, n.x); //  报错：因为 n 的所有权已经交出，不能再用&#125;\n元组:1.基本定义:元组就是把多个不同类型的值组合在一起的复合类型。语法：\nlet tup: (i32, f64, char) = (500, 6.4, &#x27;a&#x27;);\n2.访问元素\n有两种方式：\n方式一：解构\nlet tup = (500, 6.4, &#x27;a&#x27;);let (x, y, z) = tup;println!(&quot;y 的值是: &#123;&#125;&quot;, y);\n方式二：点语法（下标访问）\n注意第一个元素下标是0\nlet tup = (500, 6.4, &#x27;a&#x27;);println!(&quot;第一个元素是: &#123;&#125;&quot;, tup.0);println!(&quot;第二个元素是: &#123;&#125;&quot;, tup.1);println!(&quot;第三个元素是: &#123;&#125;&quot;, tup.2);\n3.特点:可以包含不同类型的值\n长度固定，不能改变\n4.打印可利用{:?}来打印\n核心机制&amp;数据结构栈和堆存放\n栈 (Stack) 的特点\n\n\n后进先出 (LIFO) 的数据结构，内存分配和释放都非常快。\n\n大小在编译时必须确定。\n\n栈上的数据一般是 固定大小、生命周期明确的值。\n\n\nlet x = 42;       // i32，大小固定 4 字节let y = true;     // bool，1 字节let z = &#x27;a&#x27;;      // char，4 字节let s : &amp;str = &#x27;hello&#x27;  //静态字符串切片,长度固定,在栈上\n\n堆 (Heap) 的特点\n\n\n内存大小运行时才能确定。\n\n需要手动申请（在 Rust 中由所有权系统管理，避免泄漏）。\n\n分配和释放开销比栈大，但适合存放 动态大小或不确定大小的数据。\n\n\n所有权机制堆和栈上数据都有所有权的这个概念,但是栈上数据拷贝时不会move(转移所有权),而是使用copy(复制一个样本),堆会move\n栈上的数据：如果它的类型实现了 Copy trait（比如 i32、bool、char、浮点数、简单元组），那么赋值时不会发生“严格意义上的 move”，而是直接 复制一份值。\n\n所以原变量不会失效，看起来像“转移没事”。\n\n实际上这不是“move”，而是 copy。\nfn main() &#123;    let x = 10;    let y = x;  // Copy，不是 move    println!(&quot;x=&#123;&#125;, y=&#123;&#125;&quot;, x, y); //  x 还能用&#125;\n堆上的数据：比如 String、Vec，它们没实现 Copy，赋值时会发生 move。\n\n所有权转移后，原变量会失效，防止两个变量同时指向同一块堆内存。\n\nfn main() &#123;    let s1 = String::from(&quot;hi&quot;);    let s2 = s1;   // Move    // println!(&quot;&#123;&#125;&quot;, s1); // 报错：s1 已经失效    println!(&quot;&#123;&#125;&quot;, s2);   //  只有 s2 能用了&#125;\n引用和可变引用:引用 (Reference)\n\n引用本质上就是 借用 (borrow)。\n\n借用不会转移所有权，值的所有者依然是原来的变量。\n\n分为：\n不可变引用 (&amp;T)：可以有多个，但不能和可变引用同时存在。\n可变引用 (&amp;mut T)：只能有一个，且不能和不可变引用共存。(可变引用要求被引用的变量是可变的)\n\n\nfn main() &#123;    let a:String =&quot;hello world&quot;.to_string();    let r1=&amp;a; //这里就算拷贝给r1,也能成功输出    println!(&quot;&#123;&#125;&quot;,a);&#125;\nclone的使用:#[derive(Debug,Clone)] //必须结构体里的所有字段都是可拷贝的，才可像正常u32，i32那样使用struct man&#123;    name:String,    age:u32&#125;fn main() &#123;    let a = man&#123;        name:&quot;原子&quot;.to_string(),        age:18    &#125;;    let m=a.clone();    println!(&quot;&#123;:?&#125;&quot;,a);&#125;\nclone就相当于c++中的深拷贝,解决了两个指针指向同一块内存的问题,所以clone之后就可以正常赋值,并接着使用\n生命周期:生命周期用语法 &#39;a 表示：\nfn example&lt;&#x27;a&gt;(s: &amp;&#x27;a str) &#123;    println!(&quot;&#123;&#125;&quot;, s);&#125;\n当结构体里有引用时，必须标注生命周期：\nstruct Person&lt;&#x27;a&gt; &#123;    name: &amp;&#x27;a str,    age: u32,&#125;fn main() &#123;    let name = String::from(&quot;Alice&quot;);    let p = Person &#123; name: &amp;name, age: 20 &#125;; // name 生命周期必须 ≥ p 生命周期&#125;\n生命周期的核心思想:引用永远不能比它指向的数据活得长。\n编译器在编译期检查生命周期，保证安全。\n&#39;a 是标识符，用来关联多个引用的生命周期。\n常用数据结构:String:&amp;str:是String类型的一个切片.长度确定放在栈上.\nString一般长度不确定,放在堆上\n创建:let s1 = String::new();              // 空字符串let s2 = String::from(&quot;hello&quot;);      // 从字面量创建let s3 = &quot;world&quot;.to_string();        // &amp;str 转 String\n添加:let mut s = String::from(&quot;Hello&quot;);s.push(&#x27;!&#x27;);          // 添加单个字符s.push_str(&quot; World&quot;); // 添加字符串切片\n拼接:let s1 = String::from(&quot;Hello&quot;);let s2 = String::from(&quot;World&quot;);// 使用 + 或 format! 宏let s3 = s1 + &amp;s2;           // s1 被移动，s2 被借用let s4 = format!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, &quot;!!!&quot;);  // 不移动任何变量\n获取长度和容量let s = String::from(&quot;hello&quot;);println!(&quot;length: &#123;&#125;&quot;, s.len());    // 字节数println!(&quot;capacity: &#123;&#125;&quot;, s.capacity()); // 堆上分配的容量\n删除内容let mut s = String::from(&quot;Hello World&quot;);s.pop();              // 删除最后一个字符s.clear();            // 清空整个字符串\n索引与切片let s = String::from(&quot;hello&quot;);// let c = s[0]; //  String 不支持直接索引let slice = &amp;s[0..2]; //  切片，返回 &amp;str，必须按字节边界\n查找和替换let s = String::from(&quot;hello world&quot;);println!(&quot;&#123;&#125;&quot;, s.contains(&quot;world&quot;));  // trueprintln!(&quot;&#123;&#125;&quot;, s.find(&quot;world&quot;).unwrap()); // 6，找到索引let new_s = s.replace(&quot;world&quot;, &quot;Rust&quot;);println!(&quot;&#123;&#125;&quot;, new_s); // hello Rust\n分割字符串let s = String::from(&quot;a,b,c&quot;);let v: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();println!(&quot;&#123;:?&#125;&quot;, v); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n遍历let s = String::from(&quot;hello&quot;);// 遍历字符for c in s.chars() &#123;    println!(&quot;&#123;&#125;&quot;, c);&#125;// 遍历字节for b in s.bytes() &#123;    println!(&quot;&#123;&#125;&quot;, b);&#125;\nVector:创建:let mut v: Vec&lt;i32&gt; = Vec::new();   // 空 vectorlet mut v = vec![1, 2, 3];          // 使用宏 vec! 初始化\n添加元素let mut v = Vec::new();v.push(10);   // 尾部插入v.push(20);\n访问元素let v = vec![1, 2, 3, 4];println!(&quot;&#123;&#125;&quot;, v[0]);        // 下标访问 (可能 panic 越界)println!(&quot;&#123;:?&#125;&quot;, v.get(2));  // 安全访问 -&gt; Some(3)println!(&quot;&#123;:?&#125;&quot;, v.get(10)); // None，不会 panic\n修改元素let mut v = vec![10, 20, 30];v[1] = 200;\n删除元素let mut v = vec![1, 2, 3, 4];v.pop();          // 删除最后一个 -&gt; Some(4)v.remove(0);      // 删除指定下标 -&gt; 返回删除的元素 (这里删除 1)\n遍历let v = vec![10, 20, 30];for x in &amp;v &#123;              // 只读遍历    println!(&quot;&#123;&#125;&quot;, x);&#125;for x in &amp;mut v &#123;          // 可修改遍历    *x += 1;&#125;\nHashMap:相当于c++中stl里的map\nuse std::collections::HashMap;fn main() &#123;    // 1. 创建一个 HashMap    let mut scores = HashMap::new();    // 2. 增加（插入）元素    scores.insert(&quot;Alice&quot;, 10);    scores.insert(&quot;Bob&quot;, 20);    // 3. 修改（如果 key 已存在，会覆盖旧值）    scores.insert(&quot;Alice&quot;, 30);  // Alice 的值从 10 -&gt; 30    // 4. 访问（用 get，返回 Option&lt;&amp;V&gt;）    if let Some(score) = scores.get(&quot;Alice&quot;) &#123;        println!(&quot;Alice 的分数是 &#123;&#125;&quot;, score);    &#125;    // 5. 删除（移除某个 key）    scores.remove(&quot;Bob&quot;);    println!(&quot;&#123;:?&#125;&quot;, scores);&#125;\n","categories":["rust逆向基础"],"tags":["rust"]},{"title":"异常处理机制-VEH","url":"/2025/10/09/pe%E9%80%86%E5%90%91/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8B-VEH/","content":"VEH这是 SEH 的一个增强扩展，通过 AddVectoredExceptionHandler 添加。VEH 处理器会在调试器和所有 SEH 处理器之前被调用。它们更像是一种“通知”机制，可以观察或拦截进程中的所有异常。\n与veh有关的函数\n\n\n\n函数名\n作用\n参数解释\n\n\n\n\nAddVectoredExceptionHandler\n注册一个新的向量化异常处理函数（VEH）。注册后，当线程出现异常（例如访问违规、除零、RaiseException）时，系统会回调你提供的函数。\nULONG FirstHandler：是否把此 handler 放在最前面。 1 → 高优先级（最先被调用） 0 → 低优先级（放在队列后面）PVECTORED_EXCEPTION_HANDLER VectoredHandler：回调函数地址，函数类型为 LONG CALLBACK handler(EXCEPTION_POINTERS* ExceptionInfo)。返回值控制异常是否继续传播。\n\n\nRemoveVectoredExceptionHandler\n移除已注册的 VEH。\nPVOID HandlerHandle：AddVectoredExceptionHandler 返回的句柄。\n\n\nRaiseException\n主动抛出一个软件异常，会触发 VEH。\nDWORD dwExceptionCode：异常码（自定义或系统定义）。DWORD dwExceptionFlags：是否可继续执行。0 表示可继续，EXCEPTION_NONCONTINUABLE 表示不可继续。DWORD nNumberOfArguments：额外参数个数。*_const ULONG_PTR _lpArguments__：异常参数数组（可选）。\n\n\nEXCEPTION_POINTERS\nVEH 的回调参数结构，包含异常上下文。\n成员有两个：ExceptionRecord：描述异常的详细信息（代码、参数、地址等）。ContextRecord：保存异常发生时 CPU 的寄存器状态（Rip/Eip, Rsp/Esp, Rax, Rcx…）。可读写！修改后返回 EXCEPTION_CONTINUE_EXECUTION 可以改变执行流。\n\n\n\n\n正向实例：// veh_demo.cpp#include &lt;windows.h&gt;#include &lt;iostream&gt;using namespace std;// ======================= 1. 被“隐藏”的函数 =======================void SecretFunc()&#123;    cout &lt;&lt; &quot;[SecretFunc] VEH 修改 RIP 后跳转到这里执行！&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！&quot; &lt;&lt; endl;    ExitProcess(0);&#125;// ======================= 2. VEH 回调函数 =======================LONG CALLBACK MyVectoredHandler(EXCEPTION_POINTERS* ExceptionInfo)&#123;    cout &lt;&lt; &quot;[VEH] 异常捕获！&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;  ExceptionCode: 0x&quot; &lt;&lt; hex &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode &lt;&lt; endl;    cout &lt;&lt; &quot;  ExceptionAddress: &quot; &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress &lt;&lt; endl;    // 判断是不是我们自己触发的异常（0xDEADC0DE）    if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == 0xDEADC0DE)    &#123;        cout &lt;&lt; &quot;[VEH] 捕获到自定义异常，修改上下文...&quot; &lt;&lt; endl;#ifdef _M_X64        ExceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)&amp;SecretFunc; // x64#else        ExceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;SecretFunc;   // x86#endif        // 返回 EXCEPTION_CONTINUE_EXECUTION，让程序从修改后的地址继续执行        return EXCEPTION_CONTINUE_EXECUTION;    &#125;    // 其他异常交给系统处理    return EXCEPTION_CONTINUE_SEARCH;&#125;// ======================= 3. 主函数 =======================int main()&#123;    cout &lt;&lt; &quot;[Main] 注册 VEH...&quot; &lt;&lt; endl;    // 注册 VEH，优先级高    PVOID hHandler = AddVectoredExceptionHandler(1, MyVectoredHandler);    if (!hHandler)    &#123;        cerr &lt;&lt; &quot;AddVectoredExceptionHandler failed! error=&quot; &lt;&lt; GetLastError() &lt;&lt; endl;        return 1;    &#125;    cout &lt;&lt; &quot;[Main] 准备触发自定义异常...&quot; &lt;&lt; endl;    // 手动触发异常    RaiseException(0xDEADC0DE, 0, 0, nullptr);    cout &lt;&lt; &quot;[Main] 如果看到这行，说明 VEH 没有拦截执行流。&quot; &lt;&lt; endl;    // 移除 VEH    RemoveVectoredExceptionHandler(hHandler);    return 0;&#125;\n输出：\n[Main] 注册 VEH...[Main] 准备触发自定义异常...[VEH] 异常捕获！  ExceptionCode: 0xdeadc0de  ExceptionAddress: 00007FF6F8B21000[VEH] 捕获到自定义异常，修改上下文...[SecretFunc] VEH 修改 RIP 后跳转到这里执行！[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！\n总结：\n\n\n\n函数\n用途\n常用返回\n\n\n\n\nAddVectoredExceptionHandler\n注册 VEH\n返回 handler 句柄\n\n\nRemoveVectoredExceptionHandler\n移除 VEH\n成功返回非 0\n\n\nRaiseException\n主动抛出异常\n会调用 VEH\n\n\nMyVectoredHandler\n回调处理异常\n返回 CONTINUE_EXECUTION 或 CONTINUE_SEARCH\n\n\nExceptionInfo-&gt;ContextRecord\n保存寄存器上下文\n可修改以改变执行流\n\n\n\n\n","categories":["pe逆向","反调试技术"],"tags":["反调试技术"]},{"title":"vm逆向基础及做题套路","url":"/2025/10/06/vm%E9%80%86%E5%90%91/vm%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/","content":"前言：学过计算机组成原理的应该都知道，程序的运行是靠cpu解释可执行文件中操作码来实现的功能，vm逆向顾名思义就是自己定义了小型cpu并定义了指令集，将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。\nvm逆向基本原理：vm_init：虚拟机的入口函数，对虚拟机环境进行初始化，初始化一般包括\n\n寄存器初始化(eax,ebx,ecx,edx,eip)\n\n把handle函数和操作码连接在一起\n\n给虚拟机的栈空间vm_stack分配内存\n\n\nvm_run:虚拟机开始运行的地方\nvm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。\nvm_handle:处理器，当rip走到对应操作码时调用对应操作函数，并接受操作数。\nopcode :程序可执行代码转换成的操作码\n在这种情况下，如果要逆向程序，就需要对整个emulator结构进行逆向，理解程序功能，还需要结合opcode进行分析，整个程序逆向工程将会十分繁琐。这是一个一般虚拟机结构：\nvm_lables:有的虚拟机涉及lable的创造和调用，起到跳转目的\n分析方法在比赛中，虚拟机题目常常有两种考法：\n\n给可执行程序和opcode，逆向emulator，结合opcode文件，推出flag\n\n只给可执行程序，逆向emulator，构造opcode，读取flag\n\n\n拿到一个虚拟机之后，一般有以下几个逆向过程：\n\n分析虚拟机入口，搞清虚拟机的输入，或者opcode位置\n\n理清虚拟机结构，包括Dispatcher和各个Handler\n\n逆向各个Handler，分析opcode的意义\n\n根据opcode运行时打印出对应汇编代码，根据汇编代码逻辑进行逆向\n\n\n一个简单vm虚拟机实例：vm_cpu结构体typedef struct&#123;    unsigned long r1;    //虚拟寄存器r1    unsigned long r2;    //虚拟寄存器r2    unsigned long r3;    //虚拟寄存器r3    unsigned char *eip;    //指向正在解释的opcode地址    vm_opcode op_list[OPCODE_N];    //opcode列表，存放了所有的opcode及其对应的处理函数&#125;vm_cpu;\nvm_opcode结构体typedef struct&#123;    unsigned char opcode;    void (*handle)(void*);&#125;vm_opcode;\nvm_init()void *vm_init()&#123;    vm_vpu *cpu;    cpu-&gt;r1 = 0;    cpu-&gt;r2 = 0;    cpu-&gt;r3 = 0;    cpu-&gt;eip = (unsigned char *)vm_code;//将eip指向opcode的地址    cpu-&gt;op_list[0].opcode = 0x1;    cpu-&gt;op_list[0].handle = (void (*)(void *))mov;//将操作字节码与对应的handle函数关联在一起    cpu-&gt;op_list[1].opcode = 0xf2;    cpu-&gt;op_list[1].handle = (void (*)(void *))xor;    cpu-&gt;op_list[2].opcode = 0xf5;    cpu-&gt;op_list[2].handle = (void (*)(void *))read_;    vm_stack = malloc(0x512);    memset(vm_stack,0,0x512);&#125;\nhandles(示例)void mov(vm_cpu *cpu);void xor(vm_cpu *cpu);    //xor flagvoid read_(vm_cpu *cpu);    //call read, read the flagvoid xor(vm_cpu *cpu)&#123;    int temp;    temp = cpu-&gt;r1 ^ cpu-&gt;r2;    temp ^= 0x12;    cpu-&gt;r1 = temp;    cpu-&gt;eip += 1;    //xor指令占一个字节&#125;void read_(vm_cpu *cpu)&#123;    char *dest = vm_stack;    read(0,dest,12);    //用于往虚拟机的栈上读取数据    cpu-&gt;eip += 1;    //read_指令占一个字节&#125;void mov(vm_cpu *cpu)&#123;    //mov指令的参数都因曾在字节码也就是vm_code中，指令表示后的一个字节是寄存器表示，第二到//第五是要mov的数据在vm_stack上的偏移    //这里只是实现了从vm_stack上取数据和存数据到vm_stack上    unsigned char *res = cpu-&gt;eip + 1;    //寄存器标识    int *offset = (int *)(cpu-&gt;eip + 2);    //寄存器在vm_stack上的偏移    char *dest = 0;    dest = vm_stack;    switch (*res) &#123;        case 0xe1:            cpu-&gt;r1 = *(dest + *offset);            break;           case 0xe2:            cpu-&gt;r2 = *(dest + *offset);            break;           case 0xe3:            cpu-&gt;r3 = *(dest + *offset);            break;           case 0xe4:        &#123;            int x = cpu-&gt;r1;            *(dest + *offset) = x;            break;        &#125;    &#125;       cpu-&gt;eip += 6;    //mov指令占六个字节，所以eip要向后移6位&#125;\nvm_code​unsigned char vm_code[] = &#123;    0xf5,    0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00,    0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00,    0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00,    0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00,    0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00,    0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00,    0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00,    0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00,    0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00,    0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00,    0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00,    0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00,    0xf4&#125;;​\nvm_stack一般是一个全局数组，用于存放虚拟机的栈\nvm_stack = malloc(0x512);memset(vm_stack,0,0x512);\nvm_runvoid vm_run(vm_cpu *cpu)&#123;    /*    进入虚拟机    eip指向要被解释的opcode地址    */    cpu-&gt;eip = (unsigned char*)opcodes;    while((*cpu-&gt;eip) != 0xf4)//如果opcode不为RET，就调用vm_dispatcher来解释执行    &#123;        vm_dispatcher(*cpu-&gt;eip)    &#125;&#125;\nvm_dispatchervoid vm_dispatcher(vm_cpu *cpu)&#123;    int i;    for(i = 0; i &lt; OPCODE_N; i++)    &#123;            if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode)        &#123;            cpu-&gt;op_list[i].handle(cpu);            break;        &#125;    &#125;&#125;\n做题流程：\n先根据上面的特征静态分析判断函数是vm中的哪一部分，如果静态分析困难，那就动调一下\n\n找到对应部分后创建上述结构体来帮助分析\n\n自己把vm还原在vscode里，并在dispatcher部分加上打印这条指令的代码，有的时候也可以打印stack，和当前执行完指令的内存状态(各个变量的值)\n\n根据打印出的汇编指令，手动逆向\n\n\n具体使用方法还需在实战中不断练习，具体做题流程可看我的vm题单真题\n参考文献：虚拟机逆向与实现-CSDN博客\n虚拟机保护逆向入门 - FreeBuf网络安全行业门户\n","categories":["vm逆向题单"],"tags":["vm逆向"]},{"title":"[GWCTF 2019] babyvm","url":"/2025/10/07/vm%E9%80%86%E5%90%91/%5BGWCTF%202019%5Dbabyvm/","content":"前言：这道题算非常经典的vm题了，用这道题来熟悉一下vm题基本流程\n正文：创建结构体：\n有三个函数我们点进去看一下具体逻辑\n\n第一个函数很明显就是vm_init的结构，我们改名为vm_init,并创建结构体帮助静态分析\n\n在空白部分右键，添加结构体\n\n结构体名就叫vm_cpu，下面按d键快捷键给它增加成员变量\n光标对准vm_cpu struc点一次d是在最前面增加成员变量\n对准field_0点一次d是更改一次field_0的类型,也可按y直接输入类型\n对准vm_cpu ends点一次d是在末尾增加成员变量\n\n接下来修改成员变量的名称按n快捷键，改为eax，ebx等\n由于vm_cpu中有个数组叫oplist[]\n我们先创建新结构体\nstruct opcode&#123;    QWORD _opcode;    QWORD handle;&#125;;\n这里稍微再提一下怎么确定每个成员变量占多少字节，不要看ida给你强转出来的类型，而要看上下成员之间的差值，比如(_BYTE )(a1 + 24) = -15;和(_QWORD )(a1 + 32) = sub_B5F;从a1+24到a1+32，占了8个字节。所以这里_opcode类型是qword。下面是全部改完之后的结构体\n\n再回到第一个函数，对准函数参数列表按y，把a1类型改为vm_cpu*，然后函数就变得美观了，下面的qword_2022A8是给vm设置的栈空间，我们也可以改名vm_stack\n\n第二个函数很容易看出来是vm_run,分发器控制程序执行，第三个函数是验证flag正确与否，就不展开讲了\n第二个函数把参数也改成vm_cpu*\nunsigned __int64 __fastcall vm_run(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_rip = (__int64)&amp;unk_202060;  while ( *(_BYTE *)a1-&gt;vm_rip != 0xF4 )    sub_E6E(a1);  return __readfsqword(0x28u) ^ v2;&#125;\n我们看到逻辑已经很明确了，就是rip指向的地址对应的值不等于0xf4时，一直调用sub_E6E\nunsigned __int64 __fastcall sub_E6E(vm_cpu *a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; *(_BYTE *)a1-&gt;vm_rip != LOBYTE(a1-&gt;oplist[i]._opcode); ++i )    ;  ((void (__fastcall *)(vm_cpu *))a1-&gt;oplist[i].handle)(a1);  return __readfsqword(0x28u) ^ v3;&#125;\nsub_E6E点进去就发现和我们的vm基础里的dispatcher结构一模一样，现在我们回头处理一下没命名的handle函数就可以正式逆向了\n识别函数：1.mov函数unsigned __int64 __fastcall sub_B5F(vm_cpu *a1)&#123;  int *v2; // [rsp+28h] [rbp-18h]  unsigned __int64 v3; // [rsp+38h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = (int *)(a1-&gt;vm_rip + 2);  switch ( *(_BYTE *)(a1-&gt;vm_rip + 1) )  &#123;    case 0xE1:      a1-&gt;vm_eax = *((char *)vm_stack + *v2);      break;    case 0xE2:      a1-&gt;vm_ebx = *((char *)vm_stack + *v2);      break;    case 0xE3:      a1-&gt;vm_ecx = *((char *)vm_stack + *v2);      break;    case 0xE4:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_eax;      break;    case 0xE5:      a1-&gt;vm_edx = *((char *)vm_stack + *v2);      break;    case 0xE7:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_ebx;      break;    default:      break;  &#125;  a1-&gt;vm_rip += 6LL;  return __readfsqword(0x28u) ^ v3;&#125;\n这个函数的意思是，v2是栈中偏移，相当于ss:[ebp+v2]=vm_stack[v2],当操作码=-15也就是0xF1的时候，调用这个函数，下一个地址的数(_BYTE )(a1-&gt;vm_rip+1))就是选择码，(_BYTE )(a1-&gt;vm_rip+2))就是操作数\n\n选择码=0xE1 执行mov eax ss:[ebp+v2]\n\n选择码=0xE2 执行mov ebx ss:[ebp+v2]\n\n选择码=0xE3 执行mov ecx ss:[ebp+v2]\n\n选择码=0xE4 执行mov ss:[ebp+v2] eax \n\n选择码=0xE5 执行mov edx ss:[ebp+v2]\n\n选择码=0xE7 执行mov ss:[ebp+v2] ebx \n\n\n2.xorunsigned __int64 __fastcall sub_A64(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax ^= a1-&gt;vm_ebx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n相当于xor eax ebx\n3.readunsigned __int64 __fastcall sub_AC5(vm_cpu *a1)&#123;  const char *buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  buf = (const char *)vm_stack;  read(0, vm_stack, 0x20uLL);  dword_2022A4 = strlen(buf);  if ( dword_2022A4 != 21 )  &#123;    puts(&quot;WRONG!&quot;);    exit(0);  &#125;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\n把flag读入栈上\n相当于call read,并判断flag长度\n4.nopunsigned __int64 __fastcall sub_956(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n什么都没干，rip只是加1，这是所有指令都要有的\n5.mulunsigned __int64 __fastcall sub_A08(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax *= a1-&gt;vm_edx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\nmul eax edx\n6.xchgunsigned __int64 __fastcall sub_8F0(vm_cpu *a1)&#123;  int vm_eax; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  vm_eax = a1-&gt;vm_eax;  a1-&gt;vm_eax = a1-&gt;vm_ebx;  a1-&gt;vm_ebx = vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\nxchg eax ebx\n7.自定义函数unsigned __int64 __fastcall sub_99C(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax = a1-&gt;vm_ecx + 2 * a1-&gt;vm_ebx + 3 * a1-&gt;vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n实现了eax=ecx+2ebx+3eax应该是自定义指令\n自己实现dispatcher，汇编层面逆向#include&lt;iostream&gt;using namespace std;int opcode[]=&#123;0xF5, 0xF1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x20, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x01, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x21, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x22, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x03, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x23,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x24, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x25, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x26, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x27, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x28, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x09, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x29, 0x00, 0x00,   0x00, 0xF1, 0xE1, 0x0A, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x2A, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0B, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x2B, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0C,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2C, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2D,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x2E, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0F, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2F, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x10, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x30, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x11, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x31, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x12, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x32, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x13, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x33, 0x00, 0x00,   0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0xF1,   0xE1, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x01, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x01, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x02, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x01, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x03, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x02, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x03, 0x00,   0x00, 0x00, 0xF1, 0xE2, 0x04, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x03, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x05, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x04, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x05,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x06, 0x00, 0x00, 0x00, 0xF1,   0xE2, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x08, 0x00, 0x00,   0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6, 0xF7, 0xF1,   0xE4, 0x06, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x08, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x09,   0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6,   0xF7, 0xF1, 0xE4, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x09, 0x00, 0x00, 0x00, 0xF1,   0xE3, 0x0A, 0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00,   0x00, 0xF6, 0xF7, 0xF1, 0xE4, 0x08, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x13, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x13, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x12, 0x00, 0x00, 0x00, 0xF8, 0xF1, 0xE4, 0x0E,   0x00, 0x00, 0x00, 0xF1, 0xE7, 0x12, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x11, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x11, 0x00, 0x00, 0x00, 0xF4&#125;;int main()&#123;    int rip=0;    int vm_eax=0;    int vm_ebx=18;    int vm_ecx=0;    int vm_edx=0;    int vm_stack[521];    for(int i=0;i&lt;521;i++)    &#123;        vm_stack[i]=0;    &#125;    int len = sizeof(opcode) / sizeof(opcode[0]);    while (rip&lt;len)    &#123;        if(opcode[rip]==0xF1)        &#123;            int v2=opcode[rip+2];            switch(opcode[rip+1])            &#123;                case 0xE1:                    vm_eax = vm_stack[v2];                    cout&lt;&lt;&quot;mov eax,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE2:                    vm_ebx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ebx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE3:                    vm_ecx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ecx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE4:                    vm_stack[v2] = vm_eax;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],eax&quot;&lt;&lt;endl;                    break;                case 0xE5:                    vm_edx = vm_stack[v2];                    cout&lt;&lt;&quot;mov edx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE7:                    vm_stack[v2] = vm_ebx;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],ebx&quot;&lt;&lt;endl;                    break;                default:                    break;            &#125;            rip+=6;            continue;        &#125;        else if(opcode[rip]==0xF2)        &#123;            vm_eax^=vm_ebx;            cout&lt;&lt;&quot;xor eax ebx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF5)        &#123;            // for(int i=0;i&lt;21;i++)            // &#123;            //     char c;            //     cin&gt;&gt;c;            //     vm_stack[i]=c;            // &#125;            cout&lt;&lt;&quot;read flag&amp;&amp;judge len&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xf4)        &#123;            cout&lt;&lt;&quot;nop&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF6)        &#123;            vm_eax=vm_ecx+2*vm_ebx+3*vm_eax;            cout&lt;&lt;&quot;eax=ecx+2*ebx+3*eax&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF7)        &#123;            vm_eax*=vm_edx;            cout&lt;&lt;&quot;mul eax edx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF8)        &#123;            int t = vm_eax;            vm_eax = vm_ebx;            vm_ebx = t;            cout&lt;&lt;&quot;xchg eax ebx&quot;&lt;&lt;endl;        &#125;        rip++;    &#125;&#125;\n这里其实可以把栈信息一起打印出来的，但是这道题非常简单没有涉及到栈的其他操作，只是简单把flag放在栈上，所以这里不打印了\n结果：\nread flag&amp;&amp;judge lenmov eax,stack[0]xor eax ebxmov stack[32],eaxmov eax,stack[1]xor eax ebxmov stack[33],eaxmov eax,stack[2]xor eax ebxmov stack[34],eaxmov eax,stack[3]xor eax ebxmov stack[35],eaxmov eax,stack[4]xor eax ebxmov stack[36],eaxmov eax,stack[5]xor eax ebxmov stack[37],eaxmov eax,stack[6]xor eax ebxmov stack[38],eaxmov eax,stack[7]xor eax ebxmov stack[39],eaxmov eax,stack[8]xor eax ebxmov stack[40],eaxmov eax,stack[9]xor eax ebxmov stack[41],eaxmov eax,stack[10]xor eax ebxmov stack[42],eaxmov eax,stack[11]xor eax ebxmov stack[43],eaxmov eax,stack[12]xor eax ebxmov stack[44],eaxmov eax,stack[13]xor eax ebxmov stack[45],eaxmov eax,stack[14]xor eax ebxmov stack[46],eaxmov eax,stack[15]xor eax ebxmov stack[47],eaxmov eax,stack[16]xor eax ebxmov stack[48],eaxmov eax,stack[17]xor eax ebxmov stack[49],eaxmov eax,stack[18]xor eax ebxmov stack[50],eaxmov eax,stack[19]xor eax ebxmov stack[51],eaxnopread flag&amp;&amp;judge lenmov eax,stack[0]mov ebx,stack[1]xor eax ebxmov stack[0],eaxmov eax,stack[1]mov ebx,stack[2]xor eax ebxmov stack[1],eaxmov eax,stack[2]mov ebx,stack[3]xor eax ebxmov stack[2],eaxmov eax,stack[3]mov ebx,stack[4]xor eax ebxmov stack[3],eaxmov eax,stack[4]mov ebx,stack[5]xor eax ebxmov stack[4],eaxmov eax,stack[5]mov ebx,stack[6]xor eax ebxmov stack[5],eaxmov eax,stack[6]mov ebx,stack[7]mov ecx,stack[8]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[6],eaxmov eax,stack[7]mov ebx,stack[8]mov ecx,stack[9]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[7],eaxmov eax,stack[8]mov ebx,stack[9]mov ecx,stack[10]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[8],eaxmov eax,stack[13]mov ebx,stack[19]xchg eax ebxmov stack[13],eaxmov stack[19],ebxmov eax,stack[14]mov ebx,stack[18]xchg eax ebxmov stack[14],eaxmov stack[18],ebxmov eax,stack[15]mov ebx,stack[17]xchg eax ebxmov stack[15],eaxmov stack[17],ebxnop\n正常一道普通的vm逆向题到这里看汇编逆向写exp就结束了，但这道题还有坑\n题外话：解题：这道题汇编前半部分很明显不对，因为flag总长度才21，栈上怎么索引到50多了，所以交叉引用找到真正的check函数,而且汇报中有两次输入，第二次输入才是真的\nunsigned __int64 sub_F00()&#123;  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; len_flag - 1 &gt; i; ++i )  &#123;    if ( *((_BYTE *)vm_stack + i) != byte_202020[i] )      exit(0);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\nexp：\nfrom z3 import *import re# 密文（十六进制字符串）flag = &#x27;69 45 2A 37 09 17 C5 0B 5C 72 33 76 33 21 74 31 5F 33 73 72&#x27;.split(&#x27; &#x27;)flag = [int(x, 16) for x in flag]# 1) 还原前面的三次交换（你在 forward 阶段做了 13&lt;-&gt;19, 14&lt;-&gt;18, 15&lt;-&gt;17）flag[15], flag[17] = flag[17], flag[15]flag[14], flag[18] = flag[18], flag[14]flag[19], flag[13] = flag[13], flag[19]# 2) 用 Z3 求解 a6,a7,a8（原始 stack[6..8]）# 方程（forward）是： f6 = (s8 + 2*s7 + 3*s6) * s12  （全部为字节运算）a6, a7, a8 = BitVecs(&#x27;a6 a7 a8&#x27;, 8)s = Solver()# 注意：这里 flag[...] 是 Python 整数（0..255），Z3 会自动把它转为相应的常量。# 若你想更严格地把所有算术限定为 8-bit，可把常量也包装成 BitVecVal(...,8)。s.add( BitVecVal(flag[6],8) == (a8 + (a7 &lt;&lt; 1) + a6 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[7],8) == (BitVecVal(flag[9],8)  + (a8 &lt;&lt; 1) + a7 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[8],8) == (BitVecVal(flag[10],8) + (BitVecVal(flag[9],8) &lt;&lt; 1) + a8 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )if s.check() == sat:    m = s.model()    # 把求得的 a6,a7,a8 写回 flag 对应位置    for v in [a6, a7, a8]:        idx = int(re.search(r&#x27;\\d+&#x27;, str(v)).group())        flag[idx] = m[v].as_long()# 3) 逆向 XOR 链（forward 做了 f0 = s0^s1; f1 = s1^s2; ...; f5 = s5^s6）for i in range(5, -1, -1):    flag[i] ^= flag[i + 1]print(&#x27;[+] flag: &#x27;, &#x27;&#x27;.join(chr(x) for x in flag))# [+] flag:  Y0u_hav3_r3v3rs3_1t!\n ","categories":["vm逆向题单"],"tags":["vm逆向","ctf"]},{"title":"安卓逆向环境配置","url":"/2025/10/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"前言：某些安卓题强制要求arm环境才能跑，模拟器不管是脱壳还是动调都有很多问题，最近搞了个真机重新配一遍安卓逆向环境\nroot手机","categories":["安卓逆向"],"tags":["安卓逆向"]},{"title":"逆向中的AES(二)","url":"/2025/10/09/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/aes2/","content":"前言：逆向工程中往往使用aes加密的程序不是用的查表法aes，就是用的白盒aes，让你难以分析，傻乎乎的使用aes基础算法很容易被破解\n查表法实现的aes：在前一篇文章中我们详细讲解了AES的每一轮中具体的四层结构，以加密过程为例分别是：字节代换层、行移位层、列混淆层和轮密钥加层\n对于查表法实现，就是要将每一轮中的前三层操作(字节代换层、行移位层和列混淆层)合并为查找表。\n查表法的核心思想是将字节代换层、ShiftRows层和MixColumn层融合为查找表：每个表的大小是32 bits(4字节)乘以256项，一般称为T盒(T-Box)或T表。加密过程4个表(Te)，解密过程4个表(Td)，共8个。每一轮操作都通过16次查表产生。\n算法中定义T表实现为：\nT0[x] = (2·S[x])&lt;&lt;24 | (S[x])&lt;&lt;16 | (S[x])&lt;&lt;8 | (3·S[x])T1[x] = (3·S[x])&lt;&lt;24 | (2·S[x])&lt;&lt;16 | (S[x])&lt;&lt;8 | (S[x])T2[x] = (S[x])&lt;&lt;24 | (3·S[x])&lt;&lt;16 | (2·S[x])&lt;&lt;8 | (S[x])T3[x] = (S[x])&lt;&lt;24 | (S[x])&lt;&lt;16 | (3·S[x])&lt;&lt;8 | (2·S[x])\n其中：\n\nS[x] 是 S-box 输出；\n\n2·S[x] 表示有限域 GF(2^8) 下的乘法（即 xtime 运算）。\n\n\n原理：由于aes加密流程中的字节代换和行移位可随意更改顺序而不影响加密结果，所以，我们把行移位放在最前面\n\n先不管行移位，把行移位之后的矩阵状态设为\n\n\\begin{bmatrix}\na_0 & a_4 & a_8 & a_{12} \\\\\na_1 & a_5 & a_9 & a_{13} \\\\\na_2 & a_6 & a_{10} & a_{14} \\\\\na_3 & a_7 & a_{11} & a_{15}\n\\end{bmatrix}只看第一列的变化，设\na0' = S[a0]a1' = S[a1]a2' = S[a2]a3' = S[a3]\n\n\\begin{bmatrix}\nc_0 \\\\ c_1 \\\\ c_2 \\\\ c_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n2 & 3 & 1 & 1 \\\\\n1 & 2 & 3 & 1 \\\\\n1 & 1 & 2 & 3 \\\\\n3 & 1 & 1 & 2\n\\end{bmatrix}\n\\begin{bmatrix}\na_0' \\\\ a_1' \\\\ a_2' \\\\ a_3'\n\\end{bmatrix}c0 = 2·a0' ⊕ 3·a1' ⊕ 1·a2' ⊕ 1·a3'c1 = 1·a0' ⊕ 2·a1' ⊕ 3·a2' ⊕ 1·a3'c2 = 1·a0' ⊕ 1·a1' ⊕ 2·a2' ⊕ 3·a3'c3 = 3·a0' ⊕ 1·a1' ⊕ 1·a2' ⊕ 2·a3'\nT0[x] = (2·S[x], S[x], S[x], 3·S[x])   // 合并为一个 32 位值T1[x] = (3·S[x], 2·S[x], S[x], S[x])T2[x] = (S[x], 3·S[x], 2·S[x], S[x])T3[x] = (S[x], S[x], 3·S[x], 2·S[x])\n所以\nT0[a0] = [2·S[a0], S[a0], S[a0], 3·S[a0]]T1[a1] = [3·S[a1], 2·S[a1], S[a1], S[a1]]T2[a2] = [S[a2], 3·S[a2], 2·S[a2], S[a2]]T3[a3] = [S[a3], S[a3], 3·S[a3], 2·S[a3]]\n于是\nc0c1c2c3 = T0[a0] ⊕ T1[a1] ⊕ T2[a2] ⊕ T3[a3]\n现在再来考虑行移位的影响，只要把a1-a15的对应标号改掉就行\nt0 = T0[a0] ^ T1[a5] ^ T2[a10] ^ T3[a15] ^ roundKey[0];t1 = T0[a4] ^ T1[a9] ^ T2[a14] ^ T3[a3]  ^ roundKey[1];t2 = T0[a8] ^ T1[a13]^ T2[a2]  ^ T3[a7]  ^ roundKey[2];t3 = T0[a12]^ T1[a1] ^ T2[a6]  ^ T3[a11] ^ roundKey[3];\n是最后加密的结果\n代码实现：#include &lt;stdlib.h&gt;#ifndef AES_H#define AES_H#include &lt;stdint.h&gt;typedef struct AES_Key {    uint32_t* ek;  // AES加密轮密钥    uint32_t* dk;  // AES 解密轮密钥    uint32_t nr;   //加密轮数} AES_Key;int AES_KeyInit(uint8_t* key, AES_Key* aes_key, size_t bits);void AES_Encrypt(uint8_t* plaintext, uint8_t* ciphertext, AES_Key aes_key);void AES_Decrypt(uint8_t* ciphertext, uint8_t* plaintext, AES_Key aes_key);void AES_KeyDelete(AES_Key aes_key);#endifstatic const uint8_t Sbox[256] = {    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B,    0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26,    0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,    0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED,    0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F,    0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC,    0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14,    0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,    0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F,    0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11,    0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F,    0xB0, 0x54, 0xBB, 0x16 };static const uint32_t TE[256] = {    0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd,    0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d,    0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d,    0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,    0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7,    0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,    0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4,    0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,    0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1,    0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,    0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e,    0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,    0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e,    0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c,    0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46,    0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,    0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7,    0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81,    0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe,    0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,    0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a,    0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,    0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2,    0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,    0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e,    0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,    0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256,    0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,    0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4,    0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,    0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa,    0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,    0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1,    0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,    0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42,    0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,    0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158,    0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,    0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22,    0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,    0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631,    0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,    0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a };static const uint32_t TD[256] = {    0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1,    0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25,    0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67,    0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,    0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3,    0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd,    0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182,    0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,    0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2,    0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5,    0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492,    0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a,    0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa,    0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46,    0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997,    0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb,    0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48,    0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927,    0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f,    0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,    0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad,    0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd,    0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc,    0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,    0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3,    0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422,    0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1,    0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,    0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8,    0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3,    0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4,    0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,    0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331,    0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815,    0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d,    0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,    0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252,    0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89,    0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f,    0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,    0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c,    0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190,    0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742 };#define rotr32(value, shift) ((value &gt;&gt; shift) ^ (value &lt;&lt; (32 - shift)))int AES_KeyInit(uint8_t* key, AES_Key* aes_key, size_t bits) {    uint32_t Rcon[10] = { 0x01, 0x02, 0x04, 0x08, 0x10,                         0x20, 0x40, 0x80, 0x1B, 0x36 };  //轮常数    uint32_t nr = 10 + (bits - 128) / 32;                //加密轮数 Nr    uint32_t nk = bits / 32;                             //密钥字数 Nk    uint32_t tmp, tmp1;    aes_key-&gt;nr = nr;    //-----------malloc-------------    uint32_t* w = (uint32_t*)malloc(sizeof(uint32_t) * 4 * (nr + 1));    if (w == (void*)0) {        return 0;    }    uint32_t* d = (uint32_t*)malloc(sizeof(uint32_t) * 4 * (nr + 1));    if (d == (void*)0) {        free(d);        return 0;    }    //--------------Load as BigEndian---------------    for (int i = 0; i &lt; nk; i++) {//将总的bits，每32个（四个字节）分一组，每一组用大端序来进行表示        w[i] = (key[4 * i + 0] &lt;&lt; 24) | (key[4 * i + 1] &lt;&lt; 16) |            (key[4 * i + 2] &lt;&lt; 8) | (key[4 * i + 3]);    }    //------------KeyExpand-----------------    for (int i = nk; i &lt; 4 * (nr + 1); i++) {        tmp = w[i - 1];        if (i % nk == 0) {            /* tmp = SubWord(RotWord(w[i-1])) */            tmp1 = tmp;            tmp = Sbox[(tmp1 &gt;&gt; 24) &amp; 0xFF];            tmp |= Sbox[(tmp1 &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 8;            tmp |= Sbox[(tmp1 &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 16;            tmp |= (Sbox[(tmp1 &gt;&gt; 16) &amp; 0xFF] ^ Rcon[i / nk - 1]) &lt;&lt; 24;        }        else if (nk &gt; 6 &amp;&amp; i % nk == 4) {            /* temp = SubWord(w[i-1]) */            tmp1 = tmp;            tmp = Sbox[(tmp1 &gt;&gt; 0) &amp; 0xFF];            tmp |= Sbox[(tmp1 &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;            tmp |= Sbox[(tmp1 &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;            tmp |= Sbox[(tmp1 &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;        }        w[i] = w[i - nk] ^ tmp;    }    aes_key-&gt;ek = w;    //------------TransKey-----------    for (int i = 0; i &lt; 4; i++) {        d[i] = w[i];    }    for (int i = 4; i &lt; 4 * nr; i++) {        //-----------MixCol IV-----------        d[i] = TD[Sbox[(w[i] &gt;&gt; 24) &amp; 0xFF]];        tmp = TD[Sbox[(w[i] &gt;&gt; 16) &amp; 0xFF]];        d[i] ^= rotr32(tmp, 8);        tmp = TD[Sbox[(w[i] &gt;&gt; 8) &amp; 0xFF]];        d[i] ^= rotr32(tmp, 16);        tmp = TD[Sbox[(w[i] &gt;&gt; 0) &amp; 0xFF]];        d[i] ^= rotr32(tmp, 24);    }    for (int i = 0; i &lt; 4; i++) {        d[4 * nr + i] = w[4 * nr + i];    }    aes_key-&gt;dk = d;    return 1;}void AES_KeyDelete(AES_Key aes_key) {    free(aes_key.ek);    free(aes_key.dk);}void AES_Encrypt(uint8_t* plaintext, uint8_t* ciphertext, AES_Key aes_key) {    uint32_t s[4];    uint32_t t[4];    uint32_t tmp;    //------------Load as BigEndian------------------    for (int i = 0; i &lt; 4; i++) {        s[i] = (plaintext[4 * i + 0] &lt;&lt; 24) | (plaintext[4 * i + 1] &lt;&lt; 16) |            (plaintext[4 * i + 2] &lt;&lt; 8) | (plaintext[4 * i + 3]);    }    //----------------AddRoundKey----------------    s[0] ^= aes_key.ek[0];    s[1] ^= aes_key.ek[1];    s[2] ^= aes_key.ek[2];    s[3] ^= aes_key.ek[3];    for (int i = 1; i &lt; aes_key.nr; i++) {        //-------ShiftRow + SubByte + MixCol-------------        // t0        t[0] = TE[(s[0] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[1] &gt;&gt; 16) &amp; 0xFF];        t[0] ^= rotr32(tmp, 8);        tmp = TE[(s[2] &gt;&gt; 8) &amp; 0xFF];        t[0] ^= rotr32(tmp, 16);        tmp = TE[(s[3] &gt;&gt; 0) &amp; 0xFF];        t[0] ^= rotr32(tmp, 24);        // t1        t[1] = TE[(s[1] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[2] &gt;&gt; 16) &amp; 0xFF];        t[1] ^= rotr32(tmp, 8);        tmp = TE[(s[3] &gt;&gt; 8) &amp; 0xFF];        t[1] ^= rotr32(tmp, 16);        tmp = TE[(s[0] &gt;&gt; 0) &amp; 0xFF];        t[1] ^= rotr32(tmp, 24);        // t2        t[2] = TE[(s[2] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[3] &gt;&gt; 16) &amp; 0xFF];        t[2] ^= rotr32(tmp, 8);        tmp = TE[(s[0] &gt;&gt; 8) &amp; 0xFF];        t[2] ^= rotr32(tmp, 16);        tmp = TE[(s[1] &gt;&gt; 0) &amp; 0xFF];        t[2] ^= rotr32(tmp, 24);        // t3        t[3] = TE[(s[3] &gt;&gt; 24) &amp; 0xFF];        tmp = TE[(s[0] &gt;&gt; 16) &amp; 0xFF];        t[3] ^= rotr32(tmp, 8);        tmp = TE[(s[1] &gt;&gt; 8) &amp; 0xFF];        t[3] ^= rotr32(tmp, 16);        tmp = TE[(s[2] &gt;&gt; 0) &amp; 0xFF];        t[3] ^= rotr32(tmp, 24);        //-------------AddRoundKey---------------        s[0] = t[0] ^ aes_key.ek[4 * i + 0];        s[1] = t[1] ^ aes_key.ek[4 * i + 1];        s[2] = t[2] ^ aes_key.ek[4 * i + 2];        s[3] = t[3] ^ aes_key.ek[4 * i + 3];    }    //------------ShiftRow + SubByte-----------    // t0    t[0] = Sbox[(s[0] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[0] |= Sbox[(s[1] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[0] |= Sbox[(s[2] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[0] |= Sbox[(s[3] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t1    t[1] = Sbox[(s[1] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[1] |= Sbox[(s[2] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[1] |= Sbox[(s[3] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[1] |= Sbox[(s[0] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t2    t[2] = Sbox[(s[2] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[2] |= Sbox[(s[3] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[2] |= Sbox[(s[0] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[2] |= Sbox[(s[1] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t3    t[3] = Sbox[(s[3] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[3] |= Sbox[(s[0] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[3] |= Sbox[(s[1] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[3] |= Sbox[(s[2] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    //------------AddRoundKey-------------    s[0] = t[0] ^ aes_key.ek[4 * aes_key.nr + 0];    s[1] = t[1] ^ aes_key.ek[4 * aes_key.nr + 1];    s[2] = t[2] ^ aes_key.ek[4 * aes_key.nr + 2];    s[3] = t[3] ^ aes_key.ek[4 * aes_key.nr + 3];    //-----------Store as BigEndian--------------    for (int i = 0; i &lt; 4; i++) {        ciphertext[4 * i + 0] = (s[i] &gt;&gt; 24) &amp; 0xFF;        ciphertext[4 * i + 1] = (s[i] &gt;&gt; 16) &amp; 0xFF;        ciphertext[4 * i + 2] = (s[i] &gt;&gt; 8) &amp; 0xFF;        ciphertext[4 * i + 3] = (s[i] &gt;&gt; 0) &amp; 0xFF;    }}void AES_Decrypt(uint8_t* ciphertext, uint8_t* plaintext, AES_Key aes_key) {    uint32_t s[4];    uint32_t t[4];    uint32_t tmp;    //------------Load as BigEndian------------------    for (int i = 0; i &lt; 4; i++) {        s[i] = (ciphertext[4 * i + 0] &lt;&lt; 24) | (ciphertext[4 * i + 1] &lt;&lt; 16) |            (ciphertext[4 * i + 2] &lt;&lt; 8) | (ciphertext[4 * i + 3]);    }    //----------------AddRoundKey----------------    s[0] ^= aes_key.dk[4 * aes_key.nr + 0];    s[1] ^= aes_key.dk[4 * aes_key.nr + 1];    s[2] ^= aes_key.dk[4 * aes_key.nr + 2];    s[3] ^= aes_key.dk[4 * aes_key.nr + 3];    for (int i = aes_key.nr - 1; i &gt; 0; i--) {        //-------ShiftRow IV + SubByte IV + MixCol IV-------------        // t0        t[0] = TD[(s[0] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[3] &gt;&gt; 16) &amp; 0xFF];        t[0] ^= rotr32(tmp, 8);        tmp = TD[(s[2] &gt;&gt; 8) &amp; 0xFF];        t[0] ^= rotr32(tmp, 16);        tmp = TD[(s[1] &gt;&gt; 0) &amp; 0xFF];        t[0] ^= rotr32(tmp, 24);        // t1        t[1] = TD[(s[1] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[0] &gt;&gt; 16) &amp; 0xFF];        t[1] ^= rotr32(tmp, 8);        tmp = TD[(s[3] &gt;&gt; 8) &amp; 0xFF];        t[1] ^= rotr32(tmp, 16);        tmp = TD[(s[2] &gt;&gt; 0) &amp; 0xFF];        t[1] ^= rotr32(tmp, 24);        // t2        t[2] = TD[(s[2] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[1] &gt;&gt; 16) &amp; 0xFF];        t[2] ^= rotr32(tmp, 8);        tmp = TD[(s[0] &gt;&gt; 8) &amp; 0xFF];        t[2] ^= rotr32(tmp, 16);        tmp = TD[(s[3] &gt;&gt; 0) &amp; 0xFF];        t[2] ^= rotr32(tmp, 24);        // t3        t[3] = TD[(s[3] &gt;&gt; 24) &amp; 0xFF];        tmp = TD[(s[2] &gt;&gt; 16) &amp; 0xFF];        t[3] ^= rotr32(tmp, 8);        tmp = TD[(s[1] &gt;&gt; 8) &amp; 0xFF];        t[3] ^= rotr32(tmp, 16);        tmp = TD[(s[0] &gt;&gt; 0) &amp; 0xFF];        t[3] ^= rotr32(tmp, 24);        //-------------AddRoundKey---------------        s[0] = t[0] ^ aes_key.dk[4 * i + 0];        s[1] = t[1] ^ aes_key.dk[4 * i + 1];        s[2] = t[2] ^ aes_key.dk[4 * i + 2];        s[3] = t[3] ^ aes_key.dk[4 * i + 3];    }    //------------ShiftRow + SubByte-----------    // t0    t[0] = SboxIV[(s[0] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[0] |= SboxIV[(s[3] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[0] |= SboxIV[(s[2] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[0] |= SboxIV[(s[1] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t1    t[1] = SboxIV[(s[1] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[1] |= SboxIV[(s[0] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[1] |= SboxIV[(s[3] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[1] |= SboxIV[(s[2] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t2    t[2] = SboxIV[(s[2] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[2] |= SboxIV[(s[1] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[2] |= SboxIV[(s[0] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[2] |= SboxIV[(s[3] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    // t3    t[3] = SboxIV[(s[3] &gt;&gt; 24) &amp; 0xFF] &lt;&lt; 24;    t[3] |= SboxIV[(s[2] &gt;&gt; 16) &amp; 0xFF] &lt;&lt; 16;    t[3] |= SboxIV[(s[1] &gt;&gt; 8) &amp; 0xFF] &lt;&lt; 8;    t[3] |= SboxIV[(s[0] &gt;&gt; 0) &amp; 0xFF] &lt;&lt; 0;    //------------AddRoundKey-------------    s[0] = t[0] ^ aes_key.dk[0];    s[1] = t[1] ^ aes_key.dk[1];    s[2] = t[2] ^ aes_key.dk[2];    s[3] = t[3] ^ aes_key.dk[3];    //-----------Store as BigEndian--------------    for (int i = 0; i &lt; 4; i++) {        plaintext[4 * i + 0] = (s[i] &gt;&gt; 24) &amp; 0xFF;        plaintext[4 * i + 1] = (s[i] &gt;&gt; 16) &amp; 0xFF;        plaintext[4 * i + 2] = (s[i] &gt;&gt; 8) &amp; 0xFF;        plaintext[4 * i + 3] = (s[i] &gt;&gt; 0) &amp; 0xFF;    }}int main() {    AES_Key aes_key;    // 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17    // 18 19 1a 1b 1c 1d 1e 1f    uint8_t key[256 / 8] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,                            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,                            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,                            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f };    // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff    uint8_t plaintext[16] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff };    uint8_t ciphertext[16];    //-----------AES 128-------------------    int success = AES_KeyInit(key, &amp;aes_key, 128);    if (success) {        printf(\"-----------AES 128-------------\\n\");        // 69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a        AES_Encrypt(plaintext, ciphertext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", ciphertext[i]);        }        printf(\"\\n\");        // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff        AES_Decrypt(ciphertext, plaintext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", plaintext[i]);        }        printf(\"\\n\");        AES_KeyDelete(aes_key);    }    //-----------AES 196-------------------    success = AES_KeyInit(key, &amp;aes_key, 196);    if (success) {        printf(\"-----------AES 196-------------\\n\");        // dd a9 7c a4 86 4c df e0 6e af 70 a0 ec 0d 71 91        AES_Encrypt(plaintext, ciphertext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", ciphertext[i]);        }        printf(\"\\n\");        // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff        AES_Decrypt(ciphertext, plaintext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", plaintext[i]);        }        printf(\"\\n\");        AES_KeyDelete(aes_key);    }    //------------AES 256-----------------    success = AES_KeyInit(key, &amp;aes_key, 256);    if (success) {        printf(\"-----------AES 256-------------\\n\");        // 8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89        AES_Encrypt(plaintext, ciphertext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", ciphertext[i]);        }        printf(\"\\n\");        // 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff        AES_Decrypt(ciphertext, plaintext, aes_key);        for (int i = 0; i &lt; 16; i++) {            printf(\"%02x \", plaintext[i]);        }        printf(\"\\n\");        AES_KeyDelete(aes_key);    }    return 0;}\n注意点：加解密密钥在查表法aes中不同\n逆向时拿到其中一个可以推导另一个\ndk[0]  = ek[10];                     // 最后一轮密钥直接用dk[10] = ek[0];                      // 第一轮密钥直接用dk[i]  = InvMixColumns(ek[10 - i]);  // 中间轮要过一次逆MixColumns\n不需要研究透算法逻辑，只需要知道大致原理和遇到时能识别出这是aes变种就可以了\n白盒aes白盒aes算是在逆向中最常见到的了，特点是隐藏密钥。\n查表法 AES 提供了“把轮操作变成查表”的思路，白盒 AES 则利用这个查表方法隐藏密钥，\n白盒 AES 和 “查表法 AES” 算法是同一回事，可以把白盒AES看成查表AES的加强版(把密钥也混淆进表里了)，一些密码学库会在 AES_init 的时候预处理并展开 key；如果 key 是字面量，还可能在编译时进行常量计算。这样编译后的可执行文件中就没有明文 key 了。\nDFA攻击白盒aes最主要的破解方式就是dfa攻击\n我们需要的攻击条件：\n\n我们可以反汇编出源代码并调试它\n\npip install phoenixAES\n\n编译这里面的GitHub - SideChannelMarvels/Stark: Repository of small utilities related to key recovery的aes_keyschedule.c\n\n\n原理：在白盒攻击模型中，我们可以通过DBI工具（比如Frida），Debuggger（比如IDA），修改二进制文件本身 （SO patch）来实现对 中一个字节的更改，这可以称为引导、诱发一个错误。 因此差分故障攻击或差分错误攻击都是DFA合适的名字，下面修改明文中中第一个字节的值\n首先是初始轮密钥加，错误限于这一个字节\n\n然后是第一轮的字节替换，错误限于这一个字节\n\n然后是第一轮的循环左移，因为是第一行，所以没动。\n\n然后是第一轮的列混淆步骤，结果的第m行第n列的值等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和，因此结果中第一列的每一个元素都受到矩阵B（即下图左边）第一列中每个元素的影响。因而，一个字节的错误被扩散到了一整列。或者说，正常情况和故障情况在第一轮列混淆结束后，有四个字节的值不同。\n\n然后是第一轮的轮密钥加，它只作用用当前字节，不会将差异扩散出去。\n\n可以看到，在一轮循环后，一个字节的故障，被扩散到了四个字节上。继续第二轮。第二轮的字节替换\n\n第二轮的循环左移，需要注意到，虽然差异还是四个字节，但被扩散到不同的四列去了。\n\n第二轮的列混淆，每列存在的差异扩散到整列，这导致state的全部字节都与原先有差异。\n\n所以DFA攻击就是从第9轮攻击的行移位和列混淆中间更改1个数据，创造差错点，然后从最后拿到密文来分析故障结果(有四个差错点)，由于aes一次可加密16个字节，所以可以得出16种不同的故障情况，那我们就可以通过数学间的关系，把密钥反解出来\n攻击实现在调试时更改第九轮对应字节即可，明文要求输入的话直接全输入\\x00，在第9轮进行故障注入，假设正常明文(无故障)加密结果为0x8df4e9aac5c7573a27d8d055d6e4d64b\n注入时把第一个字节改为0x10,第十轮结束后结果：\n8d f4 e9 aa c5 c7 57 3a 27 d8 d0 55 d6 e4 d6 4bda f4 e9 aa c5 c7 57 c9 27 d8 53 55 d6 37 d6 4b确实有4个字节不一样。以此类推，得到16个不一样的带差错的密文\ndaf4e9aac5c757c927d85355d637d64b47f4e9aac5c7577d27d8a655d61ed64b79f4e9aac5c7572a27d89855d62ad64b30f4e9aac5c7570b27d86555d6a5d64b8d7de9aac8c7573a27d8d09ed6e4be4b8d5ce9aa43c7573a27d8d04cd6e4054b8d0de9aaddc7573a27d8d060d6e4234b8dabe9aacac7573a27d8d009d6e4484b8df48caac598573a62d8d055d6e4d6368df4bbaac5f4573acdd8d055d6e4d6938df47aaac576573ac1d8d055d6e4d61c8df444aac5c8573a23d8d055d6e4d6fb8df4e9e0c5c7b73a2768d055ade4d64b8df4e9f2c5c7063a27a4d055dfe4d64b8df4e942c5c7793a275ed05535e4d64b8df4e98fc5c7fa3a2778d055b3e4d64b\n有了这个以后我们就可以还原得到第十轮的密钥了，这里使用phoenixAES工具，先安装：\npip install phoenixAES\n#!/usr/bin/env python3import phoenixAESwith open('tracefile', 'wb') as t:    t.write(\"\"\"8df4e9aac5c7573a27d8d055d6e4d64bdaf4e9aac5c757c927d85355d637d64b47f4e9aac5c7577d27d8a655d61ed64b79f4e9aac5c7572a27d89855d62ad64b30f4e9aac5c7570b27d86555d6a5d64b8d7de9aac8c7573a27d8d09ed6e4be4b8d5ce9aa43c7573a27d8d04cd6e4054b8d0de9aaddc7573a27d8d060d6e4234b8dabe9aacac7573a27d8d009d6e4484b8df48caac598573a62d8d055d6e4d6368df4bbaac5f4573acdd8d055d6e4d6938df47aaac576573ac1d8d055d6e4d61c8df444aac5c8573a23d8d055d6e4d6fb8df4e9e0c5c7b73a2768d055ade4d64b8df4e9f2c5c7063a27a4d055dfe4d64b8df4e942c5c7793a275ed05535e4d64b8df4e98fc5c7fa3a2778d055b3e4d64b\"\"\".encode('utf8'))phoenixAES.crack_file('tracefile', [], True, False, 3)\n一共写入了17行数据到文件，其中第一行为正确的密文，剩余16行都是故障密文，最终通过crack_file即可得到第10轮密钥：\nLast round key #N found:D014F9A8C9EE2589E13F0CC8B6630CA6\n还原最初密钥：接下来用第三个工具里的aes_keyschedule.c，在本地编译后运行\n./aes_keyschedule 5D432583B2AA833FC22D53130FDA904C 10\n执行结果：\n./aes_keyschedule D014F9A8C9EE2589E13F0CC8B6630CA6 10K00: 2B7E151628AED2A6ABF7158809CF4F3CK01: A0FAFE1788542CB123A339392A6C7605K02: F2C295F27A96B9435935807A7359F67FK03: 3D80477D4716FE3E1E237E446D7A883BK04: EF44A541A8525B7FB671253BDB0BAD00K05: D4D1C6F87C839D87CAF2B8BC11F915BCK06: 6D88A37A110B3EFDDBF98641CA0093FDK07: 4E54F70E5F5FC9F384A64FB24EA6DC4FK08: EAD27321B58DBAD2312BF5607F8D292FK09: AC7766F319FADC2128D12941575C006EK10: D014F9A8C9EE2589E13F0CC8B6630CA6\n即可得到密钥为2B7E151628AED2A6ABF7158809CF4F3C\nReferencehttps://zhuanlan.zhihu.com/p/42264499\n找回消失的密钥 —- DFA分析白盒AES算法 - 奋飞安全\nhttps://www.zskkk.cn/posts/15785/#%E8%BF%98%E5%8E%9F%E5%AF%86%E6%96%87\n","categories":["逆向中的密码学","对称加密题单"],"tags":["aes"]},{"title":"逆向中的AES(一)","url":"/2025/10/09/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/aes1/","content":"前言：aes在逆向有很多应用，尤其是现在越来越多软件加密逻辑都选择aes，所以总结一下aes的算法和在ctf逆向中的考点\naes算法基础\naes最重要的一个特征就是输入是128位分组，输出也是128位分组，但其中key分128位，192位，256位三种版本\n\n\n\n\nAES 类型\n密钥长度\n轮数 (Nr)\n密钥字数 (Nk)\n\n\n\n\nAES-128\n128 位\n10\n4\n\n\nAES-192\n192 位\n12\n6\n\n\nAES-256\n256 位\n14\n8\n\n\n\n\naes分组后16个字节是按矩阵方式排列\n\n加密总流程：\n最终轮和前面9轮的区别是没有第三个步骤列混合\n初始变换(Initial round)初始变换就是输入的16个字节和密钥(不确定几位)进行密钥扩展后生成的(16位)异或的结果\n\n\\text{State}' = \\text{State} \\oplus \\text{RoundKey}_0展开为矩阵形式：\n\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\\\\ns_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\\\\ns_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}\n\\end{bmatrix}\n\\;\\oplus\\;\n\\begin{bmatrix}\nk_{0,0} & k_{0,1} & k_{0,2} & k_{0,3} \\\\\nk_{1,0} & k_{1,1} & k_{1,2} & k_{1,3} \\\\\nk_{2,0} & k_{2,1} & k_{2,2} & k_{2,3} \\\\\nk_{3,0} & k_{3,1} & k_{3,2} & k_{3,3}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\ns'_{0,0} & s'_{0,1} & s'_{0,2} & s'_{0,3} \\\\\ns'_{1,0} & s'_{1,1} & s'_{1,2} & s'_{1,3} \\\\\ns'_{2,0} & s'_{2,1} & s'_{2,2} & s'_{2,3} \\\\\ns'_{3,0} & s'_{3,1} & s'_{3,2} & s'_{3,3}\n\\end{bmatrix}其中：\n\n 为明文状态矩阵中第  个字节  \n 为轮密钥矩阵中第  个字节  \n 表示按字节异或（XOR）运算\n\n循环运算：字节代换：\n字节代换就是把第一步初始变换后的16字节矩阵块用s表代换，例如矩阵左上角的数是十六进制19，那就要代换成s盒中第1行第9列，查表可知是d4，以此类推\n结果：\n\n行移位：ShiftRows 操作在状态矩阵上进行，规则如下：\n\n第 0 行不变\n第 1 行循环左移 1 字节\n第 2 行循环左移 2 字节\n第 3 行循环左移 3 字节\n\n原始状态矩阵：\n\n\\text{State} =\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\\\\ns_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\\\\ns_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}\n\\end{bmatrix}经过行移位后：\n\n\\text{State}' =\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,1} & s_{1,2} & s_{1,3} & s_{1,0} \\\\\ns_{2,2} & s_{2,3} & s_{2,0} & s_{2,1} \\\\\ns_{3,3} & s_{3,0} & s_{3,1} & s_{3,2}\n\\end{bmatrix}每一行的移位规律如下：\n\n\n\n\n行号\n移位字节数\n移位方向\n\n\n\n\n0\n0\n不变\n\n\n1\n1\n左移\n\n\n2\n2\n左移\n\n\n3\n3\n左移\n\n\n\n\n列混淆：\n左乘一个确定的矩阵，但是这里的乘法不是普通乘法\n列混淆中的乘法\n\\begin{aligned}\ns'_{0,c} &= (02 \\cdot s_{0,c}) \\oplus (03 \\cdot s_{1,c}) \\oplus s_{2,c} \\oplus s_{3,c} \\\\\ns'_{1,c} &= s_{0,c} \\oplus (02 \\cdot s_{1,c}) \\oplus (03 \\cdot s_{2,c}) \\oplus s_{3,c} \\\\\ns'_{2,c} &= s_{0,c} \\oplus s_{1,c} \\oplus (02 \\cdot s_{2,c}) \\oplus (03 \\cdot s_{3,c}) \\\\\ns'_{3,c} &= (03 \\cdot s_{0,c}) \\oplus s_{1,c} \\oplus s_{2,c} \\oplus (02 \\cdot s_{3,c})\n\\end{aligned}其中乘法在有限域  上进行：\n\n 表示按字节左移一位（若最高位为 1，则再与 0x1B 异或）  \n\n\n注：与0x1B异或是因为要构造有限域构造出来的多项式把模之后的结果，学逆向不用学那么深，只需要知道aes的加密解密和漏洞攻击就可以了\n轮密钥加：AddRoundKey 是 AES 每一轮中最简单但最关键的操作之一。它将 状态矩阵 (State) 与 轮密钥矩阵 (RoundKey) 按字节异或（XOR）：\n\n\\text{State}' = \\text{State} \\oplus \\text{RoundKey}_i设状态矩阵为：\n\n\\text{State} =\n\\begin{bmatrix}\ns_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\\\\ns_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\\\\ns_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\\\\ns_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}\n\\end{bmatrix}轮密钥矩阵为：\n\n\\text{RoundKey}_i =\n\\begin{bmatrix}\nk_{0,0} & k_{0,1} & k_{0,2} & k_{0,3} \\\\\nk_{1,0} & k_{1,1} & k_{1,2} & k_{1,3} \\\\\nk_{2,0} & k_{2,1} & k_{2,2} & k_{2,3} \\\\\nk_{3,0} & k_{3,1} & k_{3,2} & k_{3,3}\n\\end{bmatrix}异或后得到：\n\n\\text{State}' =\n\\begin{bmatrix}\ns_{0,0} \\oplus k_{0,0} & s_{0,1} \\oplus k_{0,1} & s_{0,2} \\oplus k_{0,2} & s_{0,3} \\oplus k_{0,3} \\\\\ns_{1,0} \\oplus k_{1,0} & s_{1,1} \\oplus k_{1,1} & s_{1,2} \\oplus k_{1,2} & s_{1,3} \\oplus k_{1,3} \\\\\ns_{2,0} \\oplus k_{2,0} & s_{2,1} \\oplus k_{2,1} & s_{2,2} \\oplus k_{2,2} & s_{2,3} \\oplus k_{2,3} \\\\\ns_{3,0} \\oplus k_{3,0} & s_{3,1} \\oplus k_{3,1} & s_{3,2} \\oplus k_{3,2} & s_{3,3} \\oplus k_{3,3}\n\\end{bmatrix}按字节运算公式每个字节的计算方式为：\n\ns'_{i,j} = s_{i,j} \\oplus k_{i,j}, \\quad 0 \\le i,j \\le 3密钥扩展：初始只有128/192/256位的密钥是怎么更新的呢，这就涉及到密钥扩展\n这是初始状态，这里以128位密钥为例，先全部填入前4列，设第5列为Wi\n\n\n初始部分：\n\n\nW[i] = \\text{原始密钥的第 } i \\text{ 个 32 位字}, \\quad 0 \\le i < N_k\n递推部分：（适用于所有aes算法）\n\n对于 ：\n\nW[i] =\n\\begin{cases}\nW[i - N_k] \\oplus \\text{SubWord}(\\text{RotWord}(W[i - 1])) \\oplus \\text{Rcon}[i/N_k], & \\text{if } i \\bmod N_k = 0 \\\\\nW[i - N_k] \\oplus \\text{SubWord}(W[i - 1]), & \\text{if } N_k > 6 \\text{ and } i \\bmod N_k = 4  (只有aes256有这条)\\\\\nW[i - N_k] \\oplus W[i - 1], & \\text{otherwise}\n\\end{cases}函数定义RotWord：循环左移 1 字节  \n\n[a_0, a_1, a_2, a_3] \\Rightarrow [a_1, a_2, a_3, a_0]\nSubWord：对 4 个字节分别进行 S-box 替代  \n\n[a_0, a_1, a_2, a_3] \\Rightarrow [S(a_0), S(a_1), S(a_2), S(a_3)]Rcon：轮常数，仅作用于字的第一个字节：\n\n\\text{Rcon}[i] =\n\\begin{bmatrix}\n\\text{RC}[i] & 00 & 00 & 00\n\\end{bmatrix}其中，，，，，，，，，\n最终结果\n解密方式就是把上述过程反过来一遍（解密的第一轮没有列混合逆向）\n\n其中的轮密钥加只需要每轮相同状态的W[i,i+3]就可以\n逆列混淆\n逆行移位：就是逆向移位就可以，很简单\n逆s表\n查表即可\n逆向题型：普通AES找到密钥，找到密文，逆向脚本，进行解密。\n加解密脚本:\ns_box = (    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)# inv_s_box = tuple([s_box.index(i) for i in range(256)])inv_s_box = (    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,)def sub_bytes(s):    for i in range(4):        for j in range(4):            s[i][j] = s_box[s[i][j]]def inv_sub_bytes(s):    for i in range(4):        for j in range(4):            s[i][j] = inv_s_box[s[i][j]]def shift_rows(s):    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]def inv_shift_rows(s):    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]def add_round_key(s, k):    for i in range(4):        for j in range(4):            s[i][j] ^= k[i][j]# learned from https://web.archive.org/web/20100626212235/http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.cxtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def mix_single_column(a):    # see Sec 4.1.2 in The Design of Rijndael    t = a[0] ^ a[1] ^ a[2] ^ a[3]    u = a[0]    a[0] ^= t ^ xtime(a[0] ^ a[1])    a[1] ^= t ^ xtime(a[1] ^ a[2])    a[2] ^= t ^ xtime(a[2] ^ a[3])    a[3] ^= t ^ xtime(a[3] ^ u)def mix_columns(s):    for i in range(4):        mix_single_column(s[i])def inv_mix_columns(s):    # see Sec 4.1.3 in The Design of Rijndael    for i in range(4):        u = xtime(xtime(s[i][0] ^ s[i][2]))        v = xtime(xtime(s[i][1] ^ s[i][3]))        s[i][0] ^= u        s[i][1] ^= v        s[i][2] ^= u        s[i][3] ^= v    mix_columns(s)r_con = (    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,)def bytes2matrix(text):    \"\"\" Converts a 16-byte array into a 4x4 matrix.  \"\"\"    return [list(text[i:i+4]) for i in range(0, len(text), 4)]def matrix2bytes(matrix):    \"\"\" Converts a 4x4 matrix into a 16-byte array.  \"\"\"    return bytes(sum(matrix, []))def xor_bytes(a, b):    \"\"\" Returns a new byte array with the elements xor'ed. \"\"\"    return bytes(i^j for i, j in zip(a, b))def inc_bytes(a):    \"\"\" Returns a new byte array with the value increment by 1 \"\"\"    out = list(a)    for i in reversed(range(len(out))):        if out[i] == 0xFF:            out[i] = 0        else:            out[i] += 1            break    return bytes(out)def pad(plaintext):    \"\"\"    Pads the given plaintext with PKCS#7 padding to a multiple of 16 bytes.    Note that if the plaintext size is a multiple of 16,    a whole block will be added.    \"\"\"    padding_len = 16 - (len(plaintext) % 16)    padding = bytes([padding_len] * padding_len)    return plaintext + paddingdef unpad(plaintext):    \"\"\"    Removes a PKCS#7 padding, returning the unpadded text and ensuring the    padding was correct.    \"\"\"    padding_len = plaintext[-1]    assert padding_len &gt; 0    message, padding = plaintext[:-padding_len], plaintext[-padding_len:]    assert all(p == padding_len for p in padding)    return messagedef split_blocks(message, block_size=16, require_padding=True):        assert len(message) % block_size == 0 or not require_padding        return [message[i:i+16] for i in range(0, len(message), block_size)]class AES:    \"\"\"    Class for AES-128 encryption with CBC mode and PKCS#7.    This is a raw implementation of AES, without key stretching or IV    management. Unless you need that, please use `encrypt` and `decrypt`.    \"\"\"    rounds_by_key_size = {16: 10, 24: 12, 32: 14}    def __init__(self, master_key):        \"\"\"        Initializes the object with a given key.        \"\"\"        assert len(master_key) in AES.rounds_by_key_size        self.n_rounds = AES.rounds_by_key_size[len(master_key)]        self._key_matrices = self._expand_key(master_key)    def _expand_key(self, master_key):        \"\"\"        Expands and returns a list of key matrices for the given master_key.        \"\"\"        # Initialize round keys with raw key material.        key_columns = bytes2matrix(master_key)        iteration_size = len(master_key) // 4        i = 1        # expand round: (rounds+1)*4        while len(key_columns) &lt; (self.n_rounds + 1) * 4:            # Copy previous word.            word = list(key_columns[-1])            # Perform schedule_core once every \"row\".            if len(key_columns) % iteration_size == 0:                # Circular shift.                word.append(word.pop(0))                # Map to S-BOX.                word = [s_box[b] for b in word]                # XOR with first byte of R-CON, since the others bytes of R-CON are 0.                word[0] ^= r_con[i]                i += 1            elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:                # Run word through S-box in the fourth iteration when using a                # 256-bit key.                word = [s_box[b] for b in word]            # XOR with equivalent word from previous iteration.            word = xor_bytes(word, key_columns[-iteration_size])            key_columns.append(list(word))        # Group key words in 4x4 byte matrices.        return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)]    def encrypt_ecb(self, ciphertext):        assert len(ciphertext) &gt;= 16        assert len(ciphertext) % 16 == 0        result = b''        for i in range(0, len(ciphertext), 16):            result += self.encrypt_ecb_block(ciphertext[i:i+16])        return result    def encrypt_ecb_block(self, plaintext):        \"\"\"        Encrypts a single block of 16 byte long plaintext.        \"\"\"        assert len(plaintext) == 16        plain_state = bytes2matrix(plaintext)        add_round_key(plain_state, self._key_matrices[0])        for i in range(1, self.n_rounds):            sub_bytes(plain_state)            shift_rows(plain_state)            mix_columns(plain_state)            add_round_key(plain_state, self._key_matrices[i])        sub_bytes(plain_state)        shift_rows(plain_state)        add_round_key(plain_state, self._key_matrices[-1])        return matrix2bytes(plain_state)    def decrypt_ecb(self, ciphertext):        assert len(ciphertext) &gt;= 16        assert len(ciphertext) % 16 == 0        result = b''        for i in range(0, len(ciphertext), 16):            result += self.decrypt_ecb_block(ciphertext[i:i+16])        return result    def decrypt_ecb_block(self, ciphertext):        \"\"\"        Decrypts a single block of 16 byte long ciphertext.        \"\"\"        assert len(ciphertext) == 16        cipher_state = bytes2matrix(ciphertext)        add_round_key(cipher_state, self._key_matrices[-1])        inv_shift_rows(cipher_state)        inv_sub_bytes(cipher_state)        for i in range(self.n_rounds - 1, 0, -1):            add_round_key(cipher_state, self._key_matrices[i])            inv_mix_columns(cipher_state)            inv_shift_rows(cipher_state)            inv_sub_bytes(cipher_state)        add_round_key(cipher_state, self._key_matrices[0])        return matrix2bytes(cipher_state)    def encrypt_cbc(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using CBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        plaintext = pad(plaintext)        blocks = []        previous = iv        for plaintext_block in split_blocks(plaintext):            # CBC mode encrypt: encrypt(plaintext_block XOR previous)            block = self.encrypt_ecb_block(xor_bytes(plaintext_block, previous))            blocks.append(block)            previous = block        return b''.join(blocks)    def decrypt_cbc(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using CBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        previous = iv        for ciphertext_block in split_blocks(ciphertext):            # CBC mode decrypt: previous XOR decrypt(ciphertext)            blocks.append(xor_bytes(previous, self.decrypt_ecb_block(ciphertext_block)))            previous = ciphertext_block        return unpad(b''.join(blocks))    def encrypt_pcbc(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using PCBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        plaintext = pad(plaintext)        blocks = []        prev_ciphertext = iv        prev_plaintext = bytes(16)        for plaintext_block in split_blocks(plaintext):            # PCBC mode encrypt: encrypt(plaintext_block XOR (prev_ciphertext XOR prev_plaintext))            ciphertext_block = self.encrypt_ecb_block(xor_bytes(plaintext_block, xor_bytes(prev_ciphertext, prev_plaintext)))            blocks.append(ciphertext_block)            prev_ciphertext = ciphertext_block            prev_plaintext = plaintext_block        return b''.join(blocks)    def decrypt_pcbc(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using PCBC mode and PKCS#7 padding, with the given        initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        prev_ciphertext = iv        prev_plaintext = bytes(16)        for ciphertext_block in split_blocks(ciphertext):            # PCBC mode decrypt: (prev_plaintext XOR prev_ciphertext) XOR decrypt(ciphertext_block)            plaintext_block = xor_bytes(xor_bytes(prev_ciphertext, prev_plaintext), self.decrypt_ecb_block(ciphertext_block))            blocks.append(plaintext_block)            prev_ciphertext = ciphertext_block            prev_plaintext = plaintext_block        return unpad(b''.join(blocks))    def encrypt_cfb(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` with the given initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        prev_ciphertext = iv        for plaintext_block in split_blocks(plaintext, require_padding=False):            # CFB mode encrypt: plaintext_block XOR encrypt(prev_ciphertext)            ciphertext_block = xor_bytes(plaintext_block, self.encrypt_ecb_block(prev_ciphertext))            blocks.append(ciphertext_block)            prev_ciphertext = ciphertext_block        return b''.join(blocks)    def decrypt_cfb(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` with the given initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        prev_ciphertext = iv        for ciphertext_block in split_blocks(ciphertext, require_padding=False):            # CFB mode decrypt: ciphertext XOR decrypt(prev_ciphertext)            plaintext_block = xor_bytes(ciphertext_block, self.encrypt_ecb_block(prev_ciphertext))            blocks.append(plaintext_block)            prev_ciphertext = ciphertext_block        return b''.join(blocks)    def encrypt_ofb(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using OFB mode initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        previous = iv        for plaintext_block in split_blocks(plaintext, require_padding=False):            # OFB mode encrypt: plaintext_block XOR encrypt(previous)            block = self.encrypt_ecb_block(previous)            ciphertext_block = xor_bytes(plaintext_block, block)            blocks.append(ciphertext_block)            previous = block        return b''.join(blocks)    def decrypt_ofb(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using OFB mode initialization vector (iv).        \"\"\"        assert len(iv) == 16        blocks = []        previous = iv        for ciphertext_block in split_blocks(ciphertext, require_padding=False):            # OFB mode decrypt: ciphertext XOR encrypt(previous)            block = self.encrypt_ecb_block(previous)            plaintext_block = xor_bytes(ciphertext_block, block)            blocks.append(plaintext_block)            previous = block        return b''.join(blocks)    def encrypt_ctr(self, plaintext, iv):        \"\"\"        Encrypts `plaintext` using CTR mode with the given nounce/IV.        \"\"\"        assert len(iv) == 16        blocks = []        nonce = iv        for plaintext_block in split_blocks(plaintext, require_padding=False):            # CTR mode encrypt: plaintext_block XOR encrypt(nonce)            block = xor_bytes(plaintext_block, self.encrypt_ecb_block(nonce))            blocks.append(block)            nonce = inc_bytes(nonce)        return b''.join(blocks)    def decrypt_ctr(self, ciphertext, iv):        \"\"\"        Decrypts `ciphertext` using CTR mode with the given nounce/IV.        \"\"\"        assert len(iv) == 16        blocks = []        nonce = iv        for ciphertext_block in split_blocks(ciphertext, require_padding=False):            # CTR mode decrypt: ciphertext XOR encrypt(nonce)            block = xor_bytes(ciphertext_block, self.encrypt_ecb_block(nonce))            blocks.append(block)            nonce = inc_bytes(nonce)        return b''.join(blocks)def AES_ecb_encrypt(data: bytes, key: bytes):    a = AES(key)    return a.encrypt_ecb(data)def AES_ecb_decrypt(data: bytes, key: bytes):    a = AES(key)    return a.decrypt_ecb(data)def AES_cbc_encrypt(data: bytes, key: bytes, iv: bytes):    a = AES(key)    return a.encrypt_cbc(data, iv)def AES_cbc_decrypt(data: bytes, key: bytes, iv: bytes):    a = AES(key)    return a.decrypt_cbc(data, iv)\n白盒AES\n\n\n\n项目\n普通 AES（黑盒）\n白盒 AES\n\n\n\n\n密钥\n独立变量、明确定义\n被混入查表中，不可直接访问\n\n\n算法结构\n明确的五步（SubBytes 等）\n各步骤混淆成查表和线性映射\n\n\n可移植性\n高（用同样的密钥随处运行）\n低（查表与密钥绑定）\n\n\n安全假设\n攻击者看不到内部\n攻击者能看到全部\n\n\n\n\n 目前市面上大多数app都是基于白盒aes开发的，还有查表法实现的aes真的严格按照上面讲的aes流程走的很少，白盒aes东西太多了，而且还有很多攻击手法，就放在”逆向中的AES(二)“里讲好了\n参考资料：【AES加密算法】| AES加密过程详解| 对称加密| Rijndael-128| 密码学| 信息安全_哔哩哔哩_bilibili\n密码学——AES/DES加密算法原理介绍 - 枫のBlog\n","categories":["逆向中的密码学","对称加密题单"],"tags":["aes"]},{"title":"强网杯2023-dotdot复现","url":"/2025/10/12/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%BC%BA%E7%BD%91%E6%9D%AF2023-dotdot%E5%A4%8D%E7%8E%B0/","content":"","categories":["逆向中的密码学","对称加密题单"],"tags":["aes"]},{"title":"分组密码的加密模式及攻击","url":"/2025/10/09/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","content":"分组密码工作模式工作模式对算法本身结构没有影响，影响的是明文密文\nECB：电子密码本模式(electronic codebook mode)\n从ECB的工作原理可以看出，如果明文数据在等分后，两块数据相同则会产生相同的加密数据块，这会辅助攻击者快速判断加密算法的工作模式，而将攻击资源聚集在破解某一块数据即可，一旦成功则意味着全文破解，大大提升了攻击效率。\n\n\\text{加密：}\\quad C_i = E_k(P_i)\n\\text{解密：}\\quad P_i = D_k(C_i)CBC：密码分组链接模式（cipher block chaining Triple）\ncbc的解密\n\nCBC模式相比ECB实现了更好的模式隐藏，但因为其将密文引入运算，加解密操作无法并行操作。同时引入的IV向量，并且还需要加、解密双方共同知晓方可。\n\nC_0 = \\text{IV}\n\\text{加密：}\\quad C_i = E_k(P_i \\oplus C_{i-1})\n\\text{解密：}\\quad P_i = D_k(C_i) \\oplus C_{i-1}CFB：密文反馈模式（Cipher FeedBack）\n与CBC模式类似，但不同的地方在于，CFB模式先生成密码流字典，然后用密码字典与明文进行异或操作并最终生成密文。后一分组的密码字典的生成需要前一分组的密文参与运算。\n\n其中s位可任意，不同s位加密结果不同，默认s是算法块规定长度，例des是64，aes是128\n\nC_0 = \\text{IV}\n\\text{加密：}\\quad O_i = E_k(C_{i-1}),\\quad C_i = P_i \\oplus O_i\n\\text{解密：}\\quad O_i = E_k(C_{i-1}),\\quad P_i = C_i \\oplus O_iOFB：输出反馈模式（Output Feedbaek）\nOFB和CFB一样，明文块可自定义长度\n\nO_0 = \\text{IV}\n\\text{生成 keystream：}\\quad O_i = E_k(O_{i-1}),\\quad S_i = O_i\n\\text{加密：}\\quad C_i = P_i \\oplus S_i\n\\text{解密：}\\quad P_i = C_i \\oplus S_iCTR：计数器模式（counter mode）\n\n\\text{令 }CTR_i = \\text{NONCE} \\,\\|\\, (\\text{counter}+i)\n\\text{加密：}\\quad S_i = E_k(CTR_i),\\quad C_i = P_i \\oplus S_i\n\\text{解密：}\\quad P_i = C_i \\oplus S_i \\quad(\\text{其中 }S_i = E_k(CTR_i))加密模式总结：\n\n\n\n模式\n全称\n优点\n缺点\n是否需 IV\n是否可并行加密\n是否可并行解密\n是否适合流加密\n\n\n\n\nECB\nElectronic Codebook\n实现简单；可并行加解密\n同块明文→同块密文，易被模式识别（最不安全）\n否\n是\n是\n否\n\n\nCBC\nCipher Block Chaining\n同块明文不同IV→不同密文；常用于文件加密\n无法并行加密；需填充；IV重用会泄密\n是\n否\n是\n否\n\n\nCFB\nCipher Feedback\n不需填充；可加密任意长度数据；适合流式\n错误传播严重；速度略慢\n是\n否\n否\n是\n\n\nOFB\nOutput Feedback\n不需填充；错误不会传播；适合流加密\n同IV下重用密钥极危险；同步要求高\n是\n是\n是\n是\n\n\nCTR\nCounter\n可随机访问块；可并行加解密；性能优\n计数器不能重用，否则致命泄密\n是（计数器）\n是\n是\n是\n\n\n\n\n加密模式攻击CBC反转字节攻击：已知密文，和明文。可以在不知道key的情况下，肆意更改明文的值，比如网站验证权限，可以把传进去的密文修改，从而使明文从’user’到’admin’，可能能绕过权限\n设A是第N-1块的密文一个字节，B是第N块密文解密后的中间值的对应部分字节，C是第N块明文对应字节，X是想要修改的字节值\n公式右边是明文变化，左边括号内是输入密文的变化\n\n\\begin{aligned}\nA \\oplus B &= C \\\\\n(A \\oplus C) \\oplus B &= 0 \\\\\n(A \\oplus C \\oplus X)\\oplus B &= X\n\\end{aligned}from Crypto.Cipher import AESimport uuidimport binasciiBS=AES.block_size  #分组长度key=b'test'  #密钥iv=uuid.uuid4().bytes  #随机初始向量pad=lambda s: s+((BS-len(s)%BS)*chr(BS-len(s)%BS)).encode()  #Pkcs5Paddingdata=b'1234567890abcdefabcdef1234567890'  #明文M#加密def enc(data):    aes=AES.new(pad(key),AES.MODE_CBC,iv)    ciphertext=aes.encrypt(pad(data))    ciphertext=binascii.b2a_hex(ciphertext)    return ciphertext#解密def dec(c):    c=binascii.a2b_hex(c)    aes=AES.new(pad(key),AES.MODE_CBC,iv)    data=aes.decrypt(c)    return data#测试CBC翻转def CBC_test(c):    c=bytearray(binascii.a2b_hex(c))    c[0]=c[0]^ord('a')^ord('A') #c[0]为第一组的密文字符，a为第二组相应位置的明文字符，A是我们想要的明文字符    c=binascii.b2a_hex(c)    return cprint(\"ciphertext:\",enc(data))print(\"data:\",dec(enc(data)))print(\"CBC Attack:\",dec(CBC_test(enc(data))))\nciphertext: b'ffa645d1b5e40afbbae47de053a66f978fa0a824e99864a7e8baf38ceccda613c304883f11fc0857c1bb7603f859798e'data: b'1234567890abcdefabcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10'CBC Attack:b':8O&lt;\\xe7\\x04\\xd8v\\xe8Q\\xfe\\xa5I\\xc9c]Abcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10'\nPadding Oracle Attack已知条件：如果明文的padding格式出错服务端会提示某个特定状态码，密文，iv(IV经常会随着密文一起发送。常见的做法是将IV作为一个前缀，附着在密文的前面)\n效果：在不清楚 key 的前提下解密任意给定的密文。\n\n原理：我们有密文，解密后的中间状态(Intermediary Value)我们不知道，爆破每个字节的iv值，当服务端不报错时，说明padding正确，如上图所示，我们知道爆破的第8个字节，就肯定直接padding为0x1,也知道我们此时爆破的iv是多少，就可以推出正确的中间状态(Intermediary Value)是多少，依次类推，把所有字节的中间状态都算出来后，就可以用初始iv异或中间状态得到明文。\n如果已知多组密文解密：从前往后进行解密\n如果已知多组明文加密：先从最后一组开始，爆破最后一组的intermediary并构造出iv，然后将本组的iv当作前一组的密文，以此类推。由此我们可以得到构造密文的步骤\n\n从最后一组开始，爆破出该组的intermediary并构造出iv，然后将本组的iv当作前一组的密文\n爆破前一组的intermediary并构造出iv，然后将本组的iv当作前一组的密文\n…\n最后会得到第一组的iv，至此我们已经构造出了所有合法密文以及iv\n\nreference:CBC字节翻转攻击&amp;Padding Oracle Attack原理解析 - 枫のBlog\n","categories":["逆向中的密码学","对称加密题单"],"tags":["aes"]}]