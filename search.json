[{"title":"[GWCTF 2019] babyvm","url":"/2025/10/07/%5BGWCTF%202019%5Dbabyvm/","content":"前言：这道题算非常经典的vm题了，用这道题来熟悉一下vm题基本流程\n正文：创建结构体：\n有三个函数我们点进去看一下具体逻辑\n\n第一个函数很明显就是vm_init的结构，我们改名为vm_init,并创建结构体帮助静态分析\n\n在空白部分右键，添加结构体\n\n结构体名就叫vm_cpu，下面按d键快捷键给它增加成员变量\n光标对准vm_cpu struc点一次d是在最前面增加成员变量\n对准field_0点一次d是更改一次field_0的类型,也可按y直接输入类型\n对准vm_cpu ends点一次d是在末尾增加成员变量\n\n接下来修改成员变量的名称按n快捷键，改为eax，ebx等\n由于vm_cpu中有个数组叫oplist[]\n我们先创建新结构体\nstruct opcode&#123;    QWORD _opcode;    QWORD handle;&#125;;\n\n这里稍微再提一下怎么确定每个成员变量占多少字节，不要看ida给你强转出来的类型，而要看上下成员之间的差值，比如*(_BYTE )(a1 + 24) &#x3D; -15;和(_QWORD *)(a1 + 32) &#x3D; sub_B5F;从a1+24到a1+32，占了8个字节。所以这里_opcode类型是qword。下面是全部改完之后的结构体\n\n再回到第一个函数，对准函数参数列表按y，把a1类型改为vm_cpu*，然后函数就变得美观了，下面的qword_2022A8是给vm设置的栈空间，我们也可以改名vm_stack\n\n第二个函数很容易看出来是vm_run,分发器控制程序执行，第三个函数是验证flag正确与否，就不展开讲了\n第二个函数把参数也改成vm_cpu*\nunsigned __int64 __fastcall vm_run(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_rip = (__int64)&amp;unk_202060;  while ( *(_BYTE *)a1-&gt;vm_rip != 0xF4 )    sub_E6E(a1);  return __readfsqword(0x28u) ^ v2;&#125;\n\n我们看到逻辑已经很明确了，就是rip指向的地址对应的值不等于0xf4时，一直调用sub_E6E\nunsigned __int64 __fastcall sub_E6E(vm_cpu *a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; *(_BYTE *)a1-&gt;vm_rip != LOBYTE(a1-&gt;oplist[i]._opcode); ++i )    ;  ((void (__fastcall *)(vm_cpu *))a1-&gt;oplist[i].handle)(a1);  return __readfsqword(0x28u) ^ v3;&#125;\n\nsub_E6E点进去就发现和我们的vm基础里的dispatcher结构一模一样，现在我们回头处理一下没命名的handle函数就可以正式逆向了\n识别函数：1.mov函数unsigned __int64 __fastcall sub_B5F(vm_cpu *a1)&#123;  int *v2; // [rsp+28h] [rbp-18h]  unsigned __int64 v3; // [rsp+38h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = (int *)(a1-&gt;vm_rip + 2);  switch ( *(_BYTE *)(a1-&gt;vm_rip + 1) )  &#123;    case 0xE1:      a1-&gt;vm_eax = *((char *)vm_stack + *v2);      break;    case 0xE2:      a1-&gt;vm_ebx = *((char *)vm_stack + *v2);      break;    case 0xE3:      a1-&gt;vm_ecx = *((char *)vm_stack + *v2);      break;    case 0xE4:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_eax;      break;    case 0xE5:      a1-&gt;vm_edx = *((char *)vm_stack + *v2);      break;    case 0xE7:      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_ebx;      break;    default:      break;  &#125;  a1-&gt;vm_rip += 6LL;  return __readfsqword(0x28u) ^ v3;&#125;\n\n这个函数的意思是，v2是栈中偏移，相当于ss:[ebp+v2]&#x3D;vm_stack[v2],当操作码&#x3D;-15也就是0xF1的时候，调用这个函数，下一个地址的数*(_BYTE )(a1-&gt;vm_rip+1))就是选择码，(_BYTE *)(a1-&gt;vm_rip+2))就是操作数\n\n选择码&#x3D;0xE1 执行mov eax ss:[ebp+v2]\n\n选择码&#x3D;0xE2 执行mov ebx ss:[ebp+v2]\n\n选择码&#x3D;0xE3 执行mov ecx ss:[ebp+v2]\n\n选择码&#x3D;0xE4 执行mov ss:[ebp+v2] eax \n\n选择码&#x3D;0xE5 执行mov edx ss:[ebp+v2]\n\n选择码&#x3D;0xE7 执行mov ss:[ebp+v2] ebx\n\n\n2.xorunsigned __int64 __fastcall sub_A64(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax ^= a1-&gt;vm_ebx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\n相当于xor eax ebx\n3.readunsigned __int64 __fastcall sub_AC5(vm_cpu *a1)&#123;  const char *buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  buf = (const char *)vm_stack;  read(0, vm_stack, 0x20uLL);  dword_2022A4 = strlen(buf);  if ( dword_2022A4 != 21 )  &#123;    puts(&quot;WRONG!&quot;);    exit(0);  &#125;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\n\n把flag读入栈上\n相当于call read,并判断flag长度\n4.nopunsigned __int64 __fastcall sub_956(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\n什么都没干，rip只是加1，这是所有指令都要有的\n5.mulunsigned __int64 __fastcall sub_A08(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax *= a1-&gt;vm_edx;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\nmul eax edx\n6.xchgunsigned __int64 __fastcall sub_8F0(vm_cpu *a1)&#123;  int vm_eax; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  vm_eax = a1-&gt;vm_eax;  a1-&gt;vm_eax = a1-&gt;vm_ebx;  a1-&gt;vm_ebx = vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v3;&#125;\n\nxchg eax ebx\n7.自定义函数unsigned __int64 __fastcall sub_99C(vm_cpu *a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  a1-&gt;vm_eax = a1-&gt;vm_ecx + 2 * a1-&gt;vm_ebx + 3 * a1-&gt;vm_eax;  ++a1-&gt;vm_rip;  return __readfsqword(0x28u) ^ v2;&#125;\n\n实现了eax&#x3D;ecx+2ebx+3eax应该是自定义指令\n自己实现dispatcher，汇编层面逆向#include&lt;iostream&gt;using namespace std;int opcode[]=&#123;0xF5, 0xF1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x20, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x01, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x21, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x22, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x03, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x23,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x24, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x25, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x26, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x27, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x28, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x09, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x29, 0x00, 0x00,   0x00, 0xF1, 0xE1, 0x0A, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x2A, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0B, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x2B, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0C,   0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2C, 0x00, 0x00, 0x00,   0xF1, 0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2D,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x2E, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0F, 0x00,   0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2F, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x10, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x30, 0x00,   0x00, 0x00, 0xF1, 0xE1, 0x11, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x31, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x12, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x32, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x13, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x33, 0x00, 0x00,   0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0xF1,   0xE1, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x01, 0x00, 0x00,   0x00, 0xF2, 0xF1, 0xE4, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE1,   0x01, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x02, 0x00, 0x00, 0x00,   0xF2, 0xF1, 0xE4, 0x01, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x03, 0x00, 0x00, 0x00, 0xF2,   0xF1, 0xE4, 0x02, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x03, 0x00,   0x00, 0x00, 0xF1, 0xE2, 0x04, 0x00, 0x00, 0x00, 0xF2, 0xF1,   0xE4, 0x03, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x05, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,   0x04, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x05,   0x00, 0x00, 0x00, 0xF1, 0xE1, 0x06, 0x00, 0x00, 0x00, 0xF1,   0xE2, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x08, 0x00, 0x00,   0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6, 0xF7, 0xF1,   0xE4, 0x06, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00,   0x00, 0xF1, 0xE2, 0x08, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x09,   0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6,   0xF7, 0xF1, 0xE4, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08,   0x00, 0x00, 0x00, 0xF1, 0xE2, 0x09, 0x00, 0x00, 0x00, 0xF1,   0xE3, 0x0A, 0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00,   0x00, 0xF6, 0xF7, 0xF1, 0xE4, 0x08, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x13, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x13, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00,   0xF1, 0xE2, 0x12, 0x00, 0x00, 0x00, 0xF8, 0xF1, 0xE4, 0x0E,   0x00, 0x00, 0x00, 0xF1, 0xE7, 0x12, 0x00, 0x00, 0x00, 0xF1,   0xE1, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x11, 0x00, 0x00,   0x00, 0xF8, 0xF1, 0xE4, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE7,   0x11, 0x00, 0x00, 0x00, 0xF4&#125;;int main()&#123;    int rip=0;    int vm_eax=0;    int vm_ebx=18;    int vm_ecx=0;    int vm_edx=0;    int vm_stack[521];    for(int i=0;i&lt;521;i++)    &#123;        vm_stack[i]=0;    &#125;    int len = sizeof(opcode) / sizeof(opcode[0]);    while (rip&lt;len)    &#123;        if(opcode[rip]==0xF1)        &#123;            int v2=opcode[rip+2];            switch(opcode[rip+1])            &#123;                case 0xE1:                    vm_eax = vm_stack[v2];                    cout&lt;&lt;&quot;mov eax,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE2:                    vm_ebx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ebx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE3:                    vm_ecx = vm_stack[v2];                    cout&lt;&lt;&quot;mov ecx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE4:                    vm_stack[v2] = vm_eax;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],eax&quot;&lt;&lt;endl;                    break;                case 0xE5:                    vm_edx = vm_stack[v2];                    cout&lt;&lt;&quot;mov edx,stack[&quot;&lt;&lt;v2&lt;&lt;&quot;]&quot;&lt;&lt;endl;                    break;                case 0xE7:                    vm_stack[v2] = vm_ebx;                    cout&lt;&lt;&quot;mov stack[&quot;&lt;&lt;v2&lt;&lt;&quot;],ebx&quot;&lt;&lt;endl;                    break;                default:                    break;            &#125;            rip+=6;            continue;        &#125;        else if(opcode[rip]==0xF2)        &#123;            vm_eax^=vm_ebx;            cout&lt;&lt;&quot;xor eax ebx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF5)        &#123;            // for(int i=0;i&lt;21;i++)            // &#123;            //     char c;            //     cin&gt;&gt;c;            //     vm_stack[i]=c;            // &#125;            cout&lt;&lt;&quot;read flag&amp;&amp;judge len&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xf4)        &#123;            cout&lt;&lt;&quot;nop&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF6)        &#123;            vm_eax=vm_ecx+2*vm_ebx+3*vm_eax;            cout&lt;&lt;&quot;eax=ecx+2*ebx+3*eax&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF7)        &#123;            vm_eax*=vm_edx;            cout&lt;&lt;&quot;mul eax edx&quot;&lt;&lt;endl;        &#125;        else if(opcode[rip]==0xF8)        &#123;            int t = vm_eax;            vm_eax = vm_ebx;            vm_ebx = t;            cout&lt;&lt;&quot;xchg eax ebx&quot;&lt;&lt;endl;        &#125;        rip++;    &#125;&#125;\n\n这里其实可以把栈信息一起打印出来的，但是这道题非常简单没有涉及到栈的其他操作，只是简单把flag放在栈上，所以这里不打印了\n结果：\nread flag&amp;&amp;judge lenmov eax,stack[0]xor eax ebxmov stack[32],eaxmov eax,stack[1]xor eax ebxmov stack[33],eaxmov eax,stack[2]xor eax ebxmov stack[34],eaxmov eax,stack[3]xor eax ebxmov stack[35],eaxmov eax,stack[4]xor eax ebxmov stack[36],eaxmov eax,stack[5]xor eax ebxmov stack[37],eaxmov eax,stack[6]xor eax ebxmov stack[38],eaxmov eax,stack[7]xor eax ebxmov stack[39],eaxmov eax,stack[8]xor eax ebxmov stack[40],eaxmov eax,stack[9]xor eax ebxmov stack[41],eaxmov eax,stack[10]xor eax ebxmov stack[42],eaxmov eax,stack[11]xor eax ebxmov stack[43],eaxmov eax,stack[12]xor eax ebxmov stack[44],eaxmov eax,stack[13]xor eax ebxmov stack[45],eaxmov eax,stack[14]xor eax ebxmov stack[46],eaxmov eax,stack[15]xor eax ebxmov stack[47],eaxmov eax,stack[16]xor eax ebxmov stack[48],eaxmov eax,stack[17]xor eax ebxmov stack[49],eaxmov eax,stack[18]xor eax ebxmov stack[50],eaxmov eax,stack[19]xor eax ebxmov stack[51],eaxnopread flag&amp;&amp;judge lenmov eax,stack[0]mov ebx,stack[1]xor eax ebxmov stack[0],eaxmov eax,stack[1]mov ebx,stack[2]xor eax ebxmov stack[1],eaxmov eax,stack[2]mov ebx,stack[3]xor eax ebxmov stack[2],eaxmov eax,stack[3]mov ebx,stack[4]xor eax ebxmov stack[3],eaxmov eax,stack[4]mov ebx,stack[5]xor eax ebxmov stack[4],eaxmov eax,stack[5]mov ebx,stack[6]xor eax ebxmov stack[5],eaxmov eax,stack[6]mov ebx,stack[7]mov ecx,stack[8]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[6],eaxmov eax,stack[7]mov ebx,stack[8]mov ecx,stack[9]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[7],eaxmov eax,stack[8]mov ebx,stack[9]mov ecx,stack[10]mov edx,stack[12]eax=ecx+2*ebx+3*eaxmul eax edxmov stack[8],eaxmov eax,stack[13]mov ebx,stack[19]xchg eax ebxmov stack[13],eaxmov stack[19],ebxmov eax,stack[14]mov ebx,stack[18]xchg eax ebxmov stack[14],eaxmov stack[18],ebxmov eax,stack[15]mov ebx,stack[17]xchg eax ebxmov stack[15],eaxmov stack[17],ebxnop\n\n正常一道普通的vm逆向题到这里看汇编逆向写exp就结束了，但这道题还有坑\n题外话：解题：这道题汇编前半部分很明显不对，因为flag总长度才21，栈上怎么索引到50多了，所以交叉引用找到真正的check函数,而且汇报中有两次输入，第二次输入才是真的\nunsigned __int64 sub_F00()&#123;  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; len_flag - 1 &gt; i; ++i )  &#123;    if ( *((_BYTE *)vm_stack + i) != byte_202020[i] )      exit(0);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\n\nexp：\nfrom z3 import *import re# 密文（十六进制字符串）flag = &#x27;69 45 2A 37 09 17 C5 0B 5C 72 33 76 33 21 74 31 5F 33 73 72&#x27;.split(&#x27; &#x27;)flag = [int(x, 16) for x in flag]# 1) 还原前面的三次交换（你在 forward 阶段做了 13&lt;-&gt;19, 14&lt;-&gt;18, 15&lt;-&gt;17）flag[15], flag[17] = flag[17], flag[15]flag[14], flag[18] = flag[18], flag[14]flag[19], flag[13] = flag[13], flag[19]# 2) 用 Z3 求解 a6,a7,a8（原始 stack[6..8]）# 方程（forward）是： f6 = (s8 + 2*s7 + 3*s6) * s12  （全部为字节运算）a6, a7, a8 = BitVecs(&#x27;a6 a7 a8&#x27;, 8)s = Solver()# 注意：这里 flag[...] 是 Python 整数（0..255），Z3 会自动把它转为相应的常量。# 若你想更严格地把所有算术限定为 8-bit，可把常量也包装成 BitVecVal(...,8)。s.add( BitVecVal(flag[6],8) == (a8 + (a7 &lt;&lt; 1) + a6 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[7],8) == (BitVecVal(flag[9],8)  + (a8 &lt;&lt; 1) + a7 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )s.add( BitVecVal(flag[8],8) == (BitVecVal(flag[10],8) + (BitVecVal(flag[9],8) &lt;&lt; 1) + a8 * BitVecVal(3,8)) * BitVecVal(flag[12],8) )if s.check() == sat:    m = s.model()    # 把求得的 a6,a7,a8 写回 flag 对应位置    for v in [a6, a7, a8]:        idx = int(re.search(r&#x27;\\d+&#x27;, str(v)).group())        flag[idx] = m[v].as_long()# 3) 逆向 XOR 链（forward 做了 f0 = s0^s1; f1 = s1^s2; ...; f5 = s5^s6）for i in range(5, -1, -1):    flag[i] ^= flag[i + 1]print(&#x27;[+] flag: &#x27;, &#x27;&#x27;.join(chr(x) for x in flag))# [+] flag:  Y0u_hav3_r3v3rs3_1t!\n\n","categories":["vm逆向题单"],"tags":["vm逆向","ctf"]},{"title":"逆向中的AES(一)","url":"/2025/10/09/aes/","content":"前言：aes在逆向有很多应用，尤其是现在越来越多软件加密逻辑都选择aes，所以总结一下aes的算法和在ctf逆向中的考点\naes算法基础\naes最重要的一个特征就是输入是128位分组，输出也是128位分组，但其中key分128位，192位，256位三种版本\n\n\n\nAES 类型\n密钥长度\n轮数 (Nr)\n密钥字数 (Nk)\n\n\n\nAES-128\n128 位\n10\n4\n\n\nAES-192\n192 位\n12\n6\n\n\nAES-256\n256 位\n14\n8\n\n\naes分组后16个字节是按矩阵方式排列\n\n加密总流程：\n最终轮和前面9轮的区别是没有第三个步骤列混合\n初始变换(Initial round)初始变换就是输入的16个字节和密钥(不确定几位)进行密钥扩展后生成的$\\text{RoundKey}_0$(16位)异或的结果\n$$\\text{State}’ &#x3D; \\text{State} \\oplus \\text{RoundKey}_0$$\n展开为矩阵形式：\n$$\\begin{bmatrix}s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \\s_{1,0} &amp; s_{1,1} &amp; s_{1,2} &amp; s_{1,3} \\s_{2,0} &amp; s_{2,1} &amp; s_{2,2} &amp; s_{2,3} \\s_{3,0} &amp; s_{3,1} &amp; s_{3,2} &amp; s_{3,3}\\end{bmatrix};\\oplus;\\begin{bmatrix}k_{0,0} &amp; k_{0,1} &amp; k_{0,2} &amp; k_{0,3} \\k_{1,0} &amp; k_{1,1} &amp; k_{1,2} &amp; k_{1,3} \\k_{2,0} &amp; k_{2,1} &amp; k_{2,2} &amp; k_{2,3} \\k_{3,0} &amp; k_{3,1} &amp; k_{3,2} &amp; k_{3,3}\\end{bmatrix};&#x3D;;\\begin{bmatrix}s’{0,0} &amp; s’{0,1} &amp; s’{0,2} &amp; s’{0,3} \\s’{1,0} &amp; s’{1,1} &amp; s’{1,2} &amp; s’{1,3} \\s’{2,0} &amp; s’{2,1} &amp; s’{2,2} &amp; s’{2,3} \\s’{3,0} &amp; s’{3,1} &amp; s’{3,2} &amp; s’{3,3}\\end{bmatrix}$$\n其中：\n\n$s_{i,j}$ 为明文状态矩阵中第 $(i,j)$ 个字节  \n$k_{i,j}$ 为轮密钥矩阵中第 $(i,j)$ 个字节  \n$\\oplus$ 表示按字节异或（XOR）运算\n\n循环运算：字节代换：\n字节代换就是把第一步初始变换后的16字节矩阵块用s表代换，例如矩阵左上角的数是十六进制19，那就要代换成s盒中第1行第9列，查表可知是d4，以此类推\n结果：\n\n行移位：ShiftRows 操作在状态矩阵上进行，规则如下：\n\n第 0 行不变\n第 1 行循环左移 1 字节\n第 2 行循环左移 2 字节\n第 3 行循环左移 3 字节\n\n原始状态矩阵：\n$$\\text{State} &#x3D;\\begin{bmatrix}s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \\s_{1,0} &amp; s_{1,1} &amp; s_{1,2} &amp; s_{1,3} \\s_{2,0} &amp; s_{2,1} &amp; s_{2,2} &amp; s_{2,3} \\s_{3,0} &amp; s_{3,1} &amp; s_{3,2} &amp; s_{3,3}\\end{bmatrix}$$\n经过行移位后：\n$$\\text{State}’ &#x3D;\\begin{bmatrix}s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \\s_{1,1} &amp; s_{1,2} &amp; s_{1,3} &amp; s_{1,0} \\s_{2,2} &amp; s_{2,3} &amp; s_{2,0} &amp; s_{2,1} \\s_{3,3} &amp; s_{3,0} &amp; s_{3,1} &amp; s_{3,2}\\end{bmatrix}$$\n每一行的移位规律如下：\n\n\n\n行号\n移位字节数\n移位方向\n\n\n\n0\n0\n不变\n\n\n1\n1\n左移\n\n\n2\n2\n左移\n\n\n3\n3\n左移\n\n\n列混淆：\n左乘一个确定的矩阵，但是这里的乘法不是普通乘法\n列混淆中的乘法$$\\begin{aligned}s’{0,c} &amp;&#x3D; (02 \\cdot s{0,c}) \\oplus (03 \\cdot s_{1,c}) \\oplus s_{2,c} \\oplus s_{3,c} \\s’{1,c} &amp;&#x3D; s{0,c} \\oplus (02 \\cdot s_{1,c}) \\oplus (03 \\cdot s_{2,c}) \\oplus s_{3,c} \\s’{2,c} &amp;&#x3D; s{0,c} \\oplus s_{1,c} \\oplus (02 \\cdot s_{2,c}) \\oplus (03 \\cdot s_{3,c}) \\s’{3,c} &amp;&#x3D; (03 \\cdot s{0,c}) \\oplus s_{1,c} \\oplus s_{2,c} \\oplus (02 \\cdot s_{3,c})\\end{aligned}$$\n其中乘法在有限域 $GF(2^8)$ 上进行：\n\n$02 \\cdot x$ 表示按字节左移一位（若最高位为 1，则再与 0x1B 异或）  \n$03 \\cdot x &#x3D; (02 \\cdot x) \\oplus x$\n\n注：与0x1B异或是因为要构造有限域$GF(2^8)$构造出来的多项式把$x^8$模之后的结果，学逆向不用学那么深，只需要知道aes的加密解密和漏洞攻击就可以了\n轮密钥加：AddRoundKey 是 AES 每一轮中最简单但最关键的操作之一。它将 状态矩阵 (State) 与 轮密钥矩阵 (RoundKey) 按字节异或（XOR）：\n$$\\text{State}’ &#x3D; \\text{State} \\oplus \\text{RoundKey}_i$$\n设状态矩阵为：\n$$\\text{State} &#x3D;\\begin{bmatrix}s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \\s_{1,0} &amp; s_{1,1} &amp; s_{1,2} &amp; s_{1,3} \\s_{2,0} &amp; s_{2,1} &amp; s_{2,2} &amp; s_{2,3} \\s_{3,0} &amp; s_{3,1} &amp; s_{3,2} &amp; s_{3,3}\\end{bmatrix}$$\n轮密钥矩阵为：\n$$\\text{RoundKey}i &#x3D;\\begin{bmatrix}k{0,0} &amp; k_{0,1} &amp; k_{0,2} &amp; k_{0,3} \\k_{1,0} &amp; k_{1,1} &amp; k_{1,2} &amp; k_{1,3} \\k_{2,0} &amp; k_{2,1} &amp; k_{2,2} &amp; k_{2,3} \\k_{3,0} &amp; k_{3,1} &amp; k_{3,2} &amp; k_{3,3}\\end{bmatrix}$$\n异或后得到：\n$$\\text{State}’ &#x3D;\\begin{bmatrix}s_{0,0} \\oplus k_{0,0} &amp; s_{0,1} \\oplus k_{0,1} &amp; s_{0,2} \\oplus k_{0,2} &amp; s_{0,3} \\oplus k_{0,3} \\s_{1,0} \\oplus k_{1,0} &amp; s_{1,1} \\oplus k_{1,1} &amp; s_{1,2} \\oplus k_{1,2} &amp; s_{1,3} \\oplus k_{1,3} \\s_{2,0} \\oplus k_{2,0} &amp; s_{2,1} \\oplus k_{2,1} &amp; s_{2,2} \\oplus k_{2,2} &amp; s_{2,3} \\oplus k_{2,3} \\s_{3,0} \\oplus k_{3,0} &amp; s_{3,1} \\oplus k_{3,1} &amp; s_{3,2} \\oplus k_{3,2} &amp; s_{3,3} \\oplus k_{3,3}\\end{bmatrix}$$\n按字节运算公式每个字节的计算方式为：\n$$s’{i,j} &#x3D; s{i,j} \\oplus k_{i,j}, \\quad 0 \\le i,j \\le 3$$\n密钥扩展：初始只有128&#x2F;192&#x2F;256位的密钥是怎么更新的呢，这就涉及到密钥扩展\n这是初始状态，这里以128位密钥为例，先全部填入前4列，设第5列为Wi\n\n\n初始部分：\n\n$$W[i] &#x3D; \\text{原始密钥的第 } i \\text{ 个 32 位字}, \\quad 0 \\le i &lt; N_k$$\n\n递推部分：（适用于所有aes算法）\n\n对于 $i \\ge N_k$：\n$$W[i] &#x3D;\\begin{cases}W[i - N_k] \\oplus \\text{SubWord}(\\text{RotWord}(W[i - 1])) \\oplus \\text{Rcon}[i&#x2F;N_k], &amp; \\text{if } i \\bmod N_k &#x3D; 0 \\W[i - N_k] \\oplus \\text{SubWord}(W[i - 1]), &amp; \\text{if } N_k &gt; 6 \\text{ and } i \\bmod N_k &#x3D; 4  (只有aes256有这条)\\W[i - N_k] \\oplus W[i - 1], &amp; \\text{otherwise}\\end{cases}$$\n函数定义RotWord：循环左移 1 字节  \n$$[a_0, a_1, a_2, a_3] \\Rightarrow [a_1, a_2, a_3, a_0]$$\n\nSubWord：对 4 个字节分别进行 S-box 替代  \n$$[a_0, a_1, a_2, a_3] \\Rightarrow [S(a_0), S(a_1), S(a_2), S(a_3)]$$\nRcon：轮常数，仅作用于字的第一个字节：\n$$\\text{Rcon}[i] &#x3D;\\begin{bmatrix}\\text{RC}[i] &amp; 00 &amp; 00 &amp; 00\\end{bmatrix}$$\n其中$\\text{RC}[1] &#x3D; 0x01$，$\\text{RC}[2] &#x3D; 0x02$，$\\text{RC}[3] &#x3D; 0x04$，$\\text{RC}[4] &#x3D; 0x08$，$\\text{RC}[5] &#x3D; 0x10$，$\\text{RC}[6] &#x3D; 0x20$，$\\text{RC}[7] &#x3D; 0x40$，$\\text{RC}[8] &#x3D; 0x80$，$\\text{RC}[9] &#x3D; 0x1B$，$\\text{RC}[10] &#x3D; 0x36$\n最终结果\n解密方式就是把上述过程反过来一遍（解密的第一轮没有列混合逆向）\n\n其中的轮密钥加只需要每轮相同状态的W[i,i+3]就可以\n逆列混淆\n逆行移位：就是逆向移位就可以，很简单\n逆s表\n查表即可\n逆向题型：普通AES找到密钥，找到密文，逆向脚本，进行解密。\n白盒AES\n\n\n项目\n普通 AES（黑盒）\n白盒 AES\n\n\n\n密钥\n独立变量、明确定义\n被混入查表中，不可直接访问\n\n\n算法结构\n明确的五步（SubBytes 等）\n各步骤混淆成查表和线性映射\n\n\n可移植性\n高（用同样的密钥随处运行）\n低（查表与密钥绑定）\n\n\n安全假设\n攻击者看不到内部\n攻击者能看到全部\n\n\n 目前市面上大多数app都是基于白盒aes开发的，还有查表法实现的aes真的严格按照上面讲的aes流程走的很少，白盒aes东西太多了，而且还有很多攻击手法，就放在”逆向中的AES(二)“里讲好了\n参考资料：【AES加密算法】| AES加密过程详解| 对称加密| Rijndael-128| 密码学| 信息安全_哔哩哔哩_bilibili\n密码学——AES&#x2F;DES加密算法原理介绍 - 枫のBlog\n","categories":["逆向中的密码学","对称加密题单"],"tags":["aes"]},{"title":"Hello World","url":"/2025/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"vm逆向基础及做题套路","url":"/2025/10/06/vm%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/","content":"前言：学过计算机组成原理的应该都知道，程序的运行是靠cpu解释可执行文件中操作码来实现的功能，vm逆向顾名思义就是自己定义了小型cpu并定义了指令集，将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。\nvm逆向基本原理：vm_init：虚拟机的入口函数，对虚拟机环境进行初始化，初始化一般包括\n\n寄存器初始化(eax,ebx,ecx,edx,eip)\n\n把handle函数和操作码连接在一起\n\n给虚拟机的栈空间vm_stack分配内存\n\n\nvm_run:虚拟机开始运行的地方\nvm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。\nvm_handle:处理器，当rip走到对应操作码时调用对应操作函数，并接受操作数。\nopcode :程序可执行代码转换成的操作码\n在这种情况下，如果要逆向程序，就需要对整个emulator结构进行逆向，理解程序功能，还需要结合opcode进行分析，整个程序逆向工程将会十分繁琐。这是一个一般虚拟机结构：\nvm_lables:有的虚拟机涉及lable的创造和调用，起到跳转目的\n分析方法在比赛中，虚拟机题目常常有两种考法：\n\n给可执行程序和opcode，逆向emulator，结合opcode文件，推出flag\n\n只给可执行程序，逆向emulator，构造opcode，读取flag\n\n\n拿到一个虚拟机之后，一般有以下几个逆向过程：\n\n分析虚拟机入口，搞清虚拟机的输入，或者opcode位置\n\n理清虚拟机结构，包括Dispatcher和各个Handler\n\n逆向各个Handler，分析opcode的意义\n\n根据opcode运行时打印出对应汇编代码，根据汇编代码逻辑进行逆向\n\n\n一个简单vm虚拟机实例：vm_cpu结构体typedef struct&#123;    unsigned long r1;    //虚拟寄存器r1    unsigned long r2;    //虚拟寄存器r2    unsigned long r3;    //虚拟寄存器r3    unsigned char *eip;    //指向正在解释的opcode地址    vm_opcode op_list[OPCODE_N];    //opcode列表，存放了所有的opcode及其对应的处理函数&#125;vm_cpu;\n\nvm_opcode结构体typedef struct&#123;    unsigned char opcode;    void (*handle)(void*);&#125;vm_opcode;\n\nvm_init()void *vm_init()&#123;    vm_vpu *cpu;    cpu-&gt;r1 = 0;    cpu-&gt;r2 = 0;    cpu-&gt;r3 = 0;    cpu-&gt;eip = (unsigned char *)vm_code;//将eip指向opcode的地址    cpu-&gt;op_list[0].opcode = 0x1;    cpu-&gt;op_list[0].handle = (void (*)(void *))mov;//将操作字节码与对应的handle函数关联在一起    cpu-&gt;op_list[1].opcode = 0xf2;    cpu-&gt;op_list[1].handle = (void (*)(void *))xor;    cpu-&gt;op_list[2].opcode = 0xf5;    cpu-&gt;op_list[2].handle = (void (*)(void *))read_;    vm_stack = malloc(0x512);    memset(vm_stack,0,0x512);&#125;\n\nhandles(示例)void mov(vm_cpu *cpu);void xor(vm_cpu *cpu);    //xor flagvoid read_(vm_cpu *cpu);    //call read, read the flagvoid xor(vm_cpu *cpu)&#123;    int temp;    temp = cpu-&gt;r1 ^ cpu-&gt;r2;    temp ^= 0x12;    cpu-&gt;r1 = temp;    cpu-&gt;eip += 1;    //xor指令占一个字节&#125;void read_(vm_cpu *cpu)&#123;    char *dest = vm_stack;    read(0,dest,12);    //用于往虚拟机的栈上读取数据    cpu-&gt;eip += 1;    //read_指令占一个字节&#125;void mov(vm_cpu *cpu)&#123;    //mov指令的参数都因曾在字节码也就是vm_code中，指令表示后的一个字节是寄存器表示，第二到//第五是要mov的数据在vm_stack上的偏移    //这里只是实现了从vm_stack上取数据和存数据到vm_stack上    unsigned char *res = cpu-&gt;eip + 1;    //寄存器标识    int *offset = (int *)(cpu-&gt;eip + 2);    //寄存器在vm_stack上的偏移    char *dest = 0;    dest = vm_stack;    switch (*res) &#123;        case 0xe1:            cpu-&gt;r1 = *(dest + *offset);            break;           case 0xe2:            cpu-&gt;r2 = *(dest + *offset);            break;           case 0xe3:            cpu-&gt;r3 = *(dest + *offset);            break;           case 0xe4:        &#123;            int x = cpu-&gt;r1;            *(dest + *offset) = x;            break;        &#125;    &#125;       cpu-&gt;eip += 6;    //mov指令占六个字节，所以eip要向后移6位&#125;\n\nvm_code​unsigned char vm_code[] = &#123;    0xf5,    0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00,    0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00,    0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00,    0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00,    0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00,    0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00,    0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00,    0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00,    0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00,    0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00,    0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00,    0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00,    0xf4&#125;;​\n\nvm_stack一般是一个全局数组，用于存放虚拟机的栈\nvm_stack = malloc(0x512);memset(vm_stack,0,0x512);\n\n\n\nvm_runvoid vm_run(vm_cpu *cpu)&#123;    /*    进入虚拟机    eip指向要被解释的opcode地址    */    cpu-&gt;eip = (unsigned char*)opcodes;    while((*cpu-&gt;eip) != 0xf4)//如果opcode不为RET，就调用vm_dispatcher来解释执行    &#123;        vm_dispatcher(*cpu-&gt;eip)    &#125;&#125;\n\nvm_dispatchervoid vm_dispatcher(vm_cpu *cpu)&#123;    int i;    for(i = 0; i &lt; OPCODE_N; i++)    &#123;            if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode)        &#123;            cpu-&gt;op_list[i].handle(cpu);            break;        &#125;    &#125;&#125;\n\n\n\n做题流程：\n先根据上面的特征静态分析判断函数是vm中的哪一部分，如果静态分析困难，那就动调一下\n\n找到对应部分后创建上述结构体来帮助分析\n\n自己把vm还原在vscode里，并在dispatcher部分加上打印这条指令的代码，有的时候也可以打印stack，和当前执行完指令的内存状态(各个变量的值)\n\n根据打印出的汇编指令，手动逆向\n\n\n具体使用方法还需在实战中不断练习，具体做题流程可看我的vm题单真题\n参考文献：虚拟机逆向与实现-CSDN博客\n虚拟机保护逆向入门 - FreeBuf网络安全行业门户\n","categories":["vm逆向题单"],"tags":["vm逆向"]},{"title":"rust逆向基础-rust基础语法","url":"/2025/10/01/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","content":"前言:拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下\nrust相比其他编程语言的优势:\nrust不通过 GC(garbage collection)机制管理内存,例如python,golang等基于GC机制的编程语言会在exe运行时不断寻找虚拟地址中无用的内存空间.这会大大降低运行速度\n\nrust使用所有权机制管理内存,这也使得它相比与手动开辟内存的c&#x2F;c++更安全\n\n\n我们rust在逆向中通常用于网络编程,游戏编程,wasm,嵌入式.所以写游戏外挂,实现检测外挂都必须要学习rust.\n语法:变量:rust中变量声明要用let.rust中每个变量类型可以自己指定,也可交给编译器推断,每个变量类型可以声明可变也可声明不可变.(注:如果要声明常量类型时,常量名一定要全大写,并且必须显示指定类型.例如 const MAX:u32=10;)\n整数类型\n有符号：i8, i16, i32, i64, i128, isize\n\n无符号：u8, u16, u32, u64, u128, usize\n\n\n浮点数\nf32（32 位单精度）\n\nf64（64 位双精度，默认）\n\n\n布尔型\ntrue\n\nfalse\n\n\nchar型字符串型\n&amp;str → 字符串切片（不可变）\n\nString → 堆分配的可变字符串\n\n\nfn main() &#123;    let n: i32= 5; // 变量后的：i32可以自己指定，也可让编译器推断    let mut i: u32 = 5; // u32 表示32位无符号整数,mut表示可变    println!(&quot;The value of n is &#123;&#125;&quot;,n); // println! 用来打印字符串到终端，n代表换行，!代表宏    println!(&quot;The value of i is &#123;&#125;&quot;,i);    i=7;    println!(&quot;The value of i is &#123;&#125;&quot;,i);    let x: f64 = 5.2;    println!(&quot;The value of x is &#123;&#125;&quot;,x);    let y: char =&#x27;d&#x27;;    println!(&quot;The value of y is &#123;&#125;&quot;,y);    let t=true;    println!(&quot;The value of t is &#123;&#125;&quot;,t);    let str: &amp;str=&quot;hello&quot;;    println!(&quot;The value of str is &#123;&#125;&quot;,str);    let mut s2: String = String::from(&quot;Hello&quot;);    s2.push_str(&quot;, Rust!&quot;);        // 可变字符串    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n\n输出结果:\nThe value of n is 5The value of i is 5The value of i is 7The value of x is 5.2The value of y is dThe value of t is trueThe value of str is helloHello, Rust!\n\n控制语句:if-else if-else// iflet n = 5;if n &lt; 0 &#123;    println!(&quot;负数&quot;);&#125; else &#123;    println!(&quot;非负数&quot;);&#125;\n\n\n\n循环\nloop 一直循环\n\nwhile 有条件的循环\n\nfor\n\n\n可以通过break跳出循环,也可以通过continue继续当前循环.这和c++是一样的\n// looplet mut counter = 0;let result = loop &#123;    counter += 1;    if counter == 10 &#123;        break counter * 2; // 返回值    &#125;&#125;;// whilelet mut i = 3;while i &gt; 0 &#123;    println!(&quot;&#123;&#125;&quot;, i);    i -= 1;&#125;// forlet arr = [10, 20, 30];for val in arr &#123;    println!(&quot;&#123;&#125;&quot;, val);&#125;\n\n\n\nMatchmatch的用法和if-else很像,但是要注意match要把所有情况包含在内,不然编译阶段就报错\nlet x = 5;match x &#123;    1 | 2 =&gt; println!(&quot;一或二&quot;),    3..=7 =&gt; println!(&quot;三到七之间&quot;), // 范围匹配    _ =&gt; println!(&quot;其他&quot;),&#125;\n\n\n\n函数函数使用基本的函数定义是fn fucnction(a:i32,b:i32) -&gt; i32其中箭头右面的是返回值类型.rust函数表达力非常强\nfn add(a:i32,b:i32)-&gt;i32&#123;    a+b //不加分号，rust会将最后一行作为返回值&#125;fn main() &#123;    let a=1;    let b=3;    let res=add(a,b);    println!(&quot;&#123;&#125;&quot;,res);//println!()是rust的输出函数，其中第一个参数必须是&quot;&quot;包裹的字符串(不能用&#x27;&#x27;替代)，第二个参数是占位符，占位符的值通过&#123;&#125;来传递&#125;\n\n闭包:闭包可以理解成python里的lambda差不多,相当于匿名函数\nfn main() &#123;    let sum=|a:i32,b:i32|-&gt;i32&#123;a+b&#125;;//这里定义时是用||包裹参数，调用时和正常函数一样    let res=sum(1,2);    println!(&quot;The sum is &#123;&#125;&quot;,res);&#125;\n\nrust复合类型枚举:简单来说，枚举（enum）就是用来表示“一个值可能属于几种互斥情况之一”，也就是“有限状态或选择”。\n换句话说，它适合表示有多种可能性，但每次只能选一个的场景。\nenum TrafficLight &#123;    Red,    Yellow,    Green,&#125;let light = TrafficLight::Red;match light &#123;    TrafficLight::Red =&gt; println!(&quot;停&quot;),    TrafficLight::Yellow =&gt; println!(&quot;准备&quot;),    TrafficLight::Green =&gt; println!(&quot;走&quot;),&#125;\n\n结构体基础:结构体和enum不一样的点在于声明结构体时,要把内部变量的类型写出来.而enum就不用\n其中对#[derive(Debug)]的解释:\n\n\n\n部分\n含义\n记忆小技巧\n\n\n\n#[]\nRust 的 属性（attribute）标记，用来告诉编译器对后面的结构体&#x2F;枚举做某些处理\n“井号括号 → 给编译器的指令”\n\n\nderive\n自动 派生&#x2F;生成实现 trait 的代码\n“derive &#x3D; 自动生成某种功能”\n\n\n(Debug)\n指定生成的 trait 是 Debug\n“Debug &#x3D; 调试打印能力”\n\n\n#[derive(Debug)]struct Node&#123;    x: i32,    y: i32&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    println!(&quot;&#123;&#125;&quot;, x);    println!(&quot;&#123;&#125;&quot;, y);    println!(&quot;&#123;:?&#125;&quot;, n); //打印结构体或enum类型，要用&#123;:?&#125;,配合结构体定义上方的#[derive(Debug)]打印结构体&#125;\n\n结构体进阶:Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 key: value 语法来实现定义：\n实例化时:\n结构体类名 {    字段名 : 字段值,    …}\n(1)在结构体内部用impl关键字实现内联函数:\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn area(x:i32,y:i32)-&gt;i32&#123;        x*y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    let s=Node::area(x, y);    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n (2)用结构体中self指针实现\nstruct Node&#123;    x: i32,    y: i32,&#125;// impl Node&#123;//     fn area(x:i32,y:i32)-&gt;i32&#123;//         x*y//     &#125;// &#125;impl Node&#123;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node&#123;x: 1, y: 2&#125;;    let x=n.x;    let y=n.y;    //let s=Node::area(x, y);    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n(3)结构体实现构造函数\nstruct Node&#123;    x: i32,    y: i32,&#125;impl Node&#123;    fn new(x:i32,y:i32)-&gt;Self&#123;//默认构造函数名都叫new，但这不是个关键字        Node&#123;            x:x,            y:y        &#125;    &#125;    fn area(&amp;self)-&gt;i32&#123;        self.x*self.y    &#125;&#125;fn main() &#123;    let n=Node::new(1,2);    let x=n.x;    let y=n.y;    let s=n.area();    println!(&quot;&#123;&#125;&quot;,s);&#125;\n\n(4)self的用法:\n\nself 小写 &#x3D; 当前对象实例指针。\n\nSelf 大写 &#x3D; 当前类型名。\n\n\nself指针也分为可变和不可变的,可变的要在self前加关键字mut\n#[derive(Debug)]struct Person&#123;    name:String,    age:u32&#125;impl Person&#123;    fn new(name:String,age:u32)-&gt;Self&#123;        Person&#123;name,age&#125;    &#125;    //不可变的this指针    fn greet(&amp;self)-&gt;String&#123;        format!(&quot;Hello,my name is &#123;&#125; and I am &#123;&#125; years old.&quot;,self.name,self.age)    &#125;    //可变的this指针    fn up_age(&amp;mut self)-&gt;u32&#123;        self.age+=1;        self.age    &#125;&#125;fn main() &#123;    let a=Person::new(&quot;原子&quot;.to_string(), 18); //“原子”是静态str.&amp;str类型，要转成可变的String    println!(&quot;&#123;:#?&#125;&quot;,a); //&#123;:#?&#125;是调试格式，和&#123;:?&#125;的区别是，&#123;:#?&#125;会多出缩进，方便阅读    println!(&quot;&#123;&#125;&quot;,a.greet());    let mut b =a;    b.up_age();    println!(&quot;&#123;&#125;&quot;,b.greet());&#125;\n\n输出:\nPerson &#123;    name: &quot;原子&quot;,    age: 18,&#125;Hello,my name is 原子 and I am 18 years old.Hello,my name is 原子 and I am 19 years old.\n\nself还有一个不经常用的用法:就是如果传入参数是self(不带&amp;)的话:\nstruct Node &#123;    x: i32,    y: i32,&#125;impl Node &#123;    // 这里的 self 是按值传递，意味着把 Node 本身交给这个方法    fn into_tuple(self) -&gt; (i32, i32) &#123;        (self.x, self.y)    &#125;&#125;fn main() &#123;    let n = Node &#123; x: 1, y: 2 &#125;;    let t = n.into_tuple();  //  这里 n 被 move 走    println!(&quot;&#123;:?&#125;&quot;, t);    // println!(&quot;&#123;:?&#125;&quot;, n.x); //  报错：因为 n 的所有权已经交出，不能再用&#125;\n\n元组:1.基本定义:元组就是把多个不同类型的值组合在一起的复合类型。语法：\nlet tup: (i32, f64, char) = (500, 6.4, &#x27;a&#x27;);\n\n2.访问元素\n有两种方式：\n方式一：解构\nlet tup = (500, 6.4, &#x27;a&#x27;);let (x, y, z) = tup;println!(&quot;y 的值是: &#123;&#125;&quot;, y);\n\n方式二：点语法（下标访问）\n注意第一个元素下标是0\nlet tup = (500, 6.4, &#x27;a&#x27;);println!(&quot;第一个元素是: &#123;&#125;&quot;, tup.0);println!(&quot;第二个元素是: &#123;&#125;&quot;, tup.1);println!(&quot;第三个元素是: &#123;&#125;&quot;, tup.2);\n\n3.特点:可以包含不同类型的值\n长度固定，不能改变\n4.打印可利用{:?}来打印\n核心机制&amp;数据结构栈和堆存放\n栈 (Stack) 的特点\n\n\n后进先出 (LIFO) 的数据结构，内存分配和释放都非常快。\n\n大小在编译时必须确定。\n\n栈上的数据一般是 固定大小、生命周期明确的值。\n\n\nlet x = 42;       // i32，大小固定 4 字节let y = true;     // bool，1 字节let z = &#x27;a&#x27;;      // char，4 字节let s : &amp;str = &#x27;hello&#x27;  //静态字符串切片,长度固定,在栈上\n\n\n堆 (Heap) 的特点\n\n\n内存大小运行时才能确定。\n\n需要手动申请（在 Rust 中由所有权系统管理，避免泄漏）。\n\n分配和释放开销比栈大，但适合存放 动态大小或不确定大小的数据。\n\n\n所有权机制堆和栈上数据都有所有权的这个概念,但是栈上数据拷贝时不会move(转移所有权),而是使用copy(复制一个样本),堆会move\n栈上的数据：如果它的类型实现了 Copy trait（比如 i32、bool、char、浮点数、简单元组），那么赋值时不会发生“严格意义上的 move”，而是直接 复制一份值。\n\n所以原变量不会失效，看起来像“转移没事”。\n\n实际上这不是“move”，而是 copy。\nfn main() &#123;    let x = 10;    let y = x;  // Copy，不是 move    println!(&quot;x=&#123;&#125;, y=&#123;&#125;&quot;, x, y); //  x 还能用&#125;\n\n堆上的数据：比如 String、Vec，它们没实现 Copy，赋值时会发生 move。\n\n所有权转移后，原变量会失效，防止两个变量同时指向同一块堆内存。\n\nfn main() &#123;    let s1 = String::from(&quot;hi&quot;);    let s2 = s1;   // Move    // println!(&quot;&#123;&#125;&quot;, s1); // 报错：s1 已经失效    println!(&quot;&#123;&#125;&quot;, s2);   //  只有 s2 能用了&#125;\n\n引用和可变引用:引用 (Reference)\n\n引用本质上就是 借用 (borrow)。\n\n借用不会转移所有权，值的所有者依然是原来的变量。\n\n分为：\n不可变引用 (&amp;T)：可以有多个，但不能和可变引用同时存在。\n可变引用 (&amp;mut T)：只能有一个，且不能和不可变引用共存。(可变引用要求被引用的变量是可变的)\n\n\nfn main() &#123;    let a:String =&quot;hello world&quot;.to_string();    let r1=&amp;a; //这里就算拷贝给r1,也能成功输出    println!(&quot;&#123;&#125;&quot;,a);&#125;\n\nclone的使用:#[derive(Debug,Clone)] //必须结构体里的所有字段都是可拷贝的，才可像正常u32，i32那样使用struct man&#123;    name:String,    age:u32&#125;fn main() &#123;    let a = man&#123;        name:&quot;原子&quot;.to_string(),        age:18    &#125;;    let m=a.clone();    println!(&quot;&#123;:?&#125;&quot;,a);&#125;\n\nclone就相当于c++中的深拷贝,解决了两个指针指向同一块内存的问题,所以clone之后就可以正常赋值,并接着使用\n生命周期:生命周期用语法 &#39;a 表示：\nfn example&lt;&#x27;a&gt;(s: &amp;&#x27;a str) &#123;    println!(&quot;&#123;&#125;&quot;, s);&#125;\n\n当结构体里有引用时，必须标注生命周期：\nstruct Person&lt;&#x27;a&gt; &#123;    name: &amp;&#x27;a str,    age: u32,&#125;fn main() &#123;    let name = String::from(&quot;Alice&quot;);    let p = Person &#123; name: &amp;name, age: 20 &#125;; // name 生命周期必须 ≥ p 生命周期&#125;\n\n生命周期的核心思想:引用永远不能比它指向的数据活得长。\n编译器在编译期检查生命周期，保证安全。\n&#39;a 是标识符，用来关联多个引用的生命周期。\n常用数据结构:String:&amp;str:是String类型的一个切片.长度确定放在栈上.\nString一般长度不确定,放在堆上\n创建:let s1 = String::new();              // 空字符串let s2 = String::from(&quot;hello&quot;);      // 从字面量创建let s3 = &quot;world&quot;.to_string();        // &amp;str 转 String\n\n添加:let mut s = String::from(&quot;Hello&quot;);s.push(&#x27;!&#x27;);          // 添加单个字符s.push_str(&quot; World&quot;); // 添加字符串切片\n\n拼接:let s1 = String::from(&quot;Hello&quot;);let s2 = String::from(&quot;World&quot;);// 使用 + 或 format! 宏let s3 = s1 + &amp;s2;           // s1 被移动，s2 被借用let s4 = format!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, &quot;!!!&quot;);  // 不移动任何变量\n\n获取长度和容量let s = String::from(&quot;hello&quot;);println!(&quot;length: &#123;&#125;&quot;, s.len());    // 字节数println!(&quot;capacity: &#123;&#125;&quot;, s.capacity()); // 堆上分配的容量\n\n删除内容let mut s = String::from(&quot;Hello World&quot;);s.pop();              // 删除最后一个字符s.clear();            // 清空整个字符串\n\n索引与切片let s = String::from(&quot;hello&quot;);// let c = s[0]; //  String 不支持直接索引let slice = &amp;s[0..2]; //  切片，返回 &amp;str，必须按字节边界\n\n查找和替换let s = String::from(&quot;hello world&quot;);println!(&quot;&#123;&#125;&quot;, s.contains(&quot;world&quot;));  // trueprintln!(&quot;&#123;&#125;&quot;, s.find(&quot;world&quot;).unwrap()); // 6，找到索引let new_s = s.replace(&quot;world&quot;, &quot;Rust&quot;);println!(&quot;&#123;&#125;&quot;, new_s); // hello Rust\n\n分割字符串let s = String::from(&quot;a,b,c&quot;);let v: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();println!(&quot;&#123;:?&#125;&quot;, v); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n\n遍历let s = String::from(&quot;hello&quot;);// 遍历字符for c in s.chars() &#123;    println!(&quot;&#123;&#125;&quot;, c);&#125;// 遍历字节for b in s.bytes() &#123;    println!(&quot;&#123;&#125;&quot;, b);&#125;\n\nVector:创建:let mut v: Vec&lt;i32&gt; = Vec::new();   // 空 vectorlet mut v = vec![1, 2, 3];          // 使用宏 vec! 初始化\n\n添加元素let mut v = Vec::new();v.push(10);   // 尾部插入v.push(20);\n\n访问元素let v = vec![1, 2, 3, 4];println!(&quot;&#123;&#125;&quot;, v[0]);        // 下标访问 (可能 panic 越界)println!(&quot;&#123;:?&#125;&quot;, v.get(2));  // 安全访问 -&gt; Some(3)println!(&quot;&#123;:?&#125;&quot;, v.get(10)); // None，不会 panic\n\n修改元素let mut v = vec![10, 20, 30];v[1] = 200;\n\n删除元素let mut v = vec![1, 2, 3, 4];v.pop();          // 删除最后一个 -&gt; Some(4)v.remove(0);      // 删除指定下标 -&gt; 返回删除的元素 (这里删除 1)\n\n遍历let v = vec![10, 20, 30];for x in &amp;v &#123;              // 只读遍历    println!(&quot;&#123;&#125;&quot;, x);&#125;for x in &amp;mut v &#123;          // 可修改遍历    *x += 1;&#125;\n\nHashMap:相当于c++中stl里的map\nuse std::collections::HashMap;fn main() &#123;    // 1. 创建一个 HashMap    let mut scores = HashMap::new();    // 2. 增加（插入）元素    scores.insert(&quot;Alice&quot;, 10);    scores.insert(&quot;Bob&quot;, 20);    // 3. 修改（如果 key 已存在，会覆盖旧值）    scores.insert(&quot;Alice&quot;, 30);  // Alice 的值从 10 -&gt; 30    // 4. 访问（用 get，返回 Option&lt;&amp;V&gt;）    if let Some(score) = scores.get(&quot;Alice&quot;) &#123;        println!(&quot;Alice 的分数是 &#123;&#125;&quot;, score);    &#125;    // 5. 删除（移除某个 key）    scores.remove(&quot;Bob&quot;);    println!(&quot;&#123;:?&#125;&quot;, scores);&#125;\n\n\n","categories":["rust逆向基础"],"tags":["rust"]},{"title":"安卓逆向环境配置","url":"/2025/10/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"前言：某些安卓题强制要求arm环境才能跑，模拟器不管是脱壳还是动调都有很多问题，最近搞了个真机重新配一遍安卓逆向环境\nroot手机","categories":["安卓逆向"],"tags":["安卓逆向"]},{"title":"异常处理机制-SEH","url":"/2025/10/09/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8A-SEH/","content":"SEH结构化异常处理（SEH）是 C 的Microsoft扩展，C++用于处理某些异常代码情况（如硬件故障）正常。 尽管 Windows 和 Microsoft C++支持 SEH，但我们建议在 C++ 代码中使用 ISO 标准C++异常处理。 它使代码更具可移植性和灵活性。 但是，若要维护现有代码或特定类型的程序，仍可能需要使用 SEH。\n异常出现流程：首先异常被交给内核态 &#x2F; 最底层**\n当 CPU 检测到一个错误（如无效内存访问），它会中断当前进程，并将控制权交给 Windows 内核。内核会为进程创建一个异常记录（EXCEPTION_RECORD），其中包含异常代码、地址等信息。然后内核会查看进程是否正在被调试。\n\n如果进程被调试：内核将异常事件发送给调试器（第一机会异常）。调试器可以决定处理这个异常（继续执行）或不处理。\n\n如果进程未被调试，或调试器不处理：内核开始在用户态中寻找能处理这个异常的函数。\n\n\n如果异常未能被处理，则在用户态等待被veh处理，若无veh，则交给seh\n如果链式seh，veh未能处理，\n\n当进程中发生异常时,此时会调用系统的kernel32!UnhandledExceptionFIlter()API。\n该API会运行系统的最后一个异常处理器——Top Level Exception Filter或Last Exception Filter（通常行为是弹出错误消息框、终止进程）。\nkernel32!UnhandledExceptionFilter()调用了ntdll!QueryInformationProcess(ProcessDebugPort)。来判断是否正在调试进程。如果正在进行调试，则将异常传递给调试器。否则系统异常处理器终止进程。\n\nSEH结构体typedef struct _EXCEPTION_REGISTRATION_RECORD&#123;    // 链表以Next成员为FFFFFFFF的结构体结束，表示链表的最后一个结点    PEXCEPTION_REGISTRATION_RECORD Next;    // Handler：异常处理函数    PEXCEPTION_DISPOSITION Handler;&#125; EX\n\n\n\nSEH语法try-except-statement ：  __try compound-statement __except ( filter-expression ) compound-statementtry-finally-statement ：  __try compound-statement __finally compound-statement\n\n正向实例：(a) __try &#x2F; __except - 异常处理程序#include &lt;windows.h&gt;#include &lt;excpt.h&gt;#include &lt;stdio.h&gt;int main() &#123;    __try &#123;        // 可能会引发异常的代码        int* p = NULL;        *p = 42; // 这将引发一个访问违规异常 (EXCEPTION_ACCESS_VIOLATION)    &#125;    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) &#123;        // 异常过滤器返回 EXCEPTION_EXECUTE_HANDLER 时，执行这个块        printf(&quot;Caught an access violation exception!\\n&quot;);        // 这里可以进行错误恢复、清理、记录日志等操作    &#125;    printf(&quot;Program continues after handling the exception.\\n&quot;);    return 0;&#125;\n\n\n__try 块：包含可能出错的代码。\n\n__except 块：异常处理程序。它是否能执行取决于其括号内的“异常过滤器表达式”。\n\n异常过滤器表达式：这是一个必须返回以下三个值之一的表达式：\n\nEXCEPTION_EXECUTE_HANDLER (1)： 执行处理程序。系统会展开堆栈（清理 __try 块中已构造的局部 C++ 对象可能会成为问题），然后跳转到 __except 块。\n\nEXCEPTION_CONTINUE_SEARCH (0)： 不处理。系统继续向上一个（外层）的异常处理程序寻找能处理的 __except 块。\n\nEXCEPTION_CONTINUE_EXECUTION (-1)： 继续执行。从异常发生处重新开始执行。极其危险！ 除非你能在过滤器里修复导致异常的问题（如虚拟内存分配），否则通常会立刻再次触发同一个异常，导致死循环。\n\n\n\n\n其中的GetExceptionCode()函数值包含EXCEPTION_ACCESS_VIOLATION, EXCEPTION_INT_DIVIDE_BY_ZERO, EXCEPTION_STACK_OVERFLOW等等，对应不同出错类型\n(b) __try &#x2F; __finally - 终止处理程序这种结构不处理异常，而是保证无论 __try 块是如何退出的（正常执行完毕、return、goto、break 或由于异常），__finally 块中的代码一定会被执行。用于实现资源清理（如关闭文件、释放锁）。\nHANDLE hFile = INVALID_HANDLE_VALUE;__try &#123;    hFile = CreateFileA(&quot;test.txt&quot;, ...);    if (hFile == INVALID_HANDLE_VALUE) &#123;        __leave; // 跳转到 __finally 块的另一种方式    &#125;    // 对文件进行一些操作，可能会引发异常    SomeRiskyOperation(hFile);&#125;__finally &#123;    // 无论上面如何退出，这里都会执行    if (hFile != INVALID_HANDLE_VALUE) &#123;        CloseHandle(hFile);        hFile = INVALID_HANDLE_VALUE;    &#125;&#125;// 执行完 __finally 后，异常（如果有）会继续向外传播\n\n\n\n\n\n逆向实战：注意：32位pe和64位peSEH使用方式不同，注意甄别\n1.32位例题：.text:00401140                 push    ebp.text:00401141                 mov     ebp, esp.text:00401143                 push    0FFFFFFFEh.text:00401145                 push    offset stru_403758.text:0040114A                 push    offset SEH_401140.text:0040114F                 mov     eax, large fs:0.text:00401155                 push    eax\n\n在使用SEH的函数汇编你会看到这样一段\n第一第二行是创建函数的基本操作，这里不多解释，第三行0xFFFFFFFE叫做Trylevel/enclosing&#96;&#96;\n-1 (0xFFFFFFFF) 表示：函数中没有任何 try&#x2F;except（即编译器没生成 ScopeTable）。\n-2 (0xFFFFFFFE) 表示：函数有 ScopeTable，但当前没有任何激活的 try 块。\n所以翻译过来就是目前这个seh只有一层(还没进入try)，具体进入try的部分见什么修改了Trylevel,如下最后是try结束\n.text:004011B3                 mov     [ebp+ms_exc.registration.TryLevel], 0 //try开始.text:004011BA                 mov     [ebp+var_38], 0.text:004011C1                 mov     eax, [ebp+var_1C].text:004011C4                 mov     edx, [ebp+var_24].text:004011C7                 mov     ecx, [ebp+var_20].text:004011CA                 mov     ebx, [ebp+arg_0].text:004011CD                 div     [ebp+var_38]    //明显除0异常.text:004011D0                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh //try结束\n\n第4行push offset stru_403758\n\n把指向 .rdata 中 scope table（你之前贴的 stru_403758） 的地址压栈。\n\n这个表包含了 filter&#x2F;handler 的地址、cookie 偏移等，运行时的异常处理器用它来决定哪个 try&#x2F;except（或 finally）块应该响应当前异常\n\n\n第5行push offset SEH_401140\n\n把一个“handler 地址”或“该函数专用的异常处理 stub”的地址压栈。IDA 给它取名为 SEH_401140（或许是个局部的 handler&#x2F;veneer）。\n\n当异常发生并且运行时走到这个注册记录时，系统会调用这个 handler（这个 handler 通常是编译器生成的代码 &#x2F; 运行时枢纽，它会读取 scope table，调用相应的 filter&#x2F;handler 函数\n\n\n第6行mov eax, large fs:0\n\n从 fs:[0] 读取当前线程的 SEH 链表头（在 x86 Windows 中，FS 段基址指向 TIB，TIB 的第一个 dword 就是 SEH 链表头）。large 是汇编器的语法，表示读取完整的 32 位值。\n\n把当前链表头（即“之前的注册记录”的指针）读出来保存到 EAX。\n\n\n第7行push eax\n\n把旧的 fs:[0]（即之前的链表头）压栈 —— 这就是新注册记录的 Next 字段（保存链表的前驱，以便函数退出时能恢复）。\n\n在压栈&#x2F;设置 fs:[0] 后，新的记录就会被插到链表最前面，变成当前活动的异常注册记录。\n\n\n退出函数时解除seh\nloc_401268:    mov     ecx, [ebp+ms_exc.registration.Next]    mov     large fs:0, ecx        ; 恢复 fs:[0] = 上一个 SEH 节点    pop     ecx    pop     edi    pop     esi    pop     ebx    mov     esp, ebp    pop     ebp    retn\n\n\n\n总结逆向流程：我们需要在stru_403758找到相应的过滤函数，和处理异常函数，该题中\n                stru_403758     dd 0FFFFFFFEh           ; GSCookieOffset.rdata:00403758                                         ; DATA XREF: sub_401140+5↑o.rdata:0040375C                 dd 0                    ; GSCookieXOROffset.rdata:00403760                 dd 0FFFFFFB0h           ; EHCookieOffset.rdata:00403764                 dd 0                    ; EHCookieXOROffset.rdata:00403768                 dd 0FFFFFFFEh           ; ScopeRecord.EnclosingLevel.rdata:0040376C                 dd offset loc_4011D9    ; ScopeRecord.FilterFunc.rdata:00403770                 dd offset loc_4011DF    ; ScopeRecord.HandlerFunc\n\n前3个没什么用，第四个是我们上面的Trylevel，第5个是过滤函数，第6个是我们的处理函数，也就是ctf中反调试替换掉的逻辑\n               loc_4011D9:                             ; DATA XREF: .rdata:stru_403758↓o.text:004011D9                 mov     eax, 1.text:004011DE                 retn.text:004011DF ; ---------------------------------------------------------------------------.text:004011DF.text:004011DF loc_4011DF:                             ; DATA XREF: .rdata:stru_403758↓o.text:004011DF                 mov     esp, [ebp+ms_exc.old_esp].text:004011E2                 mov     edi, [ebp+var_24].text:004011E5                 mov     ecx, edi.text:004011E7                 shr     ecx, 4.text:004011EA                 mov     eax, edi.text:004011EC                 shl     eax, 5.text:004011EF                 xor     ecx, eax.text:004011F1                 add     ecx, edi.text:004011F3                 mov     eax, [ebp+arg_0].text:004011F6                 mov     eax, [eax].text:004011F8                 add     eax, [ebp+var_20].text:004011FB                 xor     ecx, eax.text:004011FD                 xor     [ebp+var_1C], ecx.text:00401200                 push    offset Buffer   ; &quot;Something happend...&quot;.text:00401205                 call    ds:puts.text:0040120B                 add     esp, 4.text:0040120E                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh.text:00401215                 mov     esi, [ebp+var_28]\n\n这里过滤函数返回值保存在eax中，这里也就是返回了1，说明EXCEPTION_EXECUTE_HANDLER要处理这个异常，把原函数逻辑替换为下面的处理函数然后就可以接着进行逆向分析了，try中遇到error，那条出错指令汇编跳过，执行exception指令，然后执行try{}下面的语句。\n","categories":["pe逆向","反调试技术"],"tags":["反调试技术"]},{"title":"异常处理机制-VEH","url":"/2025/10/09/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8B-VEH/","content":"VEH这是 SEH 的一个增强扩展，通过 AddVectoredExceptionHandler 添加。VEH 处理器会在调试器和所有 SEH 处理器之前被调用。它们更像是一种“通知”机制，可以观察或拦截进程中的所有异常。\n与veh有关的函数\n\n\n函数名\n作用\n参数解释\n\n\n\nAddVectoredExceptionHandler\n注册一个新的向量化异常处理函数（VEH）。注册后，当线程出现异常（例如访问违规、除零、RaiseException）时，系统会回调你提供的函数。\nULONG FirstHandler：是否把此 handler 放在最前面。 1 → 高优先级（最先被调用） 0 → 低优先级（放在队列后面）PVECTORED_EXCEPTION_HANDLER VectoredHandler：回调函数地址，函数类型为 LONG CALLBACK handler(EXCEPTION_POINTERS* ExceptionInfo)。返回值控制异常是否继续传播。\n\n\nRemoveVectoredExceptionHandler\n移除已注册的 VEH。\nPVOID HandlerHandle：AddVectoredExceptionHandler 返回的句柄。\n\n\nRaiseException\n主动抛出一个软件异常，会触发 VEH。\nDWORD dwExceptionCode：异常码（自定义或系统定义）。DWORD dwExceptionFlags：是否可继续执行。0 表示可继续，EXCEPTION_NONCONTINUABLE 表示不可继续。DWORD nNumberOfArguments：额外参数个数。*const ULONG_PTR lpArguments：异常参数数组（可选）。\n\n\nEXCEPTION_POINTERS\nVEH 的回调参数结构，包含异常上下文。\n成员有两个：ExceptionRecord：描述异常的详细信息（代码、参数、地址等）。ContextRecord：保存异常发生时 CPU 的寄存器状态（Rip/Eip, Rsp/Esp, Rax, Rcx…）。可读写！修改后返回 EXCEPTION_CONTINUE_EXECUTION 可以改变执行流。\n\n\n正向实例：// veh_demo.cpp#include &lt;windows.h&gt;#include &lt;iostream&gt;using namespace std;// ======================= 1. 被“隐藏”的函数 =======================void SecretFunc()&#123;    cout &lt;&lt; &quot;[SecretFunc] VEH 修改 RIP 后跳转到这里执行！&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！&quot; &lt;&lt; endl;    ExitProcess(0);&#125;// ======================= 2. VEH 回调函数 =======================LONG CALLBACK MyVectoredHandler(EXCEPTION_POINTERS* ExceptionInfo)&#123;    cout &lt;&lt; &quot;[VEH] 异常捕获！&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;  ExceptionCode: 0x&quot; &lt;&lt; hex &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode &lt;&lt; endl;    cout &lt;&lt; &quot;  ExceptionAddress: &quot; &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress &lt;&lt; endl;    // 判断是不是我们自己触发的异常（0xDEADC0DE）    if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == 0xDEADC0DE)    &#123;        cout &lt;&lt; &quot;[VEH] 捕获到自定义异常，修改上下文...&quot; &lt;&lt; endl;#ifdef _M_X64        ExceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)&amp;SecretFunc; // x64#else        ExceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;SecretFunc;   // x86#endif        // 返回 EXCEPTION_CONTINUE_EXECUTION，让程序从修改后的地址继续执行        return EXCEPTION_CONTINUE_EXECUTION;    &#125;    // 其他异常交给系统处理    return EXCEPTION_CONTINUE_SEARCH;&#125;// ======================= 3. 主函数 =======================int main()&#123;    cout &lt;&lt; &quot;[Main] 注册 VEH...&quot; &lt;&lt; endl;    // 注册 VEH，优先级高    PVOID hHandler = AddVectoredExceptionHandler(1, MyVectoredHandler);    if (!hHandler)    &#123;        cerr &lt;&lt; &quot;AddVectoredExceptionHandler failed! error=&quot; &lt;&lt; GetLastError() &lt;&lt; endl;        return 1;    &#125;    cout &lt;&lt; &quot;[Main] 准备触发自定义异常...&quot; &lt;&lt; endl;    // 手动触发异常    RaiseException(0xDEADC0DE, 0, 0, nullptr);    cout &lt;&lt; &quot;[Main] 如果看到这行，说明 VEH 没有拦截执行流。&quot; &lt;&lt; endl;    // 移除 VEH    RemoveVectoredExceptionHandler(hHandler);    return 0;&#125;\n\n输出：\n[Main] 注册 VEH...[Main] 准备触发自定义异常...[VEH] 异常捕获！  ExceptionCode: 0xdeadc0de  ExceptionAddress: 00007FF6F8B21000[VEH] 捕获到自定义异常，修改上下文...[SecretFunc] VEH 修改 RIP 后跳转到这里执行！[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！\n\n总结：\n\n\n函数\n用途\n常用返回\n\n\n\nAddVectoredExceptionHandler\n注册 VEH\n返回 handler 句柄\n\n\nRemoveVectoredExceptionHandler\n移除 VEH\n成功返回非 0\n\n\nRaiseException\n主动抛出异常\n会调用 VEH\n\n\nMyVectoredHandler\n回调处理异常\n返回 CONTINUE_EXECUTION 或 CONTINUE_SEARCH\n\n\nExceptionInfo-&gt;ContextRecord\n保存寄存器上下文\n可修改以改变执行流\n\n\n","categories":["pe逆向","反调试技术"],"tags":["反调试技术"]}]