<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>s0m1ng</title>
  
  <subtitle>二进制学习中</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-10-10T15:38:57.914Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>s0m1ng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向中的AES(一)</title>
    <link href="http://example.com/2025/10/09/aes/"/>
    <id>http://example.com/2025/10/09/aes/</id>
    <published>2025-10-08T16:00:00.000Z</published>
    <updated>2025-10-10T15:38:57.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>aes在逆向有很多应用，尤其是现在越来越多软件加密逻辑都选择aes，所以总结一下aes的算法和在ctf逆向中的考点</p><h1 id="aes算法基础"><a href="#aes算法基础" class="headerlink" title="aes算法基础"></a>aes算法基础</h1><p><img data-src="D:\ctf\s0m1ng\source\images\aes\aes结构.png" alt="aes结构"></p><p>aes最重要的一个特征就是输入是128位分组，输出也是128位分组，但其中key分128位，192位，256位三种版本</p><table><thead><tr><th>AES 类型</th><th>密钥长度</th><th>轮数 (Nr)</th><th>密钥字数 (Nk)</th></tr></thead><tbody><tr><td>AES-128</td><td>128 位</td><td>10</td><td>4</td></tr><tr><td>AES-192</td><td>192 位</td><td>12</td><td>6</td></tr><tr><td>AES-256</td><td>256 位</td><td>14</td><td>8</td></tr></tbody></table><p>aes分组后16个字节是按矩阵方式排列</p><p><img data-src="D:\ctf\s0m1ng\source\images\aes\aes字节约定.png" alt="aes字节约定"></p><h1 id="加密总流程："><a href="#加密总流程：" class="headerlink" title="加密总流程："></a>加密总流程：</h1><p><img data-src="D:\ctf\s0m1ng\source\images\aes\总结构.png" alt="总结构"></p><p>最终轮和前面9轮的区别是没有第三个步骤列混合</p><h2 id="初始变换-Initial-round"><a href="#初始变换-Initial-round" class="headerlink" title="初始变换(Initial round)"></a>初始变换(Initial round)</h2><p>初始变换就是输入的16个字节和密钥(不确定几位)进行密钥扩展后生成的$\text{RoundKey}_0$(16位)异或的结果</p><p>$$<br>\text{State}’ &#x3D; \text{State} \oplus \text{RoundKey}_0<br>$$</p><p>展开为矩阵形式：</p><p>$$<br>\begin{bmatrix}<br>s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \<br>s_{1,0} &amp; s_{1,1} &amp; s_{1,2} &amp; s_{1,3} \<br>s_{2,0} &amp; s_{2,1} &amp; s_{2,2} &amp; s_{2,3} \<br>s_{3,0} &amp; s_{3,1} &amp; s_{3,2} &amp; s_{3,3}<br>\end{bmatrix}<br>;\oplus;<br>\begin{bmatrix}<br>k_{0,0} &amp; k_{0,1} &amp; k_{0,2} &amp; k_{0,3} \<br>k_{1,0} &amp; k_{1,1} &amp; k_{1,2} &amp; k_{1,3} \<br>k_{2,0} &amp; k_{2,1} &amp; k_{2,2} &amp; k_{2,3} \<br>k_{3,0} &amp; k_{3,1} &amp; k_{3,2} &amp; k_{3,3}<br>\end{bmatrix}<br>;&#x3D;;<br>\begin{bmatrix}<br>s’<em>{0,0} &amp; s’</em>{0,1} &amp; s’<em>{0,2} &amp; s’</em>{0,3} \<br>s’<em>{1,0} &amp; s’</em>{1,1} &amp; s’<em>{1,2} &amp; s’</em>{1,3} \<br>s’<em>{2,0} &amp; s’</em>{2,1} &amp; s’<em>{2,2} &amp; s’</em>{2,3} \<br>s’<em>{3,0} &amp; s’</em>{3,1} &amp; s’<em>{3,2} &amp; s’</em>{3,3}<br>\end{bmatrix}<br>$$</p><p>其中：</p><ul><li>$s_{i,j}$ 为明文状态矩阵中第 $(i,j)$ 个字节  </li><li>$k_{i,j}$ 为轮密钥矩阵中第 $(i,j)$ 个字节  </li><li>$\oplus$ 表示按字节异或（XOR）运算</li></ul><h2 id="循环运算："><a href="#循环运算：" class="headerlink" title="循环运算："></a>循环运算：</h2><h3 id="字节代换："><a href="#字节代换：" class="headerlink" title="字节代换："></a>字节代换：</h3><p><img data-src="D:\ctf\s0m1ng\source\images\aes\字节代换.png" alt="字节代换"></p><p>字节代换就是把第一步初始变换后的16字节矩阵块用s表代换，例如矩阵左上角的数是十六进制19，那就要代换成s盒中第1行第9列，查表可知是d4，以此类推</p><p>结果：</p><p><img data-src="D:\ctf\s0m1ng\source\images\aes\字节代换结果.png" alt="字节代换结果"></p><h3 id="行移位："><a href="#行移位：" class="headerlink" title="行移位："></a>行移位：</h3><p>ShiftRows 操作在状态矩阵上进行，规则如下：</p><ul><li>第 0 行不变</li><li>第 1 行循环左移 1 字节</li><li>第 2 行循环左移 2 字节</li><li>第 3 行循环左移 3 字节</li></ul><p>原始状态矩阵：</p><p>$$<br>\text{State} &#x3D;<br>\begin{bmatrix}<br>s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \<br>s_{1,0} &amp; s_{1,1} &amp; s_{1,2} &amp; s_{1,3} \<br>s_{2,0} &amp; s_{2,1} &amp; s_{2,2} &amp; s_{2,3} \<br>s_{3,0} &amp; s_{3,1} &amp; s_{3,2} &amp; s_{3,3}<br>\end{bmatrix}<br>$$</p><p>经过行移位后：</p><p>$$<br>\text{State}’ &#x3D;<br>\begin{bmatrix}<br>s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \<br>s_{1,1} &amp; s_{1,2} &amp; s_{1,3} &amp; s_{1,0} \<br>s_{2,2} &amp; s_{2,3} &amp; s_{2,0} &amp; s_{2,1} \<br>s_{3,3} &amp; s_{3,0} &amp; s_{3,1} &amp; s_{3,2}<br>\end{bmatrix}<br>$$</p><p>每一行的移位规律如下：</p><table><thead><tr><th align="center">行号</th><th align="center">移位字节数</th><th align="center">移位方向</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">不变</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">左移</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">左移</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">左移</td></tr></tbody></table><h3 id="列混淆："><a href="#列混淆：" class="headerlink" title="列混淆："></a>列混淆：</h3><p><img data-src="D:\ctf\s0m1ng\source\images\aes\列混淆.png" alt="列混淆"></p><p>左乘一个确定的矩阵，但是这里的乘法不是普通乘法</p><h4 id="列混淆中的乘法"><a href="#列混淆中的乘法" class="headerlink" title="列混淆中的乘法"></a>列混淆中的乘法</h4><p>$$<br>\begin{aligned}<br>s’<em>{0,c} &amp;&#x3D; (02 \cdot s</em>{0,c}) \oplus (03 \cdot s_{1,c}) \oplus s_{2,c} \oplus s_{3,c} \<br>s’<em>{1,c} &amp;&#x3D; s</em>{0,c} \oplus (02 \cdot s_{1,c}) \oplus (03 \cdot s_{2,c}) \oplus s_{3,c} \<br>s’<em>{2,c} &amp;&#x3D; s</em>{0,c} \oplus s_{1,c} \oplus (02 \cdot s_{2,c}) \oplus (03 \cdot s_{3,c}) \<br>s’<em>{3,c} &amp;&#x3D; (03 \cdot s</em>{0,c}) \oplus s_{1,c} \oplus s_{2,c} \oplus (02 \cdot s_{3,c})<br>\end{aligned}<br>$$</p><p>其中乘法在有限域 $GF(2^8)$ 上进行：</p><ul><li>$02 \cdot x$ 表示按字节左移一位（若最高位为 1，则再与 <code>0x1B</code> 异或）  </li><li>$03 \cdot x &#x3D; (02 \cdot x) \oplus x$</li></ul><p>注：与0x1B异或是因为要构造有限域$GF(2^8)$构造出来的多项式把$x^8$模之后的结果，学逆向不用学那么深，只需要知道aes的加密解密和漏洞攻击就可以了</p><h3 id="轮密钥加："><a href="#轮密钥加：" class="headerlink" title="轮密钥加："></a>轮密钥加：</h3><p>AddRoundKey 是 AES 每一轮中最简单但最关键的操作之一。<br>它将 <strong>状态矩阵 (State)</strong> 与 <strong>轮密钥矩阵 (RoundKey)</strong> 按字节异或（XOR）：</p><p>$$<br>\text{State}’ &#x3D; \text{State} \oplus \text{RoundKey}_i<br>$$</p><p>设状态矩阵为：</p><p>$$<br>\text{State} &#x3D;<br>\begin{bmatrix}<br>s_{0,0} &amp; s_{0,1} &amp; s_{0,2} &amp; s_{0,3} \<br>s_{1,0} &amp; s_{1,1} &amp; s_{1,2} &amp; s_{1,3} \<br>s_{2,0} &amp; s_{2,1} &amp; s_{2,2} &amp; s_{2,3} \<br>s_{3,0} &amp; s_{3,1} &amp; s_{3,2} &amp; s_{3,3}<br>\end{bmatrix}<br>$$</p><p>轮密钥矩阵为：</p><p>$$<br>\text{RoundKey}<em>i &#x3D;<br>\begin{bmatrix}<br>k</em>{0,0} &amp; k_{0,1} &amp; k_{0,2} &amp; k_{0,3} \<br>k_{1,0} &amp; k_{1,1} &amp; k_{1,2} &amp; k_{1,3} \<br>k_{2,0} &amp; k_{2,1} &amp; k_{2,2} &amp; k_{2,3} \<br>k_{3,0} &amp; k_{3,1} &amp; k_{3,2} &amp; k_{3,3}<br>\end{bmatrix}<br>$$</p><p>异或后得到：</p><p>$$<br>\text{State}’ &#x3D;<br>\begin{bmatrix}<br>s_{0,0} \oplus k_{0,0} &amp; s_{0,1} \oplus k_{0,1} &amp; s_{0,2} \oplus k_{0,2} &amp; s_{0,3} \oplus k_{0,3} \<br>s_{1,0} \oplus k_{1,0} &amp; s_{1,1} \oplus k_{1,1} &amp; s_{1,2} \oplus k_{1,2} &amp; s_{1,3} \oplus k_{1,3} \<br>s_{2,0} \oplus k_{2,0} &amp; s_{2,1} \oplus k_{2,1} &amp; s_{2,2} \oplus k_{2,2} &amp; s_{2,3} \oplus k_{2,3} \<br>s_{3,0} \oplus k_{3,0} &amp; s_{3,1} \oplus k_{3,1} &amp; s_{3,2} \oplus k_{3,2} &amp; s_{3,3} \oplus k_{3,3}<br>\end{bmatrix}<br>$$</p><h3 id="按字节运算公式"><a href="#按字节运算公式" class="headerlink" title="按字节运算公式"></a>按字节运算公式</h3><p>每个字节的计算方式为：</p><p>$$<br>s’<em>{i,j} &#x3D; s</em>{i,j} \oplus k_{i,j}, \quad 0 \le i,j \le 3<br>$$</p><h2 id="密钥扩展："><a href="#密钥扩展：" class="headerlink" title="密钥扩展："></a>密钥扩展：</h2><p>初始只有128&#x2F;192&#x2F;256位的密钥是怎么更新的呢，这就涉及到密钥扩展</p><p>这是初始状态，这里以128位密钥为例，先全部填入前4列，设第5列为Wi</p><p><img data-src="D:\ctf\s0m1ng\source\images\aes\密钥扩展初始.png" alt="密钥扩展初始"></p><ol><li><strong>初始部分：</strong></li></ol><p>$$<br>W[i] &#x3D; \text{原始密钥的第 } i \text{ 个 32 位字}, \quad 0 \le i &lt; N_k<br>$$</p><ol start="2"><li><strong>递推部分：（适用于所有aes算法）</strong></li></ol><p>对于 $i \ge N_k$：</p><p>$$<br>W[i] &#x3D;<br>\begin{cases}<br>W[i - N_k] \oplus \text{SubWord}(\text{RotWord}(W[i - 1])) \oplus \text{Rcon}[i&#x2F;N_k], &amp; \text{if } i \bmod N_k &#x3D; 0 \<br>W[i - N_k] \oplus \text{SubWord}(W[i - 1]), &amp; \text{if } N_k &gt; 6 \text{ and } i \bmod N_k &#x3D; 4  (只有aes256有这条)\<br>W[i - N_k] \oplus W[i - 1], &amp; \text{otherwise}<br>\end{cases}<br>$$</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p><strong>RotWord：</strong><br>循环左移 1 字节  </p><p>$$<br>[a_0, a_1, a_2, a_3] \Rightarrow [a_1, a_2, a_3, a_0]<br>$$</p><p><img data-src="D:\ctf\s0m1ng\source\images\aes\字循环.png" alt="字循环"></p><p><strong>SubWord：</strong><br>对 4 个字节分别进行 S-box 替代  </p><p>$$<br>[a_0, a_1, a_2, a_3] \Rightarrow [S(a_0), S(a_1), S(a_2), S(a_3)]<br>$$</p><p><strong>Rcon：</strong><br>轮常数，仅作用于字的第一个字节：</p><p>$$<br>\text{Rcon}[i] &#x3D;<br>\begin{bmatrix}<br>\text{RC}[i] &amp; 00 &amp; 00 &amp; 00<br>\end{bmatrix}<br>$$</p><p>其中<br>$\text{RC}[1] &#x3D; 0x01$，<br>$\text{RC}[2] &#x3D; 0x02$，<br>$\text{RC}[3] &#x3D; 0x04$，<br>$\text{RC}[4] &#x3D; 0x08$，<br>$\text{RC}[5] &#x3D; 0x10$，<br>$\text{RC}[6] &#x3D; 0x20$，<br>$\text{RC}[7] &#x3D; 0x40$，<br>$\text{RC}[8] &#x3D; 0x80$，<br>$\text{RC}[9] &#x3D; 0x1B$，<br>$\text{RC}[10] &#x3D; 0x36$</p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p><img data-src="D:\ctf\s0m1ng\source\images\aes\密钥最终结果.png" alt="密钥最终结果"></p><h1 id="解密方式"><a href="#解密方式" class="headerlink" title="解密方式"></a>解密方式</h1><p>就是把上述过程反过来一遍（解密的第一轮没有列混合逆向）</p><p><img data-src="D:\ctf\s0m1ng\source\images\aes\加解密.png" alt="加解密"></p><p>其中的轮密钥加只需要每轮相同状态的W[i,i+3]就可以</p><h2 id="逆列混淆"><a href="#逆列混淆" class="headerlink" title="逆列混淆"></a>逆列混淆</h2><p><img data-src="D:\ctf\s0m1ng\source\images\aes\逆列混淆.png" alt="逆列混淆"></p><h2 id="逆行移位："><a href="#逆行移位：" class="headerlink" title="逆行移位："></a>逆行移位：</h2><p>就是逆向移位就可以，很简单</p><h2 id="逆s表"><a href="#逆s表" class="headerlink" title="逆s表"></a>逆s表</h2><p><img data-src="D:\ctf\s0m1ng\source\images\aes\逆s表.png" alt="逆s表"></p><p>查表即可</p><h1 id="逆向题型："><a href="#逆向题型：" class="headerlink" title="逆向题型："></a>逆向题型：</h1><h2 id="普通AES"><a href="#普通AES" class="headerlink" title="普通AES"></a>普通AES</h2><p>找到密钥，找到密文，逆向脚本，进行解密。</p><h2 id="白盒AES"><a href="#白盒AES" class="headerlink" title="白盒AES"></a>白盒AES</h2><table><thead><tr><th>项目</th><th>普通 AES（黑盒）</th><th>白盒 AES</th></tr></thead><tbody><tr><td>密钥</td><td>独立变量、明确定义</td><td>被混入查表中，不可直接访问</td></tr><tr><td>算法结构</td><td>明确的五步（SubBytes 等）</td><td>各步骤混淆成查表和线性映射</td></tr><tr><td>可移植性</td><td>高（用同样的密钥随处运行）</td><td>低（查表与密钥绑定）</td></tr><tr><td>安全假设</td><td>攻击者看不到内部</td><td>攻击者能看到全部</td></tr></tbody></table><p> 目前市面上大多数app都是基于白盒aes开发的，还有查表法实现的aes真的严格按照上面讲的aes流程走的很少，白盒aes东西太多了，而且还有很多攻击手法，就放在”逆向中的AES(二)“里讲好了</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://www.bilibili.com/video/BV1i341187fK/?spm_id_from=333.337.search-card.all.click">【AES加密算法】| AES加密过程详解| 对称加密| Rijndael-128| 密码学| 信息安全_哔哩哔哩_bilibili</a></p><p><a href="https://goodapple.top/archives/162">密码学——AES&#x2F;DES加密算法原理介绍 - 枫のBlog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;aes在逆向有很多应用，尤其是现在越来越多软件加密逻辑都选择aes，所以总结一下aes的算法和在ctf逆向中的考点&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="逆向中的密码学" scheme="http://example.com/categories/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="对称加密题单" scheme="http://example.com/categories/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E9%A2%98%E5%8D%95/"/>
    
    
    <category term="aes" scheme="http://example.com/tags/aes/"/>
    
  </entry>
  
  <entry>
    <title>异常处理机制-SEH</title>
    <link href="http://example.com/2025/10/09/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8A-SEH/"/>
    <id>http://example.com/2025/10/09/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8A-SEH/</id>
    <published>2025-10-08T16:00:00.000Z</published>
    <updated>2025-10-09T04:11:29.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><p>结构化异常处理（SEH）是 C 的Microsoft扩展，C++用于处理某些异常代码情况（如硬件故障）正常。 尽管 Windows 和 Microsoft C++支持 SEH，但我们建议在 C++ 代码中使用 ISO 标准C++异常处理。 它使代码更具可移植性和灵活性。 但是，若要维护现有代码或特定类型的程序，仍可能需要使用 SEH。</p><h2 id="异常出现流程："><a href="#异常出现流程：" class="headerlink" title="异常出现流程："></a>异常出现流程：</h2><p><strong>首先异常被交给内核态 &#x2F; 最底层</strong>**</p><p>当 CPU 检测到一个错误（如无效内存访问），它会中断当前进程，并将控制权交给 Windows 内核。内核会为进程创建一个<strong>异常记录</strong>（<code>EXCEPTION_RECORD</code>），其中包含异常代码、地址等信息。然后内核会查看进程是否正在被调试。</p><ul><li><p><strong>如果进程被调试</strong>：内核将异常事件发送给调试器（<strong>第一机会异常</strong>）。调试器可以决定处理这个异常（继续执行）或不处理。</p></li><li><p><strong>如果进程未被调试，或调试器不处理</strong>：内核开始在用户态中寻找能处理这个异常的函数。</p></li></ul><p><strong>如果异常未能被处理，则在用户态等待被veh处理，若无veh，则交给seh</strong></p><p><strong>如果链式seh，veh未能处理</strong>，</p><ul><li>当进程中发生异常时,此时会调用系统的<code>kernel32!UnhandledExceptionFIlter()</code>API。</li><li>该API会运行系统的最后一个异常处理器——<strong>Top Level Exception Filter</strong>或<strong>Last Exception Filter</strong>（通常行为是弹出错误消息框、终止进程）。</li><li><code>kernel32!UnhandledExceptionFilter()</code>调用了<code>ntdll!QueryInformationProcess(ProcessDebugPort)</code>。来判断是否正在调试进程。如果正在进行调试，则将异常传递给调试器。否则系统异常处理器终止进程。</li></ul><h1 id="SEH结构体"><a href="#SEH结构体" class="headerlink" title="SEH结构体"></a>SEH结构体</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 链表以Next成员为FFFFFFFF的结构体结束，表示链表的最后一个结点</span></span><br><span class="line">    PEXCEPTION_REGISTRATION_RECORD Next;</span><br><span class="line">    <span class="comment">// Handler：异常处理函数</span></span><br><span class="line">    PEXCEPTION_DISPOSITION Handler;</span><br><span class="line">&#125; EX</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SEH语法"><a href="#SEH语法" class="headerlink" title="SEH语法"></a>SEH语法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try-except-statement ：</span><br><span class="line">  __try compound-statement __except ( filter-expression ) compound-statement</span><br><span class="line"></span><br><span class="line">try-finally-statement ：</span><br><span class="line">  __try compound-statement __finally compound-statement</span><br></pre></td></tr></table></figure><h1 id="正向实例："><a href="#正向实例：" class="headerlink" title="正向实例："></a>正向实例：</h1><h2 id="a-try-except-异常处理程序"><a href="#a-try-except-异常处理程序" class="headerlink" title="(a) __try &#x2F; __except - 异常处理程序"></a>(a) <code>__try</code> &#x2F; <code>__except</code> - 异常处理程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;excpt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// 可能会引发异常的代码</span></span><br><span class="line">        <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">        *p = <span class="number">42</span>; <span class="comment">// 这将引发一个访问违规异常 (EXCEPTION_ACCESS_VIOLATION)</span></span><br><span class="line">    &#125;</span><br><span class="line">    __except(<span class="built_in">GetExceptionCode</span>() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) &#123;</span><br><span class="line">        <span class="comment">// 异常过滤器返回 EXCEPTION_EXECUTE_HANDLER 时，执行这个块</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught an access violation exception!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里可以进行错误恢复、清理、记录日志等操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program continues after handling the exception.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>__try</code> 块</strong>：包含可能出错的代码。</p></li><li><p><strong><code>__except</code> 块</strong>：异常处理程序。<strong>它是否能执行取决于其括号内的“异常过滤器表达式”</strong>。</p></li><li><p><strong>异常过滤器表达式</strong>：这是一个必须返回以下三个值之一的表达式：</p><ul><li><p><code>EXCEPTION_EXECUTE_HANDLER</code> (1)： <strong>执行处理程序</strong>。系统会展开堆栈（清理 <code>__try</code> 块中已构造的局部 C++ 对象可能会成为问题），然后跳转到 <code>__except</code> 块。</p></li><li><p><code>EXCEPTION_CONTINUE_SEARCH</code> (0)： <strong>不处理</strong>。系统继续向上一个（外层）的异常处理程序寻找能处理的 <code>__except</code> 块。</p></li><li><p><code>EXCEPTION_CONTINUE_EXECUTION</code> (-1)： <strong>继续执行</strong>。从异常发生处重新开始执行。<strong>极其危险！</strong> 除非你能在过滤器里修复导致异常的问题（如虚拟内存分配），否则通常会立刻再次触发同一个异常，导致死循环。</p></li></ul></li></ul><p>其中的GetExceptionCode()函数值包含<code>EXCEPTION_ACCESS_VIOLATION</code>, <code>EXCEPTION_INT_DIVIDE_BY_ZERO</code>, <code>EXCEPTION_STACK_OVERFLOW</code>等等，对应不同出错类型</p><h2 id="b-try-finally-终止处理程序"><a href="#b-try-finally-终止处理程序" class="headerlink" title="(b) __try &#x2F; __finally - 终止处理程序"></a>(b) <code>__try</code> &#x2F; <code>__finally</code> - 终止处理程序</h2><p>这种结构<strong>不处理异常</strong>，而是保证无论 <code>__try</code> 块是如何退出的（正常执行完毕、<code>return</code>、<code>goto</code>、<code>break</code> 或由于异常），<code>__finally</code> 块中的代码<strong>一定会被执行</strong>。用于实现资源清理（如关闭文件、释放锁）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line">    hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;test.txt&quot;</span>, ...);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        __leave; <span class="comment">// 跳转到 __finally 块的另一种方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对文件进行一些操作，可能会引发异常</span></span><br><span class="line">    <span class="built_in">SomeRiskyOperation</span>(hFile);</span><br><span class="line">&#125;</span><br><span class="line">__finally &#123;</span><br><span class="line">    <span class="comment">// 无论上面如何退出，这里都会执行</span></span><br><span class="line">    <span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        hFile = INVALID_HANDLE_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行完 __finally 后，异常（如果有）会继续向外传播</span></span><br></pre></td></tr></table></figure><h1 id="逆向实战："><a href="#逆向实战：" class="headerlink" title="逆向实战："></a>逆向实战：</h1><p>注意：32位pe和64位peSEH使用方式不同，注意甄别</p><h2 id="1-32位例题："><a href="#1-32位例题：" class="headerlink" title="1.32位例题："></a>1.32位例题：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00401140                 push    ebp</span><br><span class="line">.text:00401141                 mov     ebp, esp</span><br><span class="line">.text:00401143                 push    0FFFFFFFEh</span><br><span class="line">.text:00401145                 push    offset stru_403758</span><br><span class="line">.text:0040114A                 push    offset SEH_401140</span><br><span class="line">.text:0040114F                 mov     eax, large fs:0</span><br><span class="line">.text:00401155                 push    eax</span><br></pre></td></tr></table></figure><p>在使用SEH的函数汇编你会看到这样一段</p><p>第一第二行是创建函数的基本操作，这里不多解释，第三行0xFFFFFFFE叫做<code>Trylevel/</code>enclosing&#96;&#96;</p><p><code>-1</code> (<code>0xFFFFFFFF</code>) 表示：函数中没有任何 try&#x2F;except（即编译器没生成 ScopeTable）。</p><p><code>-2</code> (<code>0xFFFFFFFE</code>) 表示：函数有 ScopeTable，但<strong>当前没有任何激活的 try 块</strong>。</p><p>所以翻译过来就是目前这个seh只有一层(还没进入try)，具体进入try的部分见什么修改了Trylevel,如下最后是try结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:004011B3                 mov     [ebp+ms_exc.registration.TryLevel], 0 //try开始</span><br><span class="line">.text:004011BA                 mov     [ebp+var_38], 0</span><br><span class="line">.text:004011C1                 mov     eax, [ebp+var_1C]</span><br><span class="line">.text:004011C4                 mov     edx, [ebp+var_24]</span><br><span class="line">.text:004011C7                 mov     ecx, [ebp+var_20]</span><br><span class="line">.text:004011CA                 mov     ebx, [ebp+arg_0]</span><br><span class="line">.text:004011CD                 div     [ebp+var_38]    //明显除0异常</span><br><span class="line">.text:004011D0                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh //try结束</span><br></pre></td></tr></table></figure><p>第4行<code>push offset stru_403758</code></p><ul><li><p>把指向 <code>.rdata</code> 中 scope table（你之前贴的 <code>stru_403758</code>） 的地址压栈。</p></li><li><p>这个表包含了 filter&#x2F;handler 的地址、cookie 偏移等，运行时的异常处理器用它来决定<strong>哪个 try&#x2F;except（或 finally）块应该响应当前异常</strong></p></li></ul><p>第5行<code>push offset SEH_401140</code></p><ul><li><p>把一个“handler 地址”或“该函数专用的异常处理 stub”的地址压栈。IDA 给它取名为 <code>SEH_401140</code>（或许是个局部的 handler&#x2F;veneer）。</p></li><li><p>当异常发生并且运行时走到这个注册记录时，系统会调用这个 handler（这个 handler 通常是编译器生成的代码 &#x2F; 运行时枢纽，它会读取 scope table，调用相应的 filter&#x2F;handler 函数</p></li></ul><p>第6行<code>mov eax, large fs:0</code></p><ul><li><p>从 <code>fs:[0]</code> 读取当前线程的 SEH 链表头（在 x86 Windows 中，FS 段基址指向 TIB，TIB 的第一个 dword 就是 SEH 链表头）。<code>large</code> 是汇编器的语法，表示读取完整的 32 位值。</p></li><li><p>把当前链表头（即“之前的注册记录”的指针）读出来保存到 EAX。</p></li></ul><p>第7行<code>push eax</code></p><ul><li><p>把旧的 <code>fs:[0]</code>（即之前的链表头）压栈 —— 这就是新注册记录的 <code>Next</code> 字段（保存链表的前驱，以便函数退出时能恢复）。</p></li><li><p>在压栈&#x2F;设置 <code>fs:[0]</code> 后，新的记录就会被插到链表最前面，变成当前活动的异常注册记录。</p></li></ul><p>退出函数时解除seh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loc_401268:</span><br><span class="line">    mov     ecx, [ebp+ms_exc.registration.Next]</span><br><span class="line">    mov     large fs:0, ecx        ; 恢复 fs:[0] = 上一个 SEH 节点</span><br><span class="line">    pop     ecx</span><br><span class="line">    pop     edi</span><br><span class="line">    pop     esi</span><br><span class="line">    pop     ebx</span><br><span class="line">    mov     esp, ebp</span><br><span class="line">    pop     ebp</span><br><span class="line">    retn</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结逆向流程："><a href="#总结逆向流程：" class="headerlink" title="总结逆向流程："></a>总结逆向流程：</h1><p>我们需要在stru_403758找到相应的过滤函数，和处理异常函数，该题中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                stru_403758     dd 0FFFFFFFEh           ; GSCookieOffset</span><br><span class="line">.rdata:00403758                                         ; DATA XREF: sub_401140+5↑o</span><br><span class="line">.rdata:0040375C                 dd 0                    ; GSCookieXOROffset</span><br><span class="line">.rdata:00403760                 dd 0FFFFFFB0h           ; EHCookieOffset</span><br><span class="line">.rdata:00403764                 dd 0                    ; EHCookieXOROffset</span><br><span class="line">.rdata:00403768                 dd 0FFFFFFFEh           ; ScopeRecord.EnclosingLevel</span><br><span class="line">.rdata:0040376C                 dd offset loc_4011D9    ; ScopeRecord.FilterFunc</span><br><span class="line">.rdata:00403770                 dd offset loc_4011DF    ; ScopeRecord.HandlerFunc</span><br></pre></td></tr></table></figure><p>前3个没什么用，第四个是我们上面的Trylevel，第5个是过滤函数，第6个是我们的处理函数，也就是ctf中反调试替换掉的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">               loc_4011D9:                             ; DATA XREF: .rdata:stru_403758↓o</span><br><span class="line">.text:004011D9                 mov     eax, 1</span><br><span class="line">.text:004011DE                 retn</span><br><span class="line">.text:004011DF ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004011DF</span><br><span class="line">.text:004011DF loc_4011DF:                             ; DATA XREF: .rdata:stru_403758↓o</span><br><span class="line">.text:004011DF                 mov     esp, [ebp+ms_exc.old_esp]</span><br><span class="line">.text:004011E2                 mov     edi, [ebp+var_24]</span><br><span class="line">.text:004011E5                 mov     ecx, edi</span><br><span class="line">.text:004011E7                 shr     ecx, 4</span><br><span class="line">.text:004011EA                 mov     eax, edi</span><br><span class="line">.text:004011EC                 shl     eax, 5</span><br><span class="line">.text:004011EF                 xor     ecx, eax</span><br><span class="line">.text:004011F1                 add     ecx, edi</span><br><span class="line">.text:004011F3                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:004011F6                 mov     eax, [eax]</span><br><span class="line">.text:004011F8                 add     eax, [ebp+var_20]</span><br><span class="line">.text:004011FB                 xor     ecx, eax</span><br><span class="line">.text:004011FD                 xor     [ebp+var_1C], ecx</span><br><span class="line">.text:00401200                 push    offset Buffer   ; &quot;Something happend...&quot;</span><br><span class="line">.text:00401205                 call    ds:puts</span><br><span class="line">.text:0040120B                 add     esp, 4</span><br><span class="line">.text:0040120E                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh</span><br><span class="line">.text:00401215                 mov     esi, [ebp+var_28]</span><br></pre></td></tr></table></figure><p>这里过滤函数返回值保存在eax中，这里也就是返回了1，说明EXCEPTION_EXECUTE_HANDLER要处理这个异常，把原函数逻辑替换为下面的处理函数然后就可以接着进行逆向分析了，try中遇到error，那条出错指令汇编跳过，执行exception指令，然后执行try{}下面的语句。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SEH&quot;&gt;&lt;a href=&quot;#SEH&quot; class=&quot;headerlink&quot; title=&quot;SEH&quot;&gt;&lt;/a&gt;SEH&lt;/h1&gt;&lt;p&gt;结构化异常处理（SEH）是 C 的Microsoft扩展，C++用于处理某些异常代码情况（如硬件故障）正常。 尽管 Windows </summary>
      
    
    
    
    <category term="pe逆向" scheme="http://example.com/categories/pe%E9%80%86%E5%90%91/"/>
    
    <category term="反调试技术" scheme="http://example.com/categories/pe%E9%80%86%E5%90%91/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="反调试技术" scheme="http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>异常处理机制-VEH</title>
    <link href="http://example.com/2025/10/09/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8B-VEH/"/>
    <id>http://example.com/2025/10/09/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8B-VEH/</id>
    <published>2025-10-08T16:00:00.000Z</published>
    <updated>2025-10-09T04:24:47.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VEH"><a href="#VEH" class="headerlink" title="VEH"></a>VEH</h1><p>这是 SEH 的一个增强扩展，通过 <code>AddVectoredExceptionHandler</code> 添加。VEH 处理器会在调试器和所有 SEH 处理器<strong>之前</strong>被调用。它们更像是一种“通知”机制，可以观察或拦截进程中的所有异常。</p><h1 id="与veh有关的函数"><a href="#与veh有关的函数" class="headerlink" title="与veh有关的函数"></a>与veh有关的函数</h1><table><thead><tr><th>函数名</th><th>作用</th><th>参数解释</th></tr></thead><tbody><tr><td><strong>AddVectoredExceptionHandler</strong></td><td>注册一个新的向量化异常处理函数（VEH）。注册后，当线程出现异常（例如访问违规、除零、<code>RaiseException</code>）时，系统会回调你提供的函数。</td><td><strong>ULONG FirstHandler</strong>：是否把此 handler 放在最前面。 <code>1</code> → 高优先级（最先被调用） <code>0</code> → 低优先级（放在队列后面）<strong>PVECTORED_EXCEPTION_HANDLER VectoredHandler</strong>：回调函数地址，函数类型为 <code>LONG CALLBACK handler(EXCEPTION_POINTERS* ExceptionInfo)</code>。返回值控制异常是否继续传播。</td></tr><tr><td><strong>RemoveVectoredExceptionHandler</strong></td><td>移除已注册的 VEH。</td><td><strong>PVOID HandlerHandle</strong>：<code>AddVectoredExceptionHandler</code> 返回的句柄。</td></tr><tr><td><strong>RaiseException</strong></td><td>主动抛出一个软件异常，会触发 VEH。</td><td><strong>DWORD dwExceptionCode</strong>：异常码（自定义或系统定义）。<strong>DWORD dwExceptionFlags</strong>：是否可继续执行。<code>0</code> 表示可继续，<code>EXCEPTION_NONCONTINUABLE</code> 表示不可继续。<strong>DWORD nNumberOfArguments</strong>：额外参数个数。*<em>const ULONG_PTR <em>lpArguments</em></em>：异常参数数组（可选）。</td></tr><tr><td><strong>EXCEPTION_POINTERS</strong></td><td>VEH 的回调参数结构，包含异常上下文。</td><td>成员有两个：<strong>ExceptionRecord</strong>：描述异常的详细信息（代码、参数、地址等）。<strong>ContextRecord</strong>：保存异常发生时 CPU 的寄存器状态（<code>Rip/Eip</code>, <code>Rsp/Esp</code>, <code>Rax</code>, <code>Rcx</code>…）。可读写！修改后返回 <code>EXCEPTION_CONTINUE_EXECUTION</code> 可以改变执行流。</td></tr></tbody></table><h2 id="正向实例："><a href="#正向实例：" class="headerlink" title="正向实例："></a>正向实例：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// veh_demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================= 1. 被“隐藏”的函数 =======================</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SecretFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[SecretFunc] VEH 修改 RIP 后跳转到这里执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">ExitProcess</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================= 2. VEH 回调函数 =======================</span></span><br><span class="line"><span class="function">LONG CALLBACK <span class="title">MyVectoredHandler</span><span class="params">(EXCEPTION_POINTERS* ExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[VEH] 异常捕获！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  ExceptionCode: 0x&quot;</span> &lt;&lt; hex &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  ExceptionAddress: &quot;</span> &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是不是我们自己触发的异常（0xDEADC0DE）</span></span><br><span class="line">    <span class="keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == <span class="number">0xDEADC0DE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[VEH] 捕获到自定义异常，修改上下文...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_X64</span></span><br><span class="line">        ExceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)&amp;SecretFunc; <span class="comment">// x64</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        ExceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;SecretFunc;   <span class="comment">// x86</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 EXCEPTION_CONTINUE_EXECUTION，让程序从修改后的地址继续执行</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他异常交给系统处理</span></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================= 3. 主函数 =======================</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[Main] 注册 VEH...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 VEH，优先级高</span></span><br><span class="line">    PVOID hHandler = <span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, MyVectoredHandler);</span><br><span class="line">    <span class="keyword">if</span> (!hHandler)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;AddVectoredExceptionHandler failed! error=&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[Main] 准备触发自定义异常...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动触发异常</span></span><br><span class="line">    <span class="built_in">RaiseException</span>(<span class="number">0xDEADC0DE</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[Main] 如果看到这行，说明 VEH 没有拦截执行流。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 VEH</span></span><br><span class="line">    <span class="built_in">RemoveVectoredExceptionHandler</span>(hHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Main] 注册 VEH...</span><br><span class="line">[Main] 准备触发自定义异常...</span><br><span class="line">[VEH] 异常捕获！</span><br><span class="line">  ExceptionCode: 0xdeadc0de</span><br><span class="line">  ExceptionAddress: 00007FF6F8B21000</span><br><span class="line">[VEH] 捕获到自定义异常，修改上下文...</span><br><span class="line">[SecretFunc] VEH 修改 RIP 后跳转到这里执行！</span><br><span class="line">[SecretFunc] 恭喜，VEH 已成功拦截并重定向执行流！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><table><thead><tr><th>函数</th><th>用途</th><th>常用返回</th></tr></thead><tbody><tr><td>AddVectoredExceptionHandler</td><td>注册 VEH</td><td>返回 handler 句柄</td></tr><tr><td>RemoveVectoredExceptionHandler</td><td>移除 VEH</td><td>成功返回非 0</td></tr><tr><td>RaiseException</td><td>主动抛出异常</td><td>会调用 VEH</td></tr><tr><td>MyVectoredHandler</td><td>回调处理异常</td><td>返回 CONTINUE_EXECUTION 或 CONTINUE_SEARCH</td></tr><tr><td>ExceptionInfo-&gt;ContextRecord</td><td>保存寄存器上下文</td><td>可修改以改变执行流</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VEH&quot;&gt;&lt;a href=&quot;#VEH&quot; class=&quot;headerlink&quot; title=&quot;VEH&quot;&gt;&lt;/a&gt;VEH&lt;/h1&gt;&lt;p&gt;这是 SEH 的一个增强扩展，通过 &lt;code&gt;AddVectoredExceptionHandler&lt;/code&gt; 添加。VEH </summary>
      
    
    
    
    <category term="pe逆向" scheme="http://example.com/categories/pe%E9%80%86%E5%90%91/"/>
    
    <category term="反调试技术" scheme="http://example.com/categories/pe%E9%80%86%E5%90%91/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="反调试技术" scheme="http://example.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>安卓逆向环境配置</title>
    <link href="http://example.com/2025/10/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2025/10/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2025-10-07T16:00:00.000Z</published>
    <updated>2025-10-09T03:44:39.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>某些安卓题强制要求arm环境才能跑，模拟器不管是脱壳还是动调都有很多问题，最近搞了个真机重新配一遍安卓逆向环境</p><h1 id="root手机"><a href="#root手机" class="headerlink" title="root手机"></a>root手机</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;某些安卓题强制要求arm环境才能跑，模拟器不管是脱壳还是动调都有很多问题，最近搞了个真机重新配一遍安卓逆向环境&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="安卓逆向" scheme="http://example.com/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
    
    <category term="安卓逆向" scheme="http://example.com/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>[GWCTF 2019] babyvm</title>
    <link href="http://example.com/2025/10/07/[GWCTF%202019]babyvm/"/>
    <id>http://example.com/2025/10/07/[GWCTF%202019]babyvm/</id>
    <published>2025-10-06T16:00:00.000Z</published>
    <updated>2025-10-08T07:10:47.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>这道题算非常经典的vm题了，用这道题来熟悉一下vm题基本流程</p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><h2 id="创建结构体："><a href="#创建结构体：" class="headerlink" title="创建结构体："></a>创建结构体：</h2><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/1.png" alt="1"></p><p>有三个函数我们点进去看一下具体逻辑</p><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/vm_init.png" alt="vm_init"></p><p>第一个函数很明显就是vm_init的结构，我们改名为vm_init,并创建结构体帮助静态分析</p><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/struct.png" alt="struct"></p><p>在空白部分右键，添加结构体</p><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/proc.png" alt="proc"></p><p>结构体名就叫vm_cpu，下面按d键快捷键给它增加成员变量</p><p>光标对准vm_cpu struc点一次d是在最前面增加成员变量</p><p>对准field_0点一次d是更改一次field_0的类型,也可按y直接输入类型</p><p>对准vm_cpu ends点一次d是在末尾增加成员变量</p><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/cpu.png" alt="cpu"></p><p>接下来修改成员变量的名称按n快捷键，改为eax，ebx等</p><p>由于vm_cpu中有个数组叫oplist[]</p><p>我们先创建新结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">opcode</span></span><br><span class="line">&#123;</span><br><span class="line">    QWORD _opcode;</span><br><span class="line">    QWORD handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里稍微再提一下怎么确定每个成员变量占多少字节，不要看ida给你强转出来的类型，而要看上下成员之间的差值，比如*(_BYTE <em>)(a1 + 24) &#x3D; -15;和</em>(_QWORD *)(a1 + 32) &#x3D; sub_B5F;从a1+24到a1+32，占了8个字节。所以这里_opcode类型是qword。下面是全部改完之后的结构体</p><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/struct2.png" alt="struct2"></p><p>再回到第一个函数，对准函数参数列表按y，把a1类型改为vm_cpu*，然后函数就变得美观了，下面的qword_2022A8是给vm设置的栈空间，我们也可以改名vm_stack</p><p><img data-src="/images/%5BGWCTF%202019%5Dbabyvm/vm_init2.png" alt="vm_init2"></p><p>第二个函数很容易看出来是vm_run,分发器控制程序执行，第三个函数是验证flag正确与否，就不展开讲了</p><p>第二个函数把参数也改成vm_cpu*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">vm_run</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  a1-&gt;vm_rip = (__int64)&amp;unk_202060;</span><br><span class="line">  <span class="keyword">while</span> ( *(_BYTE *)a1-&gt;vm_rip != <span class="number">0xF4</span> )</span><br><span class="line">    <span class="built_in">sub_E6E</span>(a1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到逻辑已经很明确了，就是rip指向的地址对应的值不等于0xf4时，一直调用sub_E6E</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_E6E</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)a1-&gt;vm_rip != <span class="built_in">LOBYTE</span>(a1-&gt;oplist[i]._opcode); ++i )</span><br><span class="line">    ;</span><br><span class="line">  ((<span class="built_in">void</span> (__fastcall *)(vm_cpu *))a1-&gt;oplist[i].handle)(a1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_E6E点进去就发现和我们的vm基础里的dispatcher结构一模一样，现在我们回头处理一下没命名的handle函数就可以正式逆向了</p><h2 id="识别函数："><a href="#识别函数：" class="headerlink" title="识别函数："></a>识别函数：</h2><h3 id="1-mov函数"><a href="#1-mov函数" class="headerlink" title="1.mov函数"></a>1.mov函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_B5F</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> *v2; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  v2 = (<span class="type">int</span> *)(a1-&gt;vm_rip + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( *(_BYTE *)(a1-&gt;vm_rip + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xE1</span>:</span><br><span class="line">      a1-&gt;vm_eax = *((<span class="type">char</span> *)vm_stack + *v2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xE2</span>:</span><br><span class="line">      a1-&gt;vm_ebx = *((<span class="type">char</span> *)vm_stack + *v2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xE3</span>:</span><br><span class="line">      a1-&gt;vm_ecx = *((<span class="type">char</span> *)vm_stack + *v2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xE4</span>:</span><br><span class="line">      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_eax;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xE5</span>:</span><br><span class="line">      a1-&gt;vm_edx = *((<span class="type">char</span> *)vm_stack + *v2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xE7</span>:</span><br><span class="line">      *((_BYTE *)vm_stack + *v2) = a1-&gt;vm_ebx;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a1-&gt;vm_rip += <span class="number">6LL</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的意思是，v2是栈中偏移，相当于ss:[ebp+v2]&#x3D;vm_stack[v2],当操作码&#x3D;-15也就是0xF1的时候，调用这个函数，下一个地址的数*(_BYTE <em>)(a1-&gt;vm_rip+1))就是选择码，</em>(_BYTE *)(a1-&gt;vm_rip+2))就是操作数</p><ul><li><p>选择码&#x3D;0xE1 执行mov eax ss:[ebp+v2]</p></li><li><p>选择码&#x3D;0xE2 执行mov ebx ss:[ebp+v2]</p></li><li><p>选择码&#x3D;0xE3 执行mov ecx ss:[ebp+v2]</p></li><li><p>选择码&#x3D;0xE4 执行mov ss:[ebp+v2] eax </p></li><li><p>选择码&#x3D;0xE5 执行mov edx ss:[ebp+v2]</p></li><li><p>选择码&#x3D;0xE7 执行mov ss:[ebp+v2] ebx</p></li></ul><h3 id="2-xor"><a href="#2-xor" class="headerlink" title="2.xor"></a>2.xor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_A64</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  a1-&gt;vm_eax ^= a1-&gt;vm_ebx;</span><br><span class="line">  ++a1-&gt;vm_rip;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于xor eax ebx</p><h3 id="3-read"><a href="#3-read" class="headerlink" title="3.read"></a>3.read</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_AC5</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *buf; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  buf = (<span class="type">const</span> <span class="type">char</span> *)vm_stack;</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, vm_stack, <span class="number">0x20uLL</span>);</span><br><span class="line">  dword_2022A4 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( dword_2022A4 != <span class="number">21</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;WRONG!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ++a1-&gt;vm_rip;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把flag读入栈上</p><p>相当于call read,并判断flag长度</p><h3 id="4-nop"><a href="#4-nop" class="headerlink" title="4.nop"></a>4.nop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_956</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  ++a1-&gt;vm_rip;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么都没干，rip只是加1，这是所有指令都要有的</p><h3 id="5-mul"><a href="#5-mul" class="headerlink" title="5.mul"></a>5.mul</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_A08</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  a1-&gt;vm_eax *= a1-&gt;vm_edx;</span><br><span class="line">  ++a1-&gt;vm_rip;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mul eax edx</p><h3 id="6-xchg"><a href="#6-xchg" class="headerlink" title="6.xchg"></a>6.xchg</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_8F0</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> vm_eax; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  vm_eax = a1-&gt;vm_eax;</span><br><span class="line">  a1-&gt;vm_eax = a1-&gt;vm_ebx;</span><br><span class="line">  a1-&gt;vm_ebx = vm_eax;</span><br><span class="line">  ++a1-&gt;vm_rip;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xchg eax ebx</p><h3 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7.自定义函数"></a>7.自定义函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_99C</span><span class="params">(vm_cpu *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  a1-&gt;vm_eax = a1-&gt;vm_ecx + <span class="number">2</span> * a1-&gt;vm_ebx + <span class="number">3</span> * a1-&gt;vm_eax;</span><br><span class="line">  ++a1-&gt;vm_rip;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了eax&#x3D;ecx+2<em>ebx+3</em>eax应该是自定义指令</p><h2 id="自己实现dispatcher，汇编层面逆向"><a href="#自己实现dispatcher，汇编层面逆向" class="headerlink" title="自己实现dispatcher，汇编层面逆向"></a>自己实现dispatcher，汇编层面逆向</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> opcode[]=&#123;</span><br><span class="line"><span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x23</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x2A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0C</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2D</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x05</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE2</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x09</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, </span><br><span class="line">  <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE3</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0E</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rip=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> vm_eax=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> vm_ebx=<span class="number">18</span>;</span><br><span class="line">    <span class="type">int</span> vm_ecx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> vm_edx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> vm_stack[<span class="number">521</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">521</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vm_stack[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(opcode) / <span class="built_in">sizeof</span>(opcode[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span> (rip&lt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(opcode[rip]==<span class="number">0xF1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v2=opcode[rip<span class="number">+2</span>];</span><br><span class="line">            <span class="keyword">switch</span>(opcode[rip<span class="number">+1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xE1</span>:</span><br><span class="line">                    vm_eax = vm_stack[v2];</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;mov eax,stack[&quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xE2</span>:</span><br><span class="line">                    vm_ebx = vm_stack[v2];</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;mov ebx,stack[&quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xE3</span>:</span><br><span class="line">                    vm_ecx = vm_stack[v2];</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;mov ecx,stack[&quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xE4</span>:</span><br><span class="line">                    vm_stack[v2] = vm_eax;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;mov stack[&quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot;],eax&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xE5</span>:</span><br><span class="line">                    vm_edx = vm_stack[v2];</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;mov edx,stack[&quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xE7</span>:</span><br><span class="line">                    vm_stack[v2] = vm_ebx;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;mov stack[&quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot;],ebx&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rip+=<span class="number">6</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opcode[rip]==<span class="number">0xF2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vm_eax^=vm_ebx;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;xor eax ebx&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opcode[rip]==<span class="number">0xF5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// for(int i=0;i&lt;21;i++)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     char c;</span></span><br><span class="line">            <span class="comment">//     cin&gt;&gt;c;</span></span><br><span class="line">            <span class="comment">//     vm_stack[i]=c;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;read flag&amp;&amp;judge len&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opcode[rip]==<span class="number">0xf4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;nop&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opcode[rip]==<span class="number">0xF6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vm_eax=vm_ecx<span class="number">+2</span>*vm_ebx<span class="number">+3</span>*vm_eax;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;eax=ecx+2*ebx+3*eax&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opcode[rip]==<span class="number">0xF7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vm_eax*=vm_edx;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;mul eax edx&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opcode[rip]==<span class="number">0xF8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = vm_eax;</span><br><span class="line">            vm_eax = vm_ebx;</span><br><span class="line">            vm_ebx = t;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;xchg eax ebx&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        rip++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实可以把栈信息一起打印出来的，但是这道题非常简单没有涉及到栈的其他操作，只是简单把flag放在栈上，所以这里不打印了</p><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">read flag&amp;&amp;judge len</span><br><span class="line">mov eax,stack[0]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[32],eax</span><br><span class="line">mov eax,stack[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[33],eax</span><br><span class="line">mov eax,stack[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[34],eax</span><br><span class="line">mov eax,stack[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[35],eax</span><br><span class="line">mov eax,stack[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[36],eax</span><br><span class="line">mov eax,stack[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[37],eax</span><br><span class="line">mov eax,stack[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[38],eax</span><br><span class="line">mov eax,stack[7]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[39],eax</span><br><span class="line">mov eax,stack[8]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[40],eax</span><br><span class="line">mov eax,stack[9]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[41],eax</span><br><span class="line">mov eax,stack[10]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[42],eax</span><br><span class="line">mov eax,stack[11]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[43],eax</span><br><span class="line">mov eax,stack[12]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[44],eax</span><br><span class="line">mov eax,stack[13]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[45],eax</span><br><span class="line">mov eax,stack[14]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[46],eax</span><br><span class="line">mov eax,stack[15]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[47],eax</span><br><span class="line">mov eax,stack[16]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[48],eax</span><br><span class="line">mov eax,stack[17]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[49],eax</span><br><span class="line">mov eax,stack[18]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[50],eax</span><br><span class="line">mov eax,stack[19]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[51],eax</span><br><span class="line">nop</span><br><span class="line">read flag&amp;&amp;judge len</span><br><span class="line">mov eax,stack[0]</span><br><span class="line">mov ebx,stack[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[0],eax</span><br><span class="line">mov eax,stack[1]</span><br><span class="line">mov ebx,stack[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[1],eax</span><br><span class="line">mov eax,stack[2]</span><br><span class="line">mov ebx,stack[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[2],eax</span><br><span class="line">mov eax,stack[3]</span><br><span class="line">mov ebx,stack[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[3],eax</span><br><span class="line">mov eax,stack[4]</span><br><span class="line">mov ebx,stack[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[4],eax</span><br><span class="line">mov eax,stack[5]</span><br><span class="line">mov ebx,stack[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov stack[5],eax</span><br><span class="line">mov eax,stack[6]</span><br><span class="line">mov ebx,stack[7]</span><br><span class="line">mov ecx,stack[8]</span><br><span class="line">mov edx,stack[12]</span><br><span class="line">eax=ecx+2*ebx+3*eax</span><br><span class="line">mul eax edx</span><br><span class="line">mov stack[6],eax</span><br><span class="line">mov eax,stack[7]</span><br><span class="line">mov ebx,stack[8]</span><br><span class="line">mov ecx,stack[9]</span><br><span class="line">mov edx,stack[12]</span><br><span class="line">eax=ecx+2*ebx+3*eax</span><br><span class="line">mul eax edx</span><br><span class="line">mov stack[7],eax</span><br><span class="line">mov eax,stack[8]</span><br><span class="line">mov ebx,stack[9]</span><br><span class="line">mov ecx,stack[10]</span><br><span class="line">mov edx,stack[12]</span><br><span class="line">eax=ecx+2*ebx+3*eax</span><br><span class="line">mul eax edx</span><br><span class="line">mov stack[8],eax</span><br><span class="line">mov eax,stack[13]</span><br><span class="line">mov ebx,stack[19]</span><br><span class="line">xchg eax ebx</span><br><span class="line">mov stack[13],eax</span><br><span class="line">mov stack[19],ebx</span><br><span class="line">mov eax,stack[14]</span><br><span class="line">mov ebx,stack[18]</span><br><span class="line">xchg eax ebx</span><br><span class="line">mov stack[14],eax</span><br><span class="line">mov stack[18],ebx</span><br><span class="line">mov eax,stack[15]</span><br><span class="line">mov ebx,stack[17]</span><br><span class="line">xchg eax ebx</span><br><span class="line">mov stack[15],eax</span><br><span class="line">mov stack[17],ebx</span><br><span class="line">nop</span><br></pre></td></tr></table></figure><p>正常一道普通的vm逆向题到这里看汇编逆向写exp就结束了，但这道题还有坑</p><h2 id="题外话："><a href="#题外话：" class="headerlink" title="题外话："></a>题外话：</h2><h3 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h3><p>这道题汇编前半部分很明显不对，因为flag总长度才21，栈上怎么索引到50多了，所以交叉引用找到真正的check函数,而且汇报中有两次输入，第二次输入才是真的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">sub_F00</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; len_flag - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)vm_stack + i) != byte_202020[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密文（十六进制字符串）</span></span><br><span class="line">flag = <span class="string">&#x27;69 45 2A 37 09 17 C5 0B 5C 72 33 76 33 21 74 31 5F 33 73 72&#x27;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">flag = [<span class="built_in">int</span>(x, <span class="number">16</span>) <span class="keyword">for</span> x <span class="keyword">in</span> flag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) 还原前面的三次交换（你在 forward 阶段做了 13&lt;-&gt;19, 14&lt;-&gt;18, 15&lt;-&gt;17）</span></span><br><span class="line">flag[<span class="number">15</span>], flag[<span class="number">17</span>] = flag[<span class="number">17</span>], flag[<span class="number">15</span>]</span><br><span class="line">flag[<span class="number">14</span>], flag[<span class="number">18</span>] = flag[<span class="number">18</span>], flag[<span class="number">14</span>]</span><br><span class="line">flag[<span class="number">19</span>], flag[<span class="number">13</span>] = flag[<span class="number">13</span>], flag[<span class="number">19</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 用 Z3 求解 a6,a7,a8（原始 stack[6..8]）</span></span><br><span class="line"><span class="comment"># 方程（forward）是： f6 = (s8 + 2*s7 + 3*s6) * s12  （全部为字节运算）</span></span><br><span class="line">a6, a7, a8 = BitVecs(<span class="string">&#x27;a6 a7 a8&#x27;</span>, <span class="number">8</span>)</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这里 flag[...] 是 Python 整数（0..255），Z3 会自动把它转为相应的常量。</span></span><br><span class="line"><span class="comment"># 若你想更严格地把所有算术限定为 8-bit，可把常量也包装成 BitVecVal(...,8)。</span></span><br><span class="line">s.add( BitVecVal(flag[<span class="number">6</span>],<span class="number">8</span>) == (a8 + (a7 &lt;&lt; <span class="number">1</span>) + a6 * BitVecVal(<span class="number">3</span>,<span class="number">8</span>)) * BitVecVal(flag[<span class="number">12</span>],<span class="number">8</span>) )</span><br><span class="line">s.add( BitVecVal(flag[<span class="number">7</span>],<span class="number">8</span>) == (BitVecVal(flag[<span class="number">9</span>],<span class="number">8</span>)  + (a8 &lt;&lt; <span class="number">1</span>) + a7 * BitVecVal(<span class="number">3</span>,<span class="number">8</span>)) * BitVecVal(flag[<span class="number">12</span>],<span class="number">8</span>) )</span><br><span class="line">s.add( BitVecVal(flag[<span class="number">8</span>],<span class="number">8</span>) == (BitVecVal(flag[<span class="number">10</span>],<span class="number">8</span>) + (BitVecVal(flag[<span class="number">9</span>],<span class="number">8</span>) &lt;&lt; <span class="number">1</span>) + a8 * BitVecVal(<span class="number">3</span>,<span class="number">8</span>)) * BitVecVal(flag[<span class="number">12</span>],<span class="number">8</span>) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="comment"># 把求得的 a6,a7,a8 写回 flag 对应位置</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> [a6, a7, a8]:</span><br><span class="line">        idx = <span class="built_in">int</span>(re.search(<span class="string">r&#x27;\d+&#x27;</span>, <span class="built_in">str</span>(v)).group())</span><br><span class="line">        flag[idx] = m[v].as_long()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 逆向 XOR 链（forward 做了 f0 = s0^s1; f1 = s1^s2; ...; f5 = s5^s6）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    flag[i] ^= flag[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] flag: &#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> flag))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] flag:  Y0u_hav3_r3v3rs3_1t!</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;这道题算非常经典的vm题了，用这道题来熟悉一下vm题基本流程&lt;/p&gt;
&lt;h1 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; cla</summary>
      
    
    
    
    <category term="vm逆向题单" scheme="http://example.com/categories/vm%E9%80%86%E5%90%91%E9%A2%98%E5%8D%95/"/>
    
    
    <category term="vm逆向" scheme="http://example.com/tags/vm%E9%80%86%E5%90%91/"/>
    
    <category term="ctf" scheme="http://example.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>vm逆向基础及做题套路</title>
    <link href="http://example.com/2025/10/06/vm%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/10/06/vm%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/</id>
    <published>2025-10-05T16:00:00.000Z</published>
    <updated>2025-10-07T12:27:17.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>学过计算机组成原理的应该都知道，程序的运行是靠cpu解释可执行文件中操作码来实现的功能，vm逆向顾名思义就是自己定义了小型cpu并定义了指令集，将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。</p><h1 id="vm逆向基本原理："><a href="#vm逆向基本原理：" class="headerlink" title="vm逆向基本原理："></a>vm逆向基本原理：</h1><h2 id="vm-init："><a href="#vm-init：" class="headerlink" title="vm_init："></a>vm_init：</h2><p>虚拟机的入口函数，对虚拟机环境进行初始化，初始化一般包括</p><ul><li><p>寄存器初始化(eax,ebx,ecx,edx,eip)</p></li><li><p>把handle函数和操作码连接在一起</p></li><li><p>给虚拟机的栈空间vm_stack分配内存</p></li></ul><h2 id="vm-run"><a href="#vm-run" class="headerlink" title="vm_run:"></a>vm_run:</h2><p>虚拟机开始运行的地方</p><h2 id="vm-dispatcher"><a href="#vm-dispatcher" class="headerlink" title="vm_dispatcher:"></a>vm_dispatcher:</h2><p>调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。</p><h2 id="vm-handle"><a href="#vm-handle" class="headerlink" title="vm_handle:"></a>vm_handle:</h2><p>处理器，当rip走到对应操作码时调用对应操作函数，并接受操作数。</p><h2 id="opcode"><a href="#opcode" class="headerlink" title="opcode :"></a>opcode :</h2><p>程序可执行代码转换成的操作码</p><p>在这种情况下，如果要逆向程序，就需要对整个emulator结构进行逆向，理解程序功能，还需要结合opcode进行分析，整个程序逆向工程将会十分繁琐。这是一个一般虚拟机结构：<br><img data-src="/images/vm%E9%80%86%E5%90%91.png" alt="vm逆向"></p><h2 id="vm-lables"><a href="#vm-lables" class="headerlink" title="vm_lables:"></a>vm_lables:</h2><p>有的虚拟机涉及lable的创造和调用，起到跳转目的</p><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><p>在比赛中，虚拟机题目常常有两种考法：</p><ul><li><p>给可执行程序和opcode，逆向emulator，结合opcode文件，推出flag</p></li><li><p>只给可执行程序，逆向emulator，构造opcode，读取flag</p></li></ul><p>拿到一个虚拟机之后，一般有以下几个逆向过程：</p><ul><li><p>分析虚拟机入口，搞清虚拟机的输入，或者opcode位置</p></li><li><p>理清虚拟机结构，包括Dispatcher和各个Handler</p></li><li><p>逆向各个Handler，分析opcode的意义</p></li><li><p>根据opcode运行时打印出对应汇编代码，根据汇编代码逻辑进行逆向</p></li></ul><h1 id="一个简单vm虚拟机实例："><a href="#一个简单vm虚拟机实例：" class="headerlink" title="一个简单vm虚拟机实例："></a>一个简单vm虚拟机实例：</h1><h2 id="vm-cpu结构体"><a href="#vm-cpu结构体" class="headerlink" title="vm_cpu结构体"></a>vm_cpu结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r1;    <span class="comment">//虚拟寄存器r1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r2;    <span class="comment">//虚拟寄存器r2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r3;    <span class="comment">//虚拟寄存器r3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *eip;    <span class="comment">//指向正在解释的opcode地址</span></span><br><span class="line">    vm_opcode op_list[OPCODE_N];    <span class="comment">//opcode列表，存放了所有的opcode及其对应的处理函数</span></span><br><span class="line">&#125;vm_cpu;</span><br></pre></td></tr></table></figure><h2 id="vm-opcode结构体"><a href="#vm-opcode结构体" class="headerlink" title="vm_opcode结构体"></a>vm_opcode结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> opcode;</span><br><span class="line">    <span class="built_in">void</span> (*handle)(<span class="type">void</span>*);</span><br><span class="line">&#125;vm_opcode;</span><br></pre></td></tr></table></figure><h2 id="vm-init"><a href="#vm-init" class="headerlink" title="vm_init()"></a>vm_init()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">vm_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vm_vpu *cpu;</span><br><span class="line">    cpu-&gt;r1 = <span class="number">0</span>;</span><br><span class="line">    cpu-&gt;r2 = <span class="number">0</span>;</span><br><span class="line">    cpu-&gt;r3 = <span class="number">0</span>;</span><br><span class="line">    cpu-&gt;eip = (<span class="type">unsigned</span> <span class="type">char</span> *)vm_code;<span class="comment">//将eip指向opcode的地址</span></span><br><span class="line"></span><br><span class="line">    cpu-&gt;op_list[<span class="number">0</span>].opcode = <span class="number">0x1</span>;</span><br><span class="line">    cpu-&gt;op_list[<span class="number">0</span>].handle = (<span class="built_in">void</span> (*)(<span class="type">void</span> *))mov;<span class="comment">//将操作字节码与对应的handle函数关联在一起</span></span><br><span class="line"></span><br><span class="line">    cpu-&gt;op_list[<span class="number">1</span>].opcode = <span class="number">0xf2</span>;</span><br><span class="line">    cpu-&gt;op_list[<span class="number">1</span>].handle = (<span class="built_in">void</span> (*)(<span class="type">void</span> *))<span class="keyword">xor</span>;</span><br><span class="line"></span><br><span class="line">    cpu-&gt;op_list[<span class="number">2</span>].opcode = <span class="number">0xf5</span>;</span><br><span class="line">    cpu-&gt;op_list[<span class="number">2</span>].handle = (<span class="built_in">void</span> (*)(<span class="type">void</span> *))read_;</span><br><span class="line"></span><br><span class="line">    vm_stack = <span class="built_in">malloc</span>(<span class="number">0x512</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vm_stack,<span class="number">0</span>,<span class="number">0x512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handles-示例"><a href="#handles-示例" class="headerlink" title="handles(示例)"></a>handles(示例)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mov</span><span class="params">(vm_cpu *cpu)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xor</span><span class="params">(vm_cpu *cpu)</span></span>;    <span class="comment">//xor flag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_</span><span class="params">(vm_cpu *cpu)</span></span>;    <span class="comment">//call read, read the flag</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xor</span><span class="params">(vm_cpu *cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = cpu-&gt;r1 ^ cpu-&gt;r2;</span><br><span class="line">    temp ^= <span class="number">0x12</span>;</span><br><span class="line">    cpu-&gt;r1 = temp;</span><br><span class="line">    cpu-&gt;eip += <span class="number">1</span>;    <span class="comment">//xor指令占一个字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_</span><span class="params">(vm_cpu *cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *dest = vm_stack;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>,dest,<span class="number">12</span>);    <span class="comment">//用于往虚拟机的栈上读取数据</span></span><br><span class="line">    cpu-&gt;eip += <span class="number">1</span>;    <span class="comment">//read_指令占一个字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mov</span><span class="params">(vm_cpu *cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//mov指令的参数都因曾在字节码也就是vm_code中，指令表示后的一个字节是寄存器表示，第二到</span></span><br><span class="line"><span class="comment">//第五是要mov的数据在vm_stack上的偏移</span></span><br><span class="line">    <span class="comment">//这里只是实现了从vm_stack上取数据和存数据到vm_stack上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *res = cpu-&gt;eip + <span class="number">1</span>;    <span class="comment">//寄存器标识</span></span><br><span class="line">    <span class="type">int</span> *offset = (<span class="type">int</span> *)(cpu-&gt;eip + <span class="number">2</span>);    <span class="comment">//寄存器在vm_stack上的偏移</span></span><br><span class="line">    <span class="type">char</span> *dest = <span class="number">0</span>;</span><br><span class="line">    dest = vm_stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (*res) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xe1</span>:</span><br><span class="line">            cpu-&gt;r1 = *(dest + *offset);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xe2</span>:</span><br><span class="line">            cpu-&gt;r2 = *(dest + *offset);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xe3</span>:</span><br><span class="line">            cpu-&gt;r3 = *(dest + *offset);</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xe4</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = cpu-&gt;r1;</span><br><span class="line">            *(dest + *offset) = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    cpu-&gt;eip += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//mov指令占六个字节，所以eip要向后移6位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vm-code"><a href="#vm-code" class="headerlink" title="vm_code"></a>vm_code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">​<span class="type">unsigned</span> <span class="type">char</span> vm_code[] = &#123;</span><br><span class="line">    <span class="number">0xf5</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x1</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x2</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x22</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x3</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x23</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x4</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x24</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x5</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x6</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x26</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x7</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x27</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x28</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x9</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x29</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0xa</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x2a</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0xb</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xf2</span>,<span class="number">0xf1</span>,<span class="number">0xe4</span>,<span class="number">0x2b</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xf4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><h3 id="vm-stack"><a href="#vm-stack" class="headerlink" title="vm_stack"></a>vm_stack</h3><p>一般是一个全局数组，用于存放虚拟机的栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm_stack = <span class="built_in">malloc</span>(<span class="number">0x512</span>);</span><br><span class="line"><span class="built_in">memset</span>(vm_stack,<span class="number">0</span>,<span class="number">0x512</span>);</span><br></pre></td></tr></table></figure><h2 id="vm-run-1"><a href="#vm-run-1" class="headerlink" title="vm_run"></a>vm_run</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vm_run</span><span class="params">(vm_cpu *cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    进入虚拟机</span></span><br><span class="line"><span class="comment">    eip指向要被解释的opcode地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cpu-&gt;eip = (<span class="type">unsigned</span> <span class="type">char</span>*)opcodes;</span><br><span class="line">    <span class="keyword">while</span>((*cpu-&gt;eip) != <span class="number">0xf4</span>)<span class="comment">//如果opcode不为RET，就调用vm_dispatcher来解释执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vm_dispatcher</span>(*cpu-&gt;eip)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vm-dispatcher-1"><a href="#vm-dispatcher-1" class="headerlink" title="vm_dispatcher"></a>vm_dispatcher</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vm_dispatcher</span><span class="params">(vm_cpu *cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; OPCODE_N; i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode)</span><br><span class="line">        &#123;</span><br><span class="line">            cpu-&gt;op_list[i].<span class="built_in">handle</span>(cpu);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题流程："><a href="#做题流程：" class="headerlink" title="做题流程："></a>做题流程：</h1><ul><li><p>先根据上面的特征静态分析判断函数是vm中的哪一部分，如果静态分析困难，那就动调一下</p></li><li><p>找到对应部分后创建上述结构体来帮助分析</p></li><li><p>自己把vm还原在vscode里，并在dispatcher部分加上打印这条指令的代码，有的时候也可以打印stack，和当前执行完指令的内存状态(各个变量的值)</p></li><li><p>根据打印出的汇编指令，手动逆向</p></li></ul><p>具体使用方法还需在实战中不断练习，具体做题流程可看我的vm题单真题</p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><p><a href="https://blog.csdn.net/weixin_43876357/article/details/108570305">虚拟机逆向与实现-CSDN博客</a></p><p><a href="https://www.freebuf.com/column/174623.html">虚拟机保护逆向入门 - FreeBuf网络安全行业门户</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;学过计算机组成原理的应该都知道，程序的运行是靠cpu解释可执行文件中操作码来实现的功能，vm逆向顾名思义就是自己定义了小型cpu并定</summary>
      
    
    
    
    <category term="vm逆向题单" scheme="http://example.com/categories/vm%E9%80%86%E5%90%91%E9%A2%98%E5%8D%95/"/>
    
    
    <category term="vm逆向" scheme="http://example.com/tags/vm%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>rust逆向基础-rust基础语法</title>
    <link href="http://example.com/2025/10/01/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/10/01/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/</id>
    <published>2025-09-30T16:00:00.000Z</published>
    <updated>2025-10-01T15:24:00.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下</p><h2 id="rust相比其他编程语言的优势"><a href="#rust相比其他编程语言的优势" class="headerlink" title="rust相比其他编程语言的优势:"></a>rust相比其他编程语言的优势:</h2><ul><li><p>rust不通过<code> GC</code>(garbage collection)机制管理内存,例如python,golang等基于GC机制的编程语言会在exe运行时不断寻找虚拟地址中无用的内存空间.这会大大降低运行速度</p></li><li><p>rust使用所有权机制管理内存,这也使得它相比与手动开辟内存的c&#x2F;c++更安全</p></li></ul><p>我们rust在逆向中通常用于网络编程,游戏编程,wasm,嵌入式.所以写游戏外挂,实现检测外挂都必须要学习rust.</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h2><p>rust中变量声明要用let.rust中每个变量类型可以自己指定,也可交给编译器推断,每个变量类型可以声明可变也可声明不可变.(注:如果要声明常量类型时,常量名一定要全大写,并且必须显示指定类型.例如<code> const MAX:u32=10;</code>)</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li><p>有符号：<code>i8, i16, i32, i64, i128, isize</code></p></li><li><p>无符号：<code>u8, u16, u32, u64, u128, usize</code></p></li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li><p><code>f32</code>（32 位单精度）</p></li><li><p><code>f64</code>（64 位双精度，默认）</p></li></ul><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><ul><li><p>true</p></li><li><p>false</p></li></ul><h3 id="char型"><a href="#char型" class="headerlink" title="char型"></a>char型</h3><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><ul><li><p><code>&amp;str</code> → 字符串切片（不可变）</p></li><li><p><code>String</code> → 堆分配的可变字符串</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span>= <span class="number">5</span>; <span class="comment">// 变量后的：i32可以自己指定，也可让编译器推断</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span>: <span class="type">u32</span> = <span class="number">5</span>; <span class="comment">// u32 表示32位无符号整数,mut表示可变</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of n is &#123;&#125;&quot;</span>,n); <span class="comment">// println! 用来打印字符串到终端，n代表换行，!代表宏</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of i is &#123;&#125;&quot;</span>,i);</span><br><span class="line">    i=<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of i is &#123;&#125;&quot;</span>,i);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">f64</span> = <span class="number">5.2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is &#123;&#125;&quot;</span>,x);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">char</span> =<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>,y);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span>=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of t is &#123;&#125;&quot;</span>,t);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span>: &amp;<span class="type">str</span>=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of str is &#123;&#125;&quot;</span>,<span class="type">str</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    s2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, Rust!&quot;</span>);        <span class="comment">// 可变字符串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The value of n is 5</span><br><span class="line">The value of i is 5</span><br><span class="line">The value of i is 7</span><br><span class="line">The value of x is 5.2</span><br><span class="line">The value of y is d</span><br><span class="line">The value of t is true</span><br><span class="line">The value of str is hello</span><br><span class="line">Hello, Rust!</span><br></pre></td></tr></table></figure><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句:"></a>控制语句:</h2><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if-else if-else"></a>if-else if-else</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;负数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;非负数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><p>loop 一直循环</p></li><li><p>while 有条件的循环</p></li><li><p>for</p></li></ul><p>可以通过break跳出循环,也可以通过continue继续当前循环.这和c++是一样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loop</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>; <span class="comment">// 返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    i -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> arr &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>match的用法和if-else很像,但是要注意match要把所有情况包含在内,不然编译阶段就报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;一或二&quot;</span>),</span><br><span class="line">    <span class="number">3</span>..=<span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;三到七之间&quot;</span>), <span class="comment">// 范围匹配</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;其他&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h3><p>基本的函数定义是<code>fn fucnction(a:i32,b:i32) -&gt; i32</code>其中箭头右面的是返回值类型.rust函数表达力非常强</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a:<span class="type">i32</span>,b:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    a+b <span class="comment">//不加分号，rust会将最后一行作为返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>=<span class="title function_ invoke__">add</span>(a,b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,res);<span class="comment">//println!()是rust的输出函数，其中第一个参数必须是&quot;&quot;包裹的字符串(不能用&#x27;&#x27;替代)，第二个参数是占位符，占位符的值通过&#123;&#125;来传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包:"></a>闭包:</h3><p>闭包可以理解成python里的lambda差不多,相当于匿名函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>=|a:<span class="type">i32</span>,b:<span class="type">i32</span>|<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;a+b&#125;;<span class="comment">//这里定义时是用||包裹参数，调用时和正常函数一样</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span>=<span class="title function_ invoke__">sum</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The sum is &#123;&#125;&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rust复合类型"><a href="#rust复合类型" class="headerlink" title="rust复合类型"></a>rust复合类型</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举:"></a>枚举:</h3><p>简单来说，<strong>枚举（<code>enum</code>）就是用来表示“一个值可能属于几种互斥情况之一”</strong>，也就是“有限状态或选择”。</p><p>换句话说，它适合表示<strong>有多种可能性，但每次只能选一个</strong>的场景。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLight</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Green,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">light</span> = TrafficLight::Red;</span><br><span class="line"><span class="keyword">match</span> light &#123;</span><br><span class="line">    TrafficLight::Red =&gt; <span class="built_in">println!</span>(<span class="string">&quot;停&quot;</span>),</span><br><span class="line">    TrafficLight::Yellow =&gt; <span class="built_in">println!</span>(<span class="string">&quot;准备&quot;</span>),</span><br><span class="line">    TrafficLight::Green =&gt; <span class="built_in">println!</span>(<span class="string">&quot;走&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体基础"><a href="#结构体基础" class="headerlink" title="结构体基础:"></a>结构体基础:</h3><p>结构体和enum不一样的点在于声明结构体时,要把内部变量的类型写出来.而enum就不用</p><p>其中对#[derive(Debug)]的解释:</p><table><thead><tr><th>部分</th><th>含义</th><th>记忆小技巧</th></tr></thead><tbody><tr><td><code>#[]</code></td><td>Rust 的 <strong>属性（attribute）标记</strong>，用来告诉编译器对后面的结构体&#x2F;枚举做某些处理</td><td>“井号括号 → 给编译器的指令”</td></tr><tr><td><code>derive</code></td><td>自动 <strong>派生&#x2F;生成实现</strong> trait 的代码</td><td>“derive &#x3D; 自动生成某种功能”</td></tr><tr><td><code>(Debug)</code></td><td>指定生成的 trait 是 <code>Debug</code></td><td>“Debug &#x3D; 调试打印能力”</td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>=Node&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=n.x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>=n.y;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="comment">//打印结构体或enum类型，要用&#123;:?&#125;,配合结构体定义上方的#[derive(Debug)]打印结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体进阶"><a href="#结构体进阶" class="headerlink" title="结构体进阶:"></a>结构体进阶:</h3><p>Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的 key: value 语法来实现定义：</p><p>实例化时:</p><p>结构体类名 {<br>    字段名 : 字段值,<br>    …<br>}</p><p>(1)在结构体内部用impl关键字实现内联函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(x:<span class="type">i32</span>,y:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">        x*y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>=Node&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=n.x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>=n.y;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=Node::<span class="title function_ invoke__">area</span>(x, y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (2)用结构体中self指针实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// impl Node&#123;</span></span><br><span class="line"><span class="comment">//     fn area(x:i32,y:i32)-&gt;i32&#123;</span></span><br><span class="line"><span class="comment">//         x*y</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.x*<span class="keyword">self</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>=Node&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=n.x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>=n.y;</span><br><span class="line">    <span class="comment">//let s=Node::area(x, y);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=n.<span class="title function_ invoke__">area</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)结构体实现构造函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x:<span class="type">i32</span>,y:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="keyword">Self</span>&#123;<span class="comment">//默认构造函数名都叫new，但这不是个关键字</span></span><br><span class="line">        Node&#123;</span><br><span class="line">            x:x,</span><br><span class="line">            y:y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.x*<span class="keyword">self</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>=Node::<span class="title function_ invoke__">new</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=n.x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>=n.y;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=n.<span class="title function_ invoke__">area</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)self的用法:</p><ul><li><p><strong><code>self</code> 小写</strong> &#x3D; 当前对象实例指针。</p></li><li><p><strong><code>Self</code> 大写</strong> &#x3D; 当前类型名。</p></li></ul><p>self指针也分为可变和不可变的,可变的要在self前加关键字mut</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    name:<span class="type">String</span>,</span><br><span class="line">    age:<span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name:<span class="type">String</span>,age:<span class="type">u32</span>)<span class="punctuation">-&gt;</span><span class="keyword">Self</span>&#123;</span><br><span class="line">        Person&#123;name,age&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不可变的this指针</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">String</span>&#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Hello,my name is &#123;&#125; and I am &#123;&#125; years old.&quot;</span>,<span class="keyword">self</span>.name,<span class="keyword">self</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可变的this指针</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">up_age</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.age+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>=Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;原子&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">18</span>); <span class="comment">//“原子”是静态str.&amp;str类型，要转成可变的String</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,a); <span class="comment">//&#123;:#?&#125;是调试格式，和&#123;:?&#125;的区别是，&#123;:#?&#125;会多出缩进，方便阅读</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a.<span class="title function_ invoke__">greet</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> =a;</span><br><span class="line">    b.<span class="title function_ invoke__">up_age</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,b.<span class="title function_ invoke__">greet</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person &#123;</span><br><span class="line">    name: &quot;原子&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">&#125;</span><br><span class="line">Hello,my name is 原子 and I am 18 years old.</span><br><span class="line">Hello,my name is 原子 and I am 19 years old.</span><br></pre></td></tr></table></figure><p>self还有一个不经常用的用法:就是如果传入参数是self(不带&amp;)的话:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 self 是按值传递，意味着把 Node 本身交给这个方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_tuple</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">i32</span>, <span class="type">i32</span>) &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = Node &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = n.<span class="title function_ invoke__">into_tuple</span>();  <span class="comment">//  这里 n 被 move 走</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, n.x); //  报错：因为 n 的所有权已经交出，不能再用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组:"></a>元组:</h3><p>1.基本定义:元组就是把多个不同类型的值组合在一起的复合类型。<br>语法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">char</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2.访问元素</p><p>有两种方式：</p><p>方式一：解构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;y 的值是: &#123;&#125;&quot;</span>, y);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式二：点语法（下标访问）</p><p>注意第一个元素下标是0</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;第一个元素是: &#123;&#125;&quot;</span>, tup.<span class="number">0</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;第二个元素是: &#123;&#125;&quot;</span>, tup.<span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;第三个元素是: &#123;&#125;&quot;</span>, tup.<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.特点:可以包含不同类型的值</p><p>长度固定，不能改变</p><p>4.打印可利用{:?}来打印</p><h1 id="核心机制-数据结构"><a href="#核心机制-数据结构" class="headerlink" title="核心机制&amp;数据结构"></a>核心机制&amp;数据结构</h1><h2 id="栈和堆存放"><a href="#栈和堆存放" class="headerlink" title="栈和堆存放"></a>栈和堆存放</h2><ol><li>栈 (Stack) 的特点</li></ol><ul><li><p>后进先出 (LIFO) 的数据结构，内存分配和释放都非常快。</p></li><li><p>大小在编译时必须确定。</p></li><li><p>栈上的数据一般是 <strong>固定大小、生命周期明确的值</strong>。</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>;       <span class="comment">// i32，大小固定 4 字节</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">true</span>;     <span class="comment">// bool，1 字节</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = <span class="string">&#x27;a&#x27;</span>;      <span class="comment">// char，4 字节</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> : &amp;<span class="type">str</span> = <span class="symbol">&#x27;hell</span>o<span class="string">&#x27;  //静态字符串切片,长度固定,在栈上</span></span><br></pre></td></tr></table></figure><ol start="2"><li>堆 (Heap) 的特点</li></ol><ul><li><p>内存大小运行时才能确定。</p></li><li><p>需要手动申请（在 Rust 中由所有权系统管理，避免泄漏）。</p></li><li><p>分配和释放开销比栈大，但适合存放 <strong>动态大小或不确定大小的数据</strong>。</p></li></ul><h2 id="所有权机制"><a href="#所有权机制" class="headerlink" title="所有权机制"></a>所有权机制</h2><p>堆和栈上数据都有所有权的这个概念,但是栈上数据拷贝时不会move(转移所有权),而是使用copy(复制一个样本),堆会move</p><p><strong>栈上的数据</strong>：如果它的类型实现了 Copy trait（比如 i32、bool、char、浮点数、简单元组），那么赋值时不会发生“严格意义上的 move”，而是直接 复制一份值。</p><ul><li>所以原变量不会失效，看起来像“转移没事”。</li></ul><p>实际上这不是“move”，而是 copy。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x;  <span class="comment">// Copy，不是 move</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;, y=&#123;&#125;&quot;</span>, x, y); <span class="comment">//  x 还能用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>堆上的数据</strong>：比如 <code>String</code>、<code>Vec</code>，它们没实现 <code>Copy</code>，赋值时会发生 <strong>move</strong>。</p><ul><li>所有权转移后，原变量会失效，防止两个变量同时指向同一块堆内存。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;   <span class="comment">// Move</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s1); // 报错：s1 已经失效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);   <span class="comment">//  只有 s2 能用了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="引用和可变引用"><a href="#引用和可变引用" class="headerlink" title="引用和可变引用:"></a>引用和可变引用:</h3><p>引用 (Reference)</p><ul><li><p>引用本质上就是 <strong>借用 (borrow)</strong>。</p></li><li><p>借用不会转移所有权，值的所有者依然是原来的变量。</p></li><li><p>分为：</p><p><strong>不可变引用 (&amp;T)</strong>：可以有多个，但不能和可变引用同时存在。</p><p><strong>可变引用 (&amp;mut T)</strong>：只能有一个，且不能和不可变引用共存。(可变引用要求被引用的变量是可变的)</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:<span class="type">String</span> =<span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span>=&amp;a; <span class="comment">//这里就算拷贝给r1,也能成功输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone的使用"><a href="#clone的使用" class="headerlink" title="clone的使用:"></a>clone的使用:</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug,Clone)]</span> <span class="comment">//必须结构体里的所有字段都是可拷贝的，才可像正常u32，i32那样使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">man</span>&#123;</span><br><span class="line">    name:<span class="type">String</span>,</span><br><span class="line">    age:<span class="type">u32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = man&#123;</span><br><span class="line">        name:<span class="string">&quot;原子&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age:<span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span>=a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clone就相当于c++中的深拷贝,解决了两个指针指向同一块内存的问题,所以clone之后就可以正常赋值,并接着使用</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h3><p>生命周期用语法 <code>&#39;a</code> 表示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">example</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当结构体里有引用时，必须标注生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123; name: &amp;name, age: <span class="number">20</span> &#125;; <span class="comment">// name 生命周期必须 ≥ p 生命周期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生命周期的核心思想:<strong>引用永远不能比它指向的数据活得长</strong>。</p><p>编译器在编译期检查生命周期，保证安全。</p><p><code>&#39;a</code> 是标识符，用来关联多个引用的生命周期。</p><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构:"></a>常用数据结构:</h2><h3 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h3><p>&amp;str:是String类型的一个切片.长度确定放在栈上.</p><p>String一般长度不确定,放在堆上</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建:"></a>创建:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();              <span class="comment">// 空字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);      <span class="comment">// 从字面量创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>();        <span class="comment">// &amp;str 转 String</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加"><a href="#添加" class="headerlink" title="添加:"></a>添加:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);          <span class="comment">// 添加单个字符</span></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; World&quot;</span>); <span class="comment">// 添加字符串切片</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接:"></a>拼接:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 + 或 format! 宏</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;           <span class="comment">// s1 被移动，s2 被借用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s2, <span class="string">&quot;!!!&quot;</span>);  <span class="comment">// 不移动任何变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取长度和容量"><a href="#获取长度和容量" class="headerlink" title="获取长度和容量"></a>获取长度和容量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;length: &#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>());    <span class="comment">// 字节数</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;capacity: &#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">capacity</span>()); <span class="comment">// 堆上分配的容量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">pop</span>();              <span class="comment">// 删除最后一个字符</span></span><br><span class="line">s.<span class="title function_ invoke__">clear</span>();            <span class="comment">// 清空整个字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// let c = s[0]; //  String 不支持直接索引</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>]; <span class="comment">//  切片，返回 &amp;str，必须按字节边界</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;world&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">find</span>(<span class="string">&quot;world&quot;</span>).<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 6，找到索引</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_s</span> = s.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, new_s); <span class="comment">// hello Rust</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a,b,c&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字节</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建:"></a>创建:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();   <span class="comment">// 空 vector</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];          <span class="comment">// 使用宏 vec! 初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">10</span>);   <span class="comment">// 尾部插入</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">0</span>]);        <span class="comment">// 下标访问 (可能 panic 越界)</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>));  <span class="comment">// 安全访问 -&gt; Some(3)</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v.<span class="title function_ invoke__">get</span>(<span class="number">10</span>)); <span class="comment">// None，不会 panic</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">v[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">v.<span class="title function_ invoke__">pop</span>();          <span class="comment">// 删除最后一个 -&gt; Some(4)</span></span><br><span class="line">v.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);      <span class="comment">// 删除指定下标 -&gt; 返回删除的元素 (这里删除 1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> &amp;v &#123;              <span class="comment">// 只读遍历</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;          <span class="comment">// 可修改遍历</span></span><br><span class="line">    *x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h3><p>相当于c++中stl里的map</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 HashMap</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 增加（插入）元素</span></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 修改（如果 key 已存在，会覆盖旧值）</span></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);  <span class="comment">// Alice 的值从 10 -&gt; 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 访问（用 get，返回 Option&lt;&amp;V&gt;）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(score) = scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Alice 的分数是 &#123;&#125;&quot;</span>, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 删除（移除某个 key）</span></span><br><span class="line">    scores.<span class="title function_ invoke__">remove</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;拖了很久的rust逆向都一直没学,正好编译原理要做rust语法分析器,顺便把rust语言学一下&lt;/p&gt;
&lt;h2 id=&quot;rust相比其他</summary>
      
    
    
    
    <category term="rust逆向基础" scheme="http://example.com/categories/rust%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2025/09/29/hello-world/"/>
    <id>http://example.com/2025/09/29/hello-world/</id>
    <published>2025-09-29T10:04:44.807Z</published>
    <updated>2025-09-29T10:04:44.807Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
